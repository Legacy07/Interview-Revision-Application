<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--Java Technical Questions-->
    <string-array name="javaTechnicalQuestions">
        <item>
            Explain JVM, JRE and JDK?
        </item>
        <item>
            Explain public static void main(String args[]).
        </item>
        <item>
           Why Java is platform independent?
        </item>
        <item>
            Why java is not 100% Object-oriented?
        </item>
        <item>
            What are wrapper classes?
        </item>
        <item>
            What are constructors in Java?
        </item>
        <item>
            What is singleton class and how can we make a class singleton?
        </item>
        <item>
            What is the difference between Array list, Linked list and Vector?
        </item>
        <item>
            What is the difference between equals() and == ?
        </item>
        <item>
            What are the differences between Heap and Stack Memory?
        </item>
        <item>
           What is Polymorphism and runtime polymorphism or dynamic method dispatch?
        </item>
        <item>
           What is Inheritance?
        </item>
        <item>
           What is Abstraction?
        </item>
        <item>
           What is Encapsulation?
        </item>
        <item>
           What is the difference between abstract classes and interfaces?
        </item>
        <item>
           What is method overloading and method overriding?
        </item>
        <item>
            Can you override a private or static method in Java?
        </item>
        <item>
          What is multiple inheritance? Is it supported by Java?
        </item>
        <item>
           What is association?
        </item>
        <item>
           What do you mean by aggregation?
        </item>
        <item>
           What is composition in Java?
        </item>
        <item>
           What is the difference between Error &amp; Exception and how can you handle Java exceptions??
        </item>
        <item>
           What are the differences between Checked Exception and Unchecked Exception?
        </item>
        <item>
           What purpose does the keywords final, finally, and finalize fulfill?
        </item>
        <item>
           What are the differences between throw and throws?
        </item>
        <item>
            What is Exception Propagation?
        </item>
        <item>
           How to create a custom Exception?
        </item>
        <item>
          What are the important methods of Java Exception Class?
        </item>
        <item>
           What are the differences between processes and threads?
        </item>
        <item>
           What is synchronization?
        </item>
        <item>
            Can we write multiple catch blocks under single try block?
        </item>
        <item>
           What is the difference between double and float variables in Java?
        </item>
        <item>
            Why would it be more secure to store sensitive data (such as a password,
            social security number, etc.) in a character array rather than in a String?
        </item>
        <item>
           What is the ThreadLocal class? How and why would you use it?
        </item>
        <item>
           What is the volatile keyword? How and why would you use it?
        </item>
        <item>
           Compare the sleep() and wait() methods in Java, including when and why you would use one vs. the other.
        </item>
        <item>
           What is the Java Classloader? List and explain the purpose of the three types of class loaders.
        </item>
        <item>
           If one needs a Set, how do you choose between HashSet vs. TreeSet?
        </item>
        <item>
           How are Java enums more powerful than integer constants? How can this capability be used?
        </item>
        <item>
            What are static initializers and when would you use them?
        </item>
        <item>
            What is serialization? How do you implement it?
        </item>
    </string-array>

    <!--Java Technical Answers-->
    <string-array name="javaTechnicalAnswers">
        <!--Explain JVM, JRE and JDK?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>JVM </strong>(<strong>Java Virtual Machine</strong>): It is an abstract machine.<br />It is a specification that provides run-time environment in which java bytecode can be executed. It follows three notations:<br />- <strong>Specification</strong>: It is a document that describes the implementation of the Java virtual machine. It is provided by Sun and other companies.<br />- <strong>Implementation</strong>: It is a program that meets the requirements of JVM specification.<br />- <strong>Runtime Instance</strong>: An instance of JVM is created whenever you write a java command on the command prompt and run the class.<br /><br /><strong>JRE</strong> (<strong>Java Runtime Environment</strong>): JRE refers to a runtime environment in which java bytecode can be executed.<br />It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that<br />JVM uses at runtime. So JRE is a software package that contains what is required to run a Java program.<br />Basically, it\'s an implementation of the JVM which physically exists.<br /><br /><strong>JDK</strong> (<strong>Java Development Kit</strong>): It is the tool necessary to compile, document and package Java programs.<br />The JDK completely includes JRE which contains tools for Java programmers. The Java Development Kit is provided free of charge.<br />Along with JRE, it includes an interpreter/loader, a compiler (javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development. In short, it contains JRE + development tools.</p>
            </pre></html>
            ]]>
        </item>
        <!--Explain public static void main(String args[]).-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>public</strong>: Public is an access modifier, which is used to specify who can access this method. Public means that this Method will be accessible by any Class.<br />static: It is a keyword in java which identifies it is class based i.e it can be accessed without creating the instance of a Class.<br /><strong>void</strong>: It is the return type of the method. Void defines the method which will not return any value.<br /><strong>main</strong>: It is the name of the method which is searched by JVM as a starting point for an application with a particular signature only. It is the method where the main execution occurs.<br /><strong>String args[]</strong>: It is the parameter passed to the main method.</p>
            </pre></html>
            ]]>
        </item>
        <!--Why Java is platform independent?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Platform independent practically means "write once run anywhere". Java is called so because of its byte codes which can run on any system irrespective of its underlying operating system.</p>
            </pre></html>
            ]]>
        </item>
        <!--Why java is not 100% Object-oriented?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Java is not 100% Object-oriented because it makes use of eight primitive datatypes such as boolean, byte, char, int, float, double, long, short which are not objects.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are wrapper classes?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Wrapper classes converts the java primitives into the reference types (objects). Every primitive data type has a class dedicated to it. These are known as wrapper classes because they "wrap" the primitive data type into an object of that class.<br />Refer to the below image which displays different primitive type, wrapper class and constructor argument.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are constructors in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <p>In Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.<br /><br />There are two types of constructors:<br />1. Default constructor<br />2. Parameterized constructor</p>
             </pre></html>
            ]]>
        </item>
        <!--What is singleton class and how can we make a class singleton?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Singleton class is a class whose only one instance can be created at any given time, in one JVM. A class can be made singleton by making its constructor private.</p>
             </pre></html>
            ]]>
        </item>
        <!--What is the difference between Array list, Linked list and Vector?-->
        <item>
             <![CDATA[<html><pre style="text-align:center">
            <p>Their main difference is their implementation which causes different performance for different operations.<br />ArrayList is implemented as a resizable array. As more elements are added to ArrayList, its size is increased dynamically.<br />It\'s elements can be accessed directly by using the get and set methods, since ArrayList is essentially an array.<br /><br /><strong>LinkedList</strong> is implemented as a double linked list. Its performance on add and remove is better than Arraylist, but worse on get and set methods. Vector is similar with ArrayList, but it is synchronized.<br /><strong>ArrayList</strong> is a better choice if your program is thread-safe. Vector and ArrayList require space as more elements are added.<br /><br /><strong>Vector</strong> each time doubles its array size, while ArrayList grow 50% of its size each time. LinkedList, however, also implements Queue interface which adds more methods than ArrayList and Vector, such as offer(), peek(), poll(), etc.<br /><br /><strong>Note</strong>: The default initial capacity of an ArrayList is pretty small.<br />It is a good habit to construct the ArrayList with a higher initial capacity. This can avoid the resizing cost.<br />Also, Vector is deprecated.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between equals() and == ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Equals() method is defined in Object class in Java and used for checking equality of two objects defined by business logic.<br />"==" or equality operator in Java is a binary operator provided by Java programming language and used to compare primitives and objects. public boolean equals(Object o) is the method provided by the Object class.<br />The default implementation uses == operator to compare two objects.<br /><br />Therefore the equals() method compares the "value" inside String instances (on the heap) irrespective if the two object references refer to the same String instance or not.<br />On the other hand, the "==" operator compares the value of two object references to see whether they refer to the same String instance.<br /><br /><strong>For example</strong>: method can be overridden like String class. equals() method is used to compare the values of two objects.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between Heap and Stack Memory?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <p>Stack is used for static memory allocation and Heap for dynamic memory allocation, both stored in the computer\'s RAM .<br /><br />Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and it\'s allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO (Last in First out) order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.<br /><br />Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Element of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time.<br />This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.<br /><br />You can use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.<br />You can use heap if you don\'t know exactly how much data you will need at runtime or if you need to allocate a lot of data.<br /><br />In a multi-threaded situation each thread will have its own completely independent stack but they will share the heap.<br />Stack is thread specific and Heap is application specific. The stack is important to consider in exception handling and thread executions.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is Polymorphism and runtime polymorphism or dynamic method dispatch?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Polymorphism is briefly described as "one interface, many implementations".<br />Polymorphism is a characteristic of being able to assign a different meaning or usage to something in different contexts specifically, to allow an entity such as a variable, a function, or an object to have more than one form.<br />There are two types of polymorphism:<br />- Compile time polymorphism<br />- Run time polymorphism<br /><br />Compile time polymorphism is method overloading whereas Runtime time polymorphism is done using inheritance and interface.<br /><br />In Java, runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. In this process, an overridden method is called through the reference variable of a superclass.<br /><br /><strong>Example</strong>:</pre>
<pre style="margin: 0; line-height: 125%;"> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Car</em> <br /><em style="color: #333333;"> {</em>
 <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">run</em><em style="color: #333333;">()<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> System</em><em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">("</em><em style="background-color: #ffffff;">car is running"</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Audi</em> <em style="color: #008800; font-weight: bold;">extends</em><em style="background-color: #ffffff;"> Car<br /> </em><em style="color: #333333;">{<br /></em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">run</em><em style="color: #333333;">()<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> System</em><em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">prinltn</em><em style="color: #333333;">("</em><em style="background-color: #ffffff;">Audi is running safely with </em><em style="color: #0000dd; font-weight: bold;">100</em><em style="background-color: #ffffff;">km"</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">static</em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">main</em><em style="color: #333333;">(</em><em style="background-color: #ffffff;">String args</em><em style="color: #333333;">[])<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> Car b</em><em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em><em style="background-color: #ffffff;"> Audi</em><em style="color: #333333;">();</em>    <em style="color: #888888;">//upcasting<br /></em><em style="background-color: #ffffff;"> b</em><em style="color: #333333;">.</em><em style="color: #0000cc;">run</em><em style="color: #333333;">();<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #333333;">}</em>
</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is inheritance-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>Inheritance is the process wherein characteristics are inherited from ancestors. Similarly, in Java, a subclass inherits the characteristics (properties and methods) of its superclass (ancestor).<br />For example, a vehicle is a superclass and a car is a subclass. The car (subclass) inherits all of the vehicle&rsquo;s properties.<br />The inheritance mechanism is very useful in code reuse.<br />The following are some limitations of Java class inheritance: A subclass cannot inherit private members of its superclass.<br />Constructor and initializer blocks cannot be inherited by a subclass. A subclass can have only one superclass.<br /><br />The keyword "extends" is used to derive a subclass from the superclass, as illustrated by the following syntax:</pre>
<pre><em>class Name_of_subclass extends Name_of superclass</em><br />{ //new fields and methods that would define the subclass go here }<br /><br />If you want to derive a subclass Rectangle from a superclass Shapes, you can do it as follows:<br /><em>class Rectangle extends Shapes { &hellip;. }</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Abstraction?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<pre>Data Abstraction is the property by virtue of which only the essential details are displayed to the user.<br />The trivial or the non-essentials units are not displayed to the user.<br />E.g. A car is viewed as a car rather than its individual components.<br /><br />Data Abstraction may also be defined as the process of identifying only the required characteristics of an object ignoring the irrelevant details.The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the objects.<br /><br />Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of car or applying brakes will stop the car but he does not know about how on pressing the accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.<br /><br />In java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.<br /><br />Abstract classes and Abstract methods:<br />1. An abstract class is a class that is declared with abstract keyword.<br />2. An abstract method is a method that is declared without an implementation.<br />3. An abstract class may or may not have all abstract methods. Some of them can be concrete methods.<br />4. A method defined abstract must always be redefined in the subclass,thus making overriding compulsory OR either make subclass itself abstract.<br />5. Any class that contains one or more abstract methods must also be declared with abstract keyword.<br />6. There can be no object of an abstract class.That is, an abstract class can not be directly instantiated with the new operator.<br />7. An abstract class can have parametrized constructors and default constructor is always present in an abstract class.<br /><br />Consider a classic "shape" example, perhaps used in a computer-aided design system or game simulation.<br />The base type is "shape" and each shape has a color, size and so on. From this, specific types of shapes are derived(inherited)-circle, square, triangle and so on &ndash; each of which may have additional characteristics and behaviors.<br /><br />For example, certain shapes can be flipped. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.<br /><br /><strong>Example</strong>:</pre>
<pre style="margin: 0; line-height: 125%;"><em style="color: #008800; font-weight: bold;">abstract</em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Shape<br /></em><em style="color: #333333;">{<br /></em>String color<em style="color: #333333;">;<br /></em><br /><em style="color: #888888;">// these are abstract methods<br /></em><em style="color: #008800; font-weight: bold;">abstract</em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">();<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">abstract</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">();<br /></em><br /><em style="color: #888888;">// abstract class can have constructor<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Shape</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em> System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Shape constructor called"</em><em style="color: #333333;">);<br /></em> <em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">=</em> color<em style="color: #333333;">;<br /></em> <em style="color: #333333;">}<br /></em>
<br /><em style="color: #888888;">// this is a concrete method<br /></em><em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">getColor</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> color<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><em style="color: #333333;">}<br /></em><em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Circle</em> <em style="color: #008800; font-weight: bold;">extends</em> Shape<br /><em style="color: #333333;">{<br /></em><em style="color: #333399; font-weight: bold;">double</em> radius<em style="color: #333333;">;<br /></em><br /><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Circle</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> radius<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em><br /><em style="color: #888888;">// calling Shape constructor<br /></em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">(</em>color<em style="color: #333333;">);<br /></em> System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Circle constructor called"</em><em style="color: #333333;">);<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">radius</em> <em style="color: #333333;">=</em> radius<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /> <em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em> <em style="color: #008800; font-weight: bold;">return</em> Math<em style="color: #333333;">.</em><em style="color: #0000cc;">PI</em> <em style="color: #333333;">*</em> Math<em style="color: #333333;">.</em><em style="color: #0000cc;">pow</em><em style="color: #333333;">(</em>radius<em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">2</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> <em style="background-color: #fff0f0;">"Circle color is "</em> <em style="color: #333333;">+</em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">+<br /></em><em style="background-color: #fff0f0;">"and area is : "</em> <em style="color: #333333;">+</em> area<em style="color: #333333;">();<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Rectangle</em> <em style="color: #008800; font-weight: bold;">extends</em> Shape<em style="color: #333333;">{<br /></em>
<em style="color: #333399; font-weight: bold;">double</em> length<em style="color: #333333;">;<br /></em> <em style="color: #333399; font-weight: bold;">double</em> width<em style="color: #333333;">;<br /></em><br /><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Rectangle</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> length<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> width<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em> <em style="color: #888888;">// calling Shape constructor<br /></em><em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">(</em>color<em style="color: #333333;">);<br /></em>System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Rectangle constructor called"</em><em style="color: #333333;">);<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">length</em> <em style="color: #333333;">=</em> length<em style="color: #333333;">;<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">width</em> <em style="color: #333333;">=</em> width<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em> <em style="color: #008800; font-weight: bold;">return</em> length<em style="color: #333333;">*</em>width<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em><em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> <em style="background-color: #fff0f0;">"Rectangle color is "</em> <em style="color: #333333;">+</em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">+<br /></em><em style="background-color: #fff0f0;">"and area is : "</em> <em style="color: #333333;">+</em> area<em style="color: #333333;">();<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #333333;">}<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Test<br /></em><em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">static</em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">main</em><em style="color: #333333;">(</em>String<em style="color: #333333;">[]</em> args<em style="color: #333333;">)<br /></em><em style="color: #333333;">{<br /></em>Shape s1 <em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em> Circle<em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Red"</em><em style="color: #333333;">,</em> <em style="color: #6600ee; font-weight: bold;">2.2</em><em style="color: #333333;">);<br /></em>Shape s2 <em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em> Rectangle<em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Yellow"</em><em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">2</em><em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">4</em><em style="color: #333333;">);<br /></em><br />System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em>s1<em style="color: #333333;">.</em><em style="color: #0000cc;">toString</em><em style="color: #333333;">());<br /></em>System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em>s2<em style="color: #333333;">.</em><em style="color: #0000cc;">toString</em><em style="color: #333333;">());<br /></em><em style="color: #333333;">}<br /></em><em style="color: #333333;">}<br /></em>
</pre>
<pre><strong>Output</strong>:<br /><em> Shape constructor called</em><br /><em> Circle constructor called</em><br /><em> Shape constructor called</em><br /><em> Rectangle constructor called</em><br /><em> Circle color is Redand area is : 15.205308443374602</em><br /><em> Rectangle color is Yellowand area is : 8.0</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Encapsulation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.<br />To achieve encapsulation in Java; <br />- Declare the variables of a class as private.<br />- Provide public setter and getter methods to modify and view the variables values.<br /><br /><strong>Example</strong>:</pre>
<pre><em>/* File name : EncapTest.java */</em><br /><em>public class EncapTest {</em><br /><em>private String name;</em><br /><em>private String idNum;</em><br /><em>private int age;</em><br /><br /><em>public int getAge() {</em><br /><em>return age;</em><br /><em>}</em><br /><br /><em>public String getName() {</em><br /><em>return name;</em><br /><em>}</em><br /><br /><em>public String getIdNum() {</em><br /><em>return idNum;</em><br /><em>}</em><br /><br /><em>public void setAge( int newAge) {</em><br /><em>age = newAge;</em><br /><em>}</em><br /><br /><em>public void setName(String newName) {</em><br /><em>name = newName;</em><br /><em>}</em><br /><br /><em>public void setIdNum( String newId) {</em><br /><em>idNum = newId;</em><br /><em>}</em><br /><em>}</em><br /><br />The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class.<br />Normally, these methods are referred as getters and setters. Therefore, any class that wants to access the variables should<br />access them through these getters and setters.<br />The variables of the EncapTest class can be accessed using the following program; <br /><br /><em>/* File name : RunEncap.java */</em><br /><em>public class RunEncap {</em><br /><br /><em>   public static void main(String args[]) </em><br /><em>   {</em><br /><em>      EncapTest encap = new EncapTest();</em><br /><em>      encap.setName("James");</em><br /><em>      encap.setAge(20);</em><br /><em>      encap.setIdNum("12343ms");</em><br /><br /><em>      System.out.print("Name : " + encap.getName() + " Age : " + encap.getAge());</em><br /><em>   }</em><br /><em>}</em></pre>
<pre>This will produce the following result &minus;<br /><br /><strong>Output</strong><br />Name : James Age : 20</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between abstract classes and interfaces?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>The key technical differences between an <strong>abstract class</strong> and an <strong>interface</strong> are:<br /><br />- Abstract classes can have constants, members, method stubs (methods without a body) and defined methods, whereas interfaces can only have constants and methods stubs.<br /><br />- Methods and members of an abstract class can be defined with any visibility, whereas all methods of an interface must be defined as public (they are defined public by default).<br /><br />- When inheriting an abstract class, a concrete child class must define the abstract methods, whereas an abstract class can extend another abstract class and abstract methods from the parent class don\'t have to be defined.<br /><br />- Similarly, an interface extending another interface is not responsible for implementing methods from the parent interface. This is because interfaces cannot define any implementation.<br /><br />- A child class can only extend a single class (abstract or concrete), whereas an interface can extend or a class can implement multiple other interfaces.<br /><br />- A child class can define abstract methods with the same or less restrictive visibility, whereas a class implementing an interface must define the methods with the exact same visibility (public).</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is method overloading and method overriding?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre><strong>Method Overloading</strong>:<br />- In Method Overloading, Methods of the same class shares the same name but each method must have different number of parameters or parameters having different types and order.<br />- Method Overloading is to "add" or "extend" more to method\'s behavior.<br />- It is a compile time polymorphism.<br />- The methods must have different signature.<br />- It may or may not need inheritance in Method Overloading.</pre>
<pre> <br /><strong>Example</strong>:<br /><em>class Adder {</em><br /><em>Static int add(int a, int b)</em><br /><em>{</em><br /><em>return a+b;</em><br /><em>}</em><br /><em>Static double add( double a, double b)</em><br /><em>{</em><br /><em>return a+b;</em><br /><em>}</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>System.out.println(Adder.add(11,11));</em><br /><em>System.out.println(Adder.add(12.3,12.6));</em><br /><em>}}</em><br /><br /><strong>Method Overriding:</strong><br />- In Method Overriding, sub class have the same method with same name and exactly the same number and type of parameters and same return type as a super class.<br />- Method Overriding is to "Change" existing behavior of method.<br />- It is a run time polymorphism.<br />- The methods must have same signature.<br />- It always requires inheritance in Method Overriding.<br /><br /><strong>Example</strong>:<br /><em>class Car {</em><br /><em>void run(){</em><br /><em>System.out.println("car is running");</em><br /><em>}</em><br /><em>Class Audi extends Car{</em><br /><em>void run()</em><br /><em>{</em><br /><em>System.out.prinltn("Audi is running safely with 100km");</em><br /><em>}</em><br /><em>public static void main( String args[])</em><br /><em>{</em><br /><em>Car b=new Audi();</em><br /><em>b.run();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--Can you override a private or static method in Java?-->
        <item>
             <![CDATA[<html><pre style="text-align:center">
            <pre>You cannot override a private or static method in Java. If you create a similar method with same return type and same method arguments in child class then it will hide the super class method; this is known as method hiding. Similarly, you cannot override a private method in sub class because it\'s not accessible there. What you can do is create another private method with the same name in the child class.<br /><br /><strong>Example</strong>:<br /><em>class Base {</em><br /><em>private static void display() {</em><br /><em>System.out.println("Static or class method from Base");</em><br /><em>}</em><br /><em>public void print() {</em><br /><em>System.out.println("Non-static or instance method from Base");</em><br /><em>}</em><br /><em>class Derived extends Base {</em><br /><em>private static void display() {</em><br /><em>System.out.println("Static or class method from Derived");</em><br /><em>}</em><br /><em>public void print() {</em><br /><em>System.out.println("Non-static or instance method from Derived");</em><br /><em>}</em><br /><em>public class test {</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>Base obj= new Derived();</em><br /><em>obj1.display();</em><br /><em>obj1.print();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is multiple inheritance? Is it supported by Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>If a child class inherits the property from multiple classes is known as multiple inheritance. Java does not allow to extend multiple classes.<br />The problem with multiple inheritance is that if multiple parent classes have a same method name, then at runtime it becomes difficult for the compiler to decide which method to execute from the child class.<br />Therefore, Java doesn\'t support multiple inheritance. The problem is commonly referred as Diamond Problem.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Association? -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Association</strong> is a relationship where all object have their own lifecycle and there is no owner.<br />Let\'s take an example of Teacher and Student. Multiple students can associate with a single teacher and a single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. These relationship can be one to one, One to many, many to one and many to many.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What do you mean by aggregation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Aggregation</strong> is a specialized form of Association where all object have their own lifecycle but there is ownership and child object can not belongs to another parent object. Let\'s take an example of Department and teacher.<br />A single teacher can not belong to multiple departments, but if we delete the department teacher object will not destroy.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is composition in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Composition</strong> is again specialized form of Aggregation and we can call this as a "death" relationship.<br />It is a strong type of Aggregation. Child object dose not have their lifecycle and if parent object deletes all child object will also be deleted. Let\'s take again an example of relationship between House and rooms.<br />House can contain multiple rooms there is no independent life of room and any room can not belong to two different house if we delete the house room will automatically delete.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between Error & Exception and how can you handle Java exceptions??-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error.<br />These JVM errors you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.<br />While exceptions are conditions that occur because of bad input or human error etc.<br />e.g. FileNotFoundException will be thrown if the specified file does not exist.<br />Or a NullPointerException will take place if you try using a null reference.<br />In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc).<br /><br />There are five keywords used to handle exceptions in Java:<br />1. try<br />2. catch<br />3. finally<br />4. throw<br />5. throws</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between Checked Exception and Unchecked Exception?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre><strong>Checked Exception</strong><br />- The classes that extend Throwable class except RuntimeException and Error are known as checked exceptions.<br />- Checked exceptions are checked at compile-time.<br />- Example: IOException, SQLException etc.<br /><br /><strong>Unchecked Exception</strong><br />- The classes that extend RuntimeException are known as unchecked exceptions.<br />- Unchecked exceptions are not checked at compile-time.<br />- Example: ArithmeticException, NullPointerException etc.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What purpose does the keywords final, finally, and finalize fulfill?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Final</strong>:<br />Final is used to apply restrictions on class, method and variable. Final class can\'t be inherited, final method can\'t be overridden and final variable value can\'t be changed.<br /><br /><strong>Example</strong>:<br /><em>class FinalVarExample {</em><br /><br /><em>public static void main( String args[])</em><br /><em>{</em><br /><em>final int a=10;   // Final variable</em><br /><em>a=50;             //Error as value can\'t be changed</em><br /><em>}</em><br /><br /><strong>Finally:</strong><br />Finally is used to place important code, it will be executed whether exception is handled or not.<br /><br /><strong>Example</strong>:<br /><em>class FinallyExample {</em><br /><br /><em>public static void main(String args[]){</em><br /><em>try {</em><br /><em>int x=100;</em><br /><em>}</em><br /><em>catch(Exception e) {</em><br /><em>System.out.println(e);</em><br /><em>}</em><br /><em>finally {</em><br /><em>System.out.println("finally block is executing");}</em><br /><em>}}</em><br /><em>}</em><br /><br /><strong>Finalize</strong><br />Finalize is used to perform clean up processing just before object is garbage collected.<br /><br /><strong>Example</strong>:<br /><em>class FinalizeExample {</em><br /><br /><em>public void finalize() {</em><br /><em>System.out.println("Finalize is called");</em><br /><em>}</em><br /><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>FinalizeExample f1=new FinalizeExample();</em><br /><em>FinalizeExample f2=new FinalizeExample();</em><br /><em>f1= NULL;</em><br /><em>f2=NULL;</em><br /><em>System.gc();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between throw and throws?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>1. throws clause is used to declare an exception and throw keyword is used to throw an exception explicitly.<br />2. If we see syntax wise then throw is followed by an instance variable and throws is followed by exception class names.<br />3. The keyword throw is used inside method body to invoke an exception and throws clause is used in method declaration (signature).<br />4. You cannot declare multiple exceptions with throw. You can declare multiple exception e.g. public void method()throws IOException,SQLException.<br />5. Checked Exceptions can not be propagated with throw only because it is explicitly used to throw an particular exception. Checked exception can be propagated with throws.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is exception propagation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>After a method throws an exception, the runtime system searches the call stack for a method that contains a block of code(exception handler) that can handle the exception. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler.<br />Also, there\'s a note-worthy point: Only unchecked exceptions are propagated. Checked exceptions throw compilation error.<br /><br />Lets say, we have a chain of methods where method3() calls method2() and method2() calls method1(). So when<br />1) An exception occurs in the method3() and in method3() we don\'t have any exception handler.<br />2) Uncaught exception will be propagated downward in stack i.e it will check appropriate exception handler in the method2().<br />3) Again in method2 if we don\'t have any exception handler then again exception is propagated downward to method1() where it finds exception handler.<br /><br /><strong>Example</strong>:<br /><em>class ExceptionPropagation{</em><br /><br /><em>void method3(){</em><br /><em>      int result = 100 / 0;  //Exception Generated</em><br /><em>}</em><br /><br /><em>void method2(){</em><br /><em>      method3();</em><br /><em>}</em><br /><br /><em>void method1(){</em><br /><em>try{</em><br /><em>   method2();</em><br /><em>} catch(Exception e){</em><br /><em>System.out.println("Exception is handled here");</em><br /><em>}</em><br /><em>}</em><br /><br /><em>public static void main(String args[]){</em><br /><em>ExceptionPropagation obj=new ExceptionPropagation();</em><br /><em>obj.method1();</em><br /><em>System.out.println("Continue with Normal Flow...");</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Exception is handled here<br /><br />Continue with Normal Flow...</pre>
            </pre></html>
            ]]>
        </item>
        <!--How to create a custom Exception?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- class New1Exception extends Exception { }               // this will create Checked Exception<br />- class NewException extends IOException { }             // this will create Checked exception<br />- class NewException extends NullPointerException { }  // this will create UnChecked exception</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the important methods of Java Exception Class?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>Exception and all of it\'s subclasses doesn\'t provide any specific methods and all of the methods are defined in the base class Throwable.<br /><br />1. String getMessage() &ndash; This method returns the message String of Throwable and the message can be provided while creating the exception through it\'s constructor.<br />2. String getLocalizedMessage() &ndash; This method is provided so that subclasses can override it to provide locale specific message to the calling program. Throwable class implementation of this method simply use getMessage() method to return the exception message.<br />3. Synchronized Throwable getCause() &ndash; This method returns the cause of the exception or null id the cause is unknown.<br />4. String toString() &ndash; This method returns the information about Throwable in String format, the returned String contains the name of Throwable class and localized message.<br />5. void printStackTrace() &ndash; This method prints the stack trace information to the standard error stream, this method is overloaded and we can pass PrintStream or PrintWriter as argument to write the stack trace information to the file or stream.<br /><br /></pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between processes and threads?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Key difference: Thread and Process are two closely related terms in multi-threading.<br />The main difference between the two terms is that the threads are a part of a process, i.e. a process may contain one or more threads, but a thread cannot contain a process.<br /><br />In programming, there are two basic units of execution: processes and threads.<br />They both execute a series of instructions. Both are initiated by a program or the operating system.<br />This article helps to differentiate between the two units.<br /><br />Process A process is an instance of a program that is being executed. It contains the program code and its current activity.<br />Depending on the operating system, a process may be made up of multiple threads of execution that execute instructions concurrently. A program is a collection of instructions; a process is the actual execution of those instructions.<br /><br />A process has a self-contained execution environment. It has a complete set of private basic run-time resources;<br />in particular, each process has its own memory space. Processes are often considered similar to other programs or applications.<br />However, the running of a single application may in fact be a set of cooperating processes.<br />To facilitate communication between the processes, most operating systems use Inter Process Communication (IPC) resources, such as pipes and sockets. The IPC resources can also be used for communication between processes on different systems.<br />Most applications in a virtual machine run as a single process. However, it can create additional processes using a process builder object.<br /><br />In computers, a thread can execute even the smallest sequence of programmed instructions that can be managed independently by an operating system. The applications of threads and processes differ from one operating system to another.<br />However, the threads are made of and exist within a process; every process has at least one. Multiple threads can also exist in a process and share resources, which helps in efficient communication between threads.<br /><br />On a single processor, multitasking takes place as the processor switches between different threads; it is known as multithreading. The switching happens so frequently that the threads or tasks are perceived to be running at the same time.<br />Threads can truly be concurrent on a multiprocessor or multi-core system, with every processor or core executing the separate threads simultaneously.<br /><br />In summary, threads may be considered lightweight processes, as they contain simple sets of instructions and can run within a larger process. Computers can run multiple threads and processes at the same time.<br /><br />Comparison between <strong>Process</strong> and <strong>Thread</strong>:<br /><br /><strong>Process</strong>:<br />- An executing instance of a program is called a process.<br />- It has its own copy of the data segment of the parent process.<br />- Processes must use inter-process communication to communicate with sibling processes.<br />- Processes have considerable overhead.<br />- New processes require duplication of the parent process.<br />- Processes can only exercise control over child processes.<br />- Any change in the parent process does not affect child processes.<br />- Run in separate memory spaces.<br />- Most file descriptors are not shared.<br />- There is no sharing of file system context.<br />- It does not share signal handling.<br />- Process is controlled by the operating system.<br />- Processes are independent.<br /><br /><strong>Thread</strong>:<br />- A thread is a subset of the process.<br />- It has direct access to the data segment of its process.<br />- Threads can directly communicate with other threads of its process.<br />- Threads have almost no overhead.<br />- New threads are easily created.<br />- Threads can exercise considerable control over threads of the same process.<br />- Any change in the main thread may affect the behavior of the other threads of the process.<br />- Run in shared memory spaces.<br />- It shares file descriptors.<br />- It shares file system context.<br />- It shares signal handling.<br />- Threads are controlled by programmer in a program.<br />- Threads are dependent.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is synchronizations?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Synchronization</strong> refers to multi-threading. A synchronized block of code can be executed by only one thread at a time.<br />As Java supports execution of multiple threads, two or more threads may access the same fields or objects.<br />Synchronization is a process which keeps all concurrent threads in execution to be in sync. Synchronization avoids memory consistency errors caused due to inconsistent view of shared memory. When a method is declared as synchronized the thread holds the monitor for that method\'s object. If another thread is executing the synchronized method the thread is blocked until that thread releases the monitor.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Can we write multiple catch blocks under single try blocks?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>It is possible to have multiple catch blocks under single try block but the approach should be from specific to general.<br /><br /><strong>Example</strong>:<br /><em>public class Example {</em><br /><em>public static void main(String args[]) {</em><br /><em>try {</em><br /><em>int a[]= new int[10];</em><br /><em>a[10]= 10/0;</em><br /><em>}</em><br /><em>catch(ArithmeticException e)</em><br /><em>{</em><br /><em>System.out.println("Arithmetic exception in first catch block");</em><br /><em>}</em><br /><em>catch(ArrayIndexOutOfBoundsException e)</em><br /><em>{</em><br /><em>System.out.println("Array index out of bounds in second catch block");</em><br /><em>}</em><br /><em>catch(Exception e)</em><br /><em>{</em><br /><em>System.out.println("Any exception in third catch block");</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between double and float variables in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Though both float and double datatype are used to represent floating point numbers in Java, a double data type is more precise than float. A double variable can provide precision up to 15 to 16 decimal points as compared to float precision of 6 to 7 decimal digits. Another significant difference between float and double is their storage requirement, double is more expensive than float. It takes 8 bytes to store a variable while float just takes 4 bytes.<br />Which means, if memory is constraint than its better to use float than double. BTW, the double type also has larger range than float and if your numbers don\'t fit well in float then you have to use double in Java. It\'s also worth noting that floating point numbers or real numbers are by default double in Java. If you want to store them into float variable, you need to either cast them or use a prefix \'f\' or \'F\'.<br /><br /><strong>Also to note that</strong>: float uses 1 bits for sign, 8 bits for exponent and 23 bits for mantissa, while double uses 1 bits for sign, 11 bits for exponent and 52 bits for mantissa.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Why would it be more secure to store sensitive data (such as a password,
        social security number, etc.) in a character array rather than in a String?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In Java, Strings are immutable and are stored in the String pool.<br />What this means is that, once a String is created, it stays in the pool in memory until being garbage collected.<br />Therefore, even after you\'re done processing the string value (e.g., the password), it remains available in memory for an indeterminate period of time thereafter (again, until being garbage collected) which you have no real control over.<br />Therefore, anyone having access to a memory dump can potentially extract the sensitive data and exploit it.<br /><br />In contrast, if you use a mutable object like a character array, for example, to store the value, you can set it to blank once you are done with it with confidence that it will no longer be retained in memory.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the ThreadLocal class? How and why would you use it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A single ThreadLocal instance can store different values for each thread independently.<br />Each thread that accesses the get() or set() method of a ThreadLocal instance is accessing its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or transaction ID).<br />The example below, from the ThreadLocal Javadoc, generates unique identifiers local to each thread.<br />A thread\'s id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.<br /><br /><strong>Example</strong>:<br /><em>public class ThreadId {</em><br /><em> // Next thread ID to be assigned</em><br /><em>private static final AtomicInteger nextId = new AtomicInteger(0);</em><br /><br /><em>// Thread local variable containing each thread\'s ID</em><br /><em> private static final ThreadLocal&lt;Integer&gt; threadId =</em><br /><em> new ThreadLocal&lt;Integer&gt;() {</em><br /><em> @Override protected Integer initialValue() {</em><br /><em> return nextId.getAndIncrement();</em><br /><em> }</em><br /><em> };</em><br /><br /><em>// Returns the current thread\'s unique ID, assigning it if necessary</em><br /><em>public static int get() {</em><br /><em>return threadId.get();</em><br /><em>}</em><br /><em> }</em><br /><br />Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the volatile keyword? How and why would you use it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In Java, each thread has its own stack, including its own copy of variables it can access.<br />When the thread is created, it copies the value of all accessible variables into its own stack.<br />The volatile keyword basically says to the JVM "Warning, this variable may be modified in another Thread".<br /><br />In all versions of Java, the volatile keyword guarantees global ordering on reads and writes to a variable.<br />This implies that every thread accessing a volatile field will read the variable\'s current value instead of (potentially) using a cached value.<br /><br />In Java 5 or later, volatile reads and writes establish a happens-before relationship, much like acquiring and releasing a mutex.<br /><br />Using volatile may be faster than a lock, but it will not work in some situations. The range of situations in which volatile is effective was expanded in Java 5; in particular, double-checked locking now works correctly.<br /><br />The volatile keyword is also useful for 64-bit types like long and double since they are written in two operations.<br />Without the volatile keyword you risk stale or invalid values.<br /><br />One common example for using volatile is for a flag to terminate a thread. If you\'ve started a thread, and you want to be able to safely interrupt it from a different thread, you can have the thread periodically check a flag (i.e., to stop it, set the flag to true). By making the flag volatile, you can ensure that the thread that is checking its value will see that it has been set to true without even having to use a synchronized block.<br /><br /><strong>Example</strong>:<br /><em>public class Foo extends Thread {</em><br /><em>private volatile boolean close = false;</em><br /><em>public void run() {</em><br /><em>while(!close) {</em><br /><em>// do work</em><br /><em>}</em><br /><em>}</em><br /><em>public void close() {</em><br /><em>close = true;</em><br /><em>// interrupt here if needed</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--Compare the sleep() and wait() methods in Java, including when and why you would use one vs. the other.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>- sleep() is a blocking operation that keeps a hold on the monitor / lock of the shared object for the specified number of milliseconds.<br /><br />- wait(), on the other hand, simply pauses the thread until either (a) the specified number of milliseconds have elapsed or(b) it receives a desired notification from another thread (whichever is first), without keeping a hold on the monitor/lock of the shared object.<br /><br />- sleep() is most commonly used for polling, or to check for certain results, at a regular interval.<br />wait() is generally used in multithreaded applications, in conjunction with notify() / notifyAll(), to achieve synchronization and avoid race conditions.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Java Classloader? List and explain the purpose of the three types of the class loaders.        -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>The Java Classloader is the part of the Java runtime environment that loads classes on demand (lazy loading) into the JVM (Java Virtual Machine). Classes may be loaded from the local file system, a remote file system, or even the web.<br /><br />When the JVM is started, three class loaders are used:<br />1. Bootstrap Classloader: Loads core java API file rt.jar from folder.<br />2. Extension Classloader: Loads jar files from folder.<br />3. System/Application Classloader: Loads jar files from path specified in the CLASSPATH environment variable.</pre>
            </pre></html>
            ]]>
        </item>
        <!--if one needs a Set, how do you choose between HashSet vs TreeSet?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>At first glance, HashSet is superior in almost every way: O(1) add, remove and contains, vs. O(log(N)) for TreeSet.<br /><br />However, TreeSet is indispensable when you wish to maintain order over the inserted elements or query for a range of elements within the set.<br /><br />Consider a Set of timestamped Event objects. They could be stored in a HashSet, with equals and hashCode based on that timestamp. This is efficient storage and permits looking up events by a specific timestamp, but how would you get all events that happened on any given day? That would require a O(n) traversal of the HashSet, but it&rsquo;s only a O(log(n)) operation with TreeSet using the tailSet method;<br /><br /><em>public class Event implements Comparable&lt;Event&gt; {</em><br /><em>private final long timestamp;</em><br /><em><br />public Event(long timestamp) {</em><br /><em>      this.timestamp = timestamp;</em><br /><em>}</em><br /><br /><em>@Override <br />public int compareTo(Event that) {</em><br /><em>      return Long.compare(this.timestamp, that.timestamp);</em><br /><em>   }</em><br /><em>}</em><br /><em>         ...<br /></em><br /><em>SortedSet&lt;Event&gt; events = new TreeSet&lt;&gt;();</em><br /><em>events.addAll(...); // events come in</em><br /><br /><em>// all events that happened today</em><br /><em>long midnightToday = ...;</em><br /><em>events.tailSet(new Event(midnightToday));</em><br /><em>}</em><br /><br />If Event happens to be a class that we cannot extend or that doesn&rsquo;t implement Comparable, TreeSet allows us to pass in our own Comparator:<br /><br /><em>SortedSet&lt;Event&gt;; events = new TreeSet&lt;&gt;(</em><br /><em>    (left, right) -&gt; Long.compare(left.timestamp, right.timestamp));</em><br /><br />Generally speaking, TreeSet is a good choice when order matters and when reads are balanced against the increased cost of writes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How are Java enums more powerful than integer constants? How can this capability be used?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>Enums are essentially final classes with a fixed number of instances. They can implement interfaces but cannot extend another class.<br />This flexibility is useful in implementing the strategy pattern, for example, when the number of strategies is fixed.<br />Consider an address book that records multiple methods of contact. We can represent these methods as an enum and attach fields, like the filename of the icon to display in the UI, and any corresponding behaviour, like how to initiate contact via that method:<br /><br /><em>public enum ContactMethod {</em><br /><em>PHONE("telephone.png") {</em><br /><em>@Override public void initiate(User user) {</em><br /><em>    Telephone.dial(user.getPhoneNumber());</em><br /><em>    }</em><br /><em>},</em><br /><em>EMAIL("envelope.png") {</em><br /><em>@Override public void initiate(User user) {</em><br /><em>       EmailClient.sendTo(user.getEmailAddress());</em><br /><em>    }</em><br /><em>},</em><br /><em> SKYPE("skype.png") {</em><br /><em>     ...</em><br /><em>};</em><br /><br /><em>ContactMethod(String icon) {</em><br /><em>    this.icon = icon;</em><br /><em>}</em><br /><br /><em>private final String icon;</em><br /><br /><em>public abstract void initiate(User user);</em><br /><br /><em>public String getIcon() {</em><br /><em>     return icon;</em><br /><em>}</em><br /><em>}</em><br /><br />We can dispense with switch statements entirely by simply using instances of ContactMethod:<br /><br /><em>ContactMethod method = user.getPrimaryContactMethod();</em><br /><em>displayIcon(method.getIcon());</em><br /><em>method.initiate(user);</em><br /><br />This is just the beginning of what can be done with enums.<br />Generally, the safety and flexibility of enums means they should be used in place of integer constants, and switch statements can be eliminated with liberal use of abstract methods.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are static initializers and when would you use them?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A static initializer gives you the opportunity to run code during the initial loading of a class and it guarantees that this code will only run once and will finish running before your class can be accessed in any way.<br />They are useful for performing initialization of complex static objects or to register a type with a static registry, as JDBC drivers do.<br />Suppose you want to create a static, immutable Map containing some feature flags.<br />Java doesn\'t have a good one-liner for initializing maps, so you can use static initializers instead:<br /><br /><em>public static final Map&lt;String, Boolean&gt; FEATURE_FLAGS;</em><br /><em>static {</em><br /><em>Map&lt;String, Boolean&gt; flags = new HashMap&lt;&gt;();</em><br /><em>flags.put("frustrate-users", false);</em><br /><em>flags.put("reticulate-splines", true);</em><br /><em>flags.put(...);</em><br /><em>FEATURE_FLAGS = Collections.unmodifiableMap(flags);</em><br /><em>}<br /></em><br />Within the same class, you can repeat this pattern of declaring a static field and immediately initializing it, since multiple static initializers are allowed.</pre>
            </pre></html>
            ]]>
        </item>
        <!--what is serialization? how do you implement it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Serialization is the process of converting an object into a stream of bytes in order to store an object into memory, so that it can be recreated at a later time, while still keeping the object\'s original state and data.<br /><br />After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.<br /><br />Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.<br /><br />Classes ObjectInputStream and ObjectOutputStream are high-level streams that contain the methods for serializing and deserializing an object.<br /><br /><strong>Example</strong>:<br />Suppose that we have the following Employee class, which implements the Serializable interface;<br /><br /><em>public class Employee implements java.io.Serializable {</em><br /><em>public String name;</em><br /><em>public String address;</em><br /><em>public transient int SSN;</em><br /><em>public int number;</em><br /><br /><em>public void mailCheck() {</em><br /><em>      System.out.println("Mailing a check to " + name + " " + address);</em><br /><em>   }</em><br /><em>}</em><br /><br /><strong>Serializing an Object</strong>;<br /><em>import java.io.*;</em><br /><em>public class SerializeDemo {</em><br /><br /><em>public static void main(String [] args) {</em><br /><em>Employee e = new Employee();</em><br /><em> e.name = "Reyan Ali";</em><br /><em> e.address = "Phokka Kuan, Ambehta Peer";</em><br /><em> e.SSN = 11122333;</em><br /><em> e.number = 101;</em><br /><br /><em> try {</em><br /><em> FileOutputStream fileOut =</em><br /><em> new FileOutputStream("/tmp/employee.ser");</em><br /><em> ObjectOutputStream out = new ObjectOutputStream(fileOut);</em><br /><em> out.writeObject(e);</em><br /><em> out.close();</em><br /><em> fileOut.close();</em><br /><em> System.out.printf("Serialized data is saved in /tmp/employee.ser");</em><br /> <br /><em>} catch (IOException i) {</em><br /><em> i.printStackTrace();</em><br /><em> }</em><br /><em> }</em><br /><em> }</em><br /><br /><strong>Note</strong> &minus; When serializing an object to a file, the standard convention in Java is to give the file a .ser extension.<br /><br /><strong>Deserializing an Object</strong>;<br /><em>import java.io.*;</em><br /><em>public class DeserializeDemo {</em><br /><br /><em>public static void main(String [] args) {</em><br /><em>Employee e = null;</em><br /><br /><em>try {</em><br /><em> FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");</em><br /><em> ObjectInputStream in = new ObjectInputStream(fileIn);</em><br /><em> e = (Employee) in.readObject();</em><br /><em> in.close();</em><br /><em> fileIn.close();</em><br /> <br /><em>}</em><br /><em> catch (IOException i) {</em><br /><em> i.printStackTrace();</em><br /><em> return;</em><br /> <br /><em>}</em><br /><em> catch (ClassNotFoundException c) {</em><br /><em> System.out.println("Employee class not found");</em><br /><em> c.printStackTrace();</em><br /><em> return;</em><br /><em> }</em><br /><br /><em> System.out.println("Deserialized Employee...");</em><br /><em> System.out.println("Name: " + e.name);</em><br /><em> System.out.println("Address: " + e.address);</em><br /><em> System.out.println("SSN: " + e.SSN);</em><br /><em> System.out.println("Number: " + e.number);</em><br /><em>  }</em><br /><em> }</em><br /><br /><strong>Output</strong>:<br />Deserialized Employee...<br />Name: Reyan Ali<br />Address:Phokka Kuan, Ambehta Peer<br />SSN: 0<br />Number:101</pre>
            </pre></html>
            ]]>
        </item>
    </string-array>

    <!--Android Technical Questions-->
    <string-array name="androidTechnicalQuestions">
        <item>
            Why did you become an Android developer? What are some of the advantages of the Android platform?
        </item>
        <item>
            What are the latest Android versions? The most important Oreo new features?
        </item>
        <item>
            What Is the Google Android SDK?
        </item>
        <item>
            What is the Android Architecture?
        </item>
        <item>
            Describe the Android Framework.
        </item>
        <item>
             What is AAPT?
        </item>
        <item>
            Mention Native Android Actions?
        </item>
        <item>
            Describe Activities.
        </item>
        <item>
             What do you know about Material design?
        </item>
        <item>
            What’s the difference between Dialog and AlertDialog in Android?
        </item>
        <item>
            What’s the difference between FrameLayout, GridLayout, ConstraintLayout, LinearLayout and RelativeLayout and which has better performance?
        </item>
        <item>
            What are Intents and Describe three common use cases for using an Intent.
        </item>
        <item>
            Where should you use implicit and explicit intent?
        </item>
        <item>
            What is the function of an intent filter?
        </item>
        <item>
            What are containers?
        </item>
        <item>
             What do you think are some disadvantages of Android?
        </item>
        <item>
            What are the four essential states of an activity?
        </item>
        <item>
            What are the seven lifecycle methods of Android activity and what is their purpose?
        </item>
        <item>
            The last callback in the lifecycle of an activity is onDestroy().
            The system calls this method on your activity as the final signal that your activity instance is being completely
            removed from the system memory. Usually, the system will call onPause() and onStop() before calling onDestroy().
            Describe a scenario, though, where onPause() and onStop() would not be invoked.
        </item>
        <item>
            What is the importance of settings permissions in app development?
        </item>
        <item>
            Enumerate the three key loops when monitoring an activity.
        </item>
        <item>
            What is the difference between a fragment and an activity? Explain the relationship between the two.
        </item>
        <item>
            Which method is called only once in a fragment life cycle?
        </item>
        <item>
            When is the onStop() method invoked?
        </item>
        <item>
            What are the different states wherein a process is based?
        </item>
        <item>
            How to communicate between fragments?
        </item>
        <item>
            What is ANR, When does it occur and How can it be prevented?
        </item>
        <item>
            What role does Dalvik play in Android development?
        </item>
        <item>
            What is the AndroidManifest.xml?
        </item>
        <item>
            What is AIDL and What data types are supported?
        </item>
        <item>
            What is the difference between foreground and visible lifetime?
        </item>
        <item>
            What is the difference between a regular bitmap and a nine-patch image?
        </item>
        <item>
            How many types we can store data in Android Phone, which is better approaches
            in SharedPreferences and SQLite to save small data or large data ?
        </item>
        <item>
            What is SQLite? How does it differ from client-server database management systems?
        </item>
        <item>
            What is DDMS and what can it do?
        </item>
        <item>
            What is a ContentProvider and what is it typically used for?
        </item>
        <item>
            Under what condition could the code sample crash your application? How would you modify the code to avoid this potential problem?
            Explain your answer.
        </item>
        <item>
            Suppose that you are starting a service in an Activity as follows:
            \nIntent service = new Intent(context, MyService.class);
            \nstartService(service);
            \nwhere MyService accesses a remote server via an Internet connection.
            \nIf the Activity is showing an animation that indicates some kind of progress, what issue might you encounter and
            how could you address it?
        </item>
        <item>
            What is the difference between Service, IntentService, Thread and AsyncTask? How is each used?
        </item>
        <item>
            How to run the service even after killing the application in android ?
        </item>
        <item>
            Normally, in the process of carrying out a screen reorientation, the Android platform tears down the foreground activity
            and recreates it, restoring each of the view values in the activity’s layout.
            \nIn an app you’re working on, you notice that a view’s value is not being restored after screen reorientation.
            What could be a likely cause of the problem that you should verify, at a minimum, about that particular view?
        </item>
        <item>
            What is the relationship between the life cycle of an AsyncTask and an Activity?
            What problems can this result in? How can these problems be avoided?
        </item>
        <item>
            What is the difference between Serializable and Parcelable ? Which is best approach in Android ?
        </item>
        <item>
            What are "launch modes"? What are the two mechanisms by which they can be defined? What specific types of
            launch modes are supported?
        </item>
        <item>
            What is a broadcast receiver?
        </item>
        <item>
            When dealing with multiple resources, which one takes precedence?
        </item>

    </string-array>

    <!--Android Technical Answers -->
    <string-array name="androidTechnicalAnswers">
        <!--Why did you become an android developer? what are some of the advantages of the Android platform?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>You want a developer who really knows how to play to the strengths of your chosen platform.<br />Some key advantages of Android are listed below for your convenience.<br /><br />- <strong>Open Source</strong>: No licenses, no distribution or development fees.<br />- <strong>DVM</strong> (Dalvik Virtual Machine): DVM is a highly optimized virtual machine for mobile devices.<br />- <strong>Platform Diversity</strong>: Since Android is open-source, it has been adopted by a wide range of manufacturers of mobile devices.<br />- <strong>Experience with Java</strong>: Java is the language of choice for Android app development.<br /><br />Those who already have years of experience in Java will feel right at home developing for Android.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the latest Android versions? The most important Oreo new features?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Android Versions with Code names From 2015 which are supported by Google.<br />- October 2015: Marshmallow 6.0 - 6.0.1, API level 23<br />- August 2016: Nougat 7.0 - 7.1.2, API level 24 - 25<br />- August 2017: Oreo 8.0 - 8.1, API level 26 - 27<br />- May 2018: Android P (Beta) - 9, API level 28<br /><br /><strong>Noticeable Features</strong>:<br />- <strong>Power Saving</strong>:<br />For one, Google has put automatic limits on background app activities in the latest version of Android.<br />This means that the operating system will specifically limit background usage including broadcasts, background services, and location updates. This translates to less energy consumption by apps when you are not actively using them and longer battery life as a result.<br /><br />- <strong>Better and more Secure Apps</strong>:<br />Google is now very active in nudging developers towards optimizing their apps. Google Play Protect is a background service that will quietly analyze the behavior of apps in an effort to detect malware and, if found, automatically remove it from your device and from the Play Store itself (exactly how that part works is still a bit fuzzy right now).<br />Google is also being a bit stricter on developers when it comes to stability and performance.<br />If the app falls in the bottom 25 percent, the dev will get a warning and if there are no improvements, it might result in the app being pulled off the Google Play Store.<br /><br />- <strong>Preventing Boot Loops</strong>:<br />This is a great feature to be introduced in the new Android 8.0 Oreo. Rescue Party is a feature that helps prevent boot loops.<br />Boot loop, if you are unfamiliar with the term, is what happens when the device starts up and restarts immediately over and over.<br />When core systems are not running well, Android will take notice of that and try to return them to their default states.<br />If that doesn\'t work, it will reboot automatically in the Recovery Mode and provide the option of a factory reset as a last ditch effort.<br /><br />- <strong>Wi-Fi Aware</strong>:<br />Compatible smartphones will be able to use Neighbor Awareness Networking and communicate with nearby devices without an internet connection.<br />"Wi-Fi Aware continuously discovers other devices within a user\'s Wi-Fi range prior to association, making it easy to find nearby information and services available that match preferences set by the user. Wi-Fi Aware devices bring users a more interesting, relevant, and productive mobility experience. An individual in a subway station can connect to a person within proximity to play a game, while simultaneously receiving train schedule updates without the need for an internet connection.<br />Co-workers on a lunch break can establish peer-to-peer connections to share photos, while also maintaining a connection to the company network.<br />Wi-Fi Aware is a key enabler of a truly personalized social, local, and mobile experience and works well in crowded environments.<br />Wi-Fi Aware is poised for mass adoption, with native support available in the Android Oreo operating system."<br /><br />- <strong>Google Autofill</strong>:<br />Google resolves this annoyance by bringing Autofill password management to Android. This feature allows you to manage all of your passwords in a single place, and will result in an easier and more secure way to log into your accounts.<br />And the best part is that it syncs across devices, so if you\'ve used Google Autofill while browsing the internet with Chrome, you\'ll have access to all that log in information via your mobile device, too, as long as you\'re using the same Google Account.<br /><br />For developer features, check <a href="https://developer.android.com/about/versions/oreo/android-8.0">Android Developers</a>.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Google Android SDK?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>The Google Android SDK is a toolset that developers need in order to write apps on Android enabled devices.<br />It contains a graphical interface that emulates an Android driven handheld environment, allowing them to test<br />and debug their codes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Android Architecture?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The Android software stack is typically divided into the five main components detailed below.<br />- <strong>Linux Kernel</strong>: The base layer of an application that directly interfaces with the device hardware - this is the level that deals with hardware drivers like the camera, keypad, and display.<br />- <strong>Native Libraries</strong>: Resting on top of the Linux Kernel are a set of open-source libraries, including the SQLite database, libc, and the WebKit browser engine.<br />- <strong>Android Runtime</strong>: The Dalvik Virtual Machine is in the same level as the Native Libraries and allows every Android app to run its own processes.<br />- <strong>Application Framework</strong>: The next layer up provides higher-level services in the form of Java classes to applications on the device. The key services to know are the Activity Manager, Content Providers, Resource Manager, Notifications Manager, and the View System.<br />- <strong>Applications</strong>: The top layer is the Android App itself. This is the level where applications are actually installed, and the one developers are most familiar with.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Describe the Android Framework?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The Android Framework is an important aspect of the Android Architecture. Here you can find all the classes and methods that developers would need in order to write applications on the Android environment.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is AAPT?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>AAPT is short for Android Asset Packaging Tool. This tool provides developers with the ability to deal with zip-compatible archives, which includes creating, extracting as well as viewing its contents.<br />So It is the default tool of the Android SDK to pack all classes and resources in an APK file.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Mention Native Android actions?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The following non-comprehensive list shows some of the native actions available as static string constants in the Intent class.<br />When creating implicit Intents you can use these actions, called Activity Intents, to start Activities and sub-Activities within your own applications.<br /><br />- <strong>action_answer</strong>: Opens an Activity that handles incoming calls. Currently this is handled by the native in-call screen.<br /><br />- <strong>action_call</strong>: Brings up a phone dialer and immediately initiates a call using the number supplied in the Intent URI.<br />Generally it\'s considered better form to use action_dial if possible.<br /><br />- <strong>action_delete</strong>: Starts an Activity that lets you delete the data specified at the Intent\'s data URI.<br /><br />- <strong>action_dial</strong>: Brings up a dialer application with the number to dial pre-populated from the Intent URI.<br />By default this is handled by the native Android phone dialer. The dialer can normalize most number schemas:<br />for example, <em>tel:555-1234</em> and <em>tel:(212) 555 1212</em> are both valid numbers.<br /><br />- <strong>action_edit</strong>: Requests an Activity that can edit the data at the specified Intent URI.<br /><br />- <strong>action_insert</strong>: Opens an Activity capable of inserting new items into the Cursor specified in the Intent URI.<br />When called as a sub-Activity it should return a URI to the newly inserted item.<br /><br />- <strong>action_pick</strong>: Launches a sub-Activity that lets you pick an item from the Content Provider specified by the Intent URI.<br />When closed it should return a URI to the item that was picked. The Activity launched depends on the data being picked:<br />for example, passing <em>content://contacts/people</em> will invoke the native contacts list.<br /><br />- <strong>action_search</strong>: Launches the Activity used for performing a search. Supply the search term as a string in the Intent\'s<br />extras using thffiearchManager.QUERY key.<br /><br />- <strong>action_sendto</strong>: Launches an Activity to send a message to the contact specified by the Intent URI.<br /><br />- <strong>action_send</strong>: Launches an Activity that sends the data specified in the Intent. The recipient contact needs to be selected by the resolved Activity. Use setType to set the MIME type of the transmitted data.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Describe Activities.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).<br />While activities are often presented to the user as full-screen windows, they can also be used in other ways:<br />as floating windows (via a theme with windowIsFloating set) or embedded inside of another activity (using ActivityGroup).<br />There are two methods almost all subclasses of Activity will implement:<br /><br />- <strong>onCreate(Bundle)</strong> is where you initialize your activity.<br />Most importantly, here you will usually call setContentView(int) with a layout resource defining your UI, and using<br /><br />- <strong>onPause()</strong> is where you deal with the user leaving your activity. Most importantly, any changes made by the user should at this point be committed (usually to the ContentProvider holding the data).<br /><br />To be of use with Context.startActivity(), all activity classes must have a corresponding &lt;activity&gt;;<br />declaration in their package\'s AndroidManifest.xml.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What do you know about Material Design-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
             <pre>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.<br />To use material design in Android apps, follow the guidelines and use the new components and styles available in the material design support library.<br /><br />Android provides the following features to help you build material design apps:<br /><br />- A material design app theme to style all your UI widgets<br />- Widgets for complex views such as lists and cards<br />- New APIs for custom shadows and animations</pre>
             </pre></html>
            ]]>
        </item>
        <!--What's the difference between Dialog and AlertDialog Android?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Dialogs in Android are used to shows alerts for making decisions or to edit a single value.<br />But there are some differences between an AlertDialog and a BasicDialog.<br />In an AlertDialog you always want to show a message and at least one Button for user interaction.<br />In a BasicDialog you have a custom view to a TextView or something more complex.<br /><br />Furthermore AlertDialog is derived from Dialog and provides additional functionality in terms of Dialog Title, Icon, 3 lines of message you can display to the user.<br />It also provides for lists, checkboxes etc. So you can decide which one to choose yourself.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What’s the difference between FrameLayout, GridLayout, ConstraintLayout, LinearLayout and RelativeLayout
        and which has better performance?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- <strong>ConstraintLayout</strong>: ConstraintLayout allows you to create large and complex layouts with a flat view hierarchy (no nested view groups). It\'s similar to RelativeLayout in that all views are laid out according to relationships between sibling views and the parent layout, but it\'s more flexible than RelativeLayout and easier to use with Android Studio\'s Layout Editor.<br />All the power of ConstraintLayout is available directly from the Layout Editor\'s visual tools, because the layout API and the Layout Editor were specially built for each other. So you can build your layout with ConstraintLayout entirely by drag-and-dropping instead of editing the XML.<br /><br />- <strong>FrameLayout</strong>: FrameLayout is designed to block out an area on the screen to display a single item. Generally, FrameLayout should be used to hold a single child view, because it can be difficult to organize child views in a way that\'s scalable to different screen sizes without the children overlapping each other. You can, however, add multiple children to a FrameLayout and control their position within the FrameLayout by assigning gravity to each child, using the android:layout_gravity attribute.<br />Child views are drawn in a stack, with the most recently added child on top. The size of the FrameLayout is the size of its largest child (plus padding), visible or not (if the FrameLayout\'s parent permits). Views that are GONE are used for sizing only if setConsiderGoneChildrenWhenMeasuring() is set to true.<br /><br />- <strong>GridLayout</strong>: A layout that places its children in a rectangular grid.<br />The grid is composed of a set of infinitely thin lines that separate the viewing area into cells.<br />Throughout the API, grid lines are referenced by grid indices. A grid with N columns has N + 1 grid indices that run from 0 through N inclusive. Regardless of how GridLayout is configured, grid index 0 is fixed to the leading edge of the container and grid index N is fixed to its trailing edge (after padding is taken into account).<br /><br />- <strong>LinearLayout</strong>: LinearLayout is a view group that aligns all children in a single direction, vertically or horizontally. You can specify the layout direction with the android:orientation attribute.<br />All children of a LinearLayout are stacked one after the other, so a vertical list will only have one child per row, no matter how wide they are, and a horizontal list will only be one row high (the height of the tallest child, plus padding).<br />A LinearLayout respects margins between children and the gravity (right, center, or left alignment) of each child.<br /><br />- <strong>RelativeLayout</strong>: RelativeLayout is a view group that displays child views in relative positions.<br />The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent RelativeLayout area (such as aligned to the bottom, left or center).<br />A RelativeLayout is a very powerful utility for designing a user interface because it can eliminate nested view groups and keep your layout hierarchy flat, which improves performance. If you find yourself using several nested LinearLayout groups, you may be able to replace them with a single RelativeLayout.<br /><br /><strong>Conclusion</strong>: A detailed performance testing is made in <a href="https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html">Android Developers</a>.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are intents and Describe three common use cases for using an Intent.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>An Intent is a messaging object you can use to request an action from another app component.<br />Although intents facilitate communication between components in several ways, there are three fundamental use cases:<br /><br />- <strong>Starting an Activity</strong>:<br />An Activity represents a single screen in an app. You can start a new instance of an Activity by passing an Intent to startActivity(). The Intent describes the activity to start and carries any necessary data.<br />\nIf you want to receive a result from the activity when it finishes, call startActivityForResult(). Your activity receives the result as a separate Intent object in your activity\'s onActivityResult() callback. For more information, see the Activities guide.<br /><br />- <strong>Starting a Service</strong>:<br />A Service is a component that performs operations in the background without a user interface.<br />With Android 5.0 (API level 21) and later, you can start a service with JobScheduler.<br />For more information about JobScheduler, see its API-reference documentation.<br />For versions earlier than Android 5.0 (API level 21), you can start a service by using methods of the Service class.<br />You can start a service to perform a one-time operation (such as downloading a file) by passing an Intent to startService().<br />The Intent describes the service to start and carries any necessary data.<br />If the service is designed with a client-server interface, you can bind to the service from another component by passing an Intent to bindService(). For more information, see the Services guide.<br /><br />- <strong>Delivering a Broadcast</strong>:<br />A broadcast is a message that any app can receive. The system delivers various broadcasts for system events, such as when the system boots up or the device starts charging. You can deliver a broadcast to other apps by passing an Intent to sendBroadcast() or sendOrderedBroadcast().<br /><br />There are two types of <strong>intents</strong>:<br /><br />-<strong> Explicit intents</strong> specify which application will satisfy the intent, by supplying either the target app\'s package name or a fully-qualified component class name. You\'ll typically use an explicit intent to start a component in your own app, because you know the class name of the activity or service you want to start. For example, you might start a new activity within your app in response to a user action, or start a service to download a file in the background.<br /><br />- <strong>Implicit intents</strong> do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Where should you use implicit and explicit intent? -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- You\'ll typically use an explicit intent to start a component in your own app, because you know the class name of the activity or service you want to start. For example, you might start a new activity within your app in response to a user action, or start a service to download a file in the background.<br /><br />- Implicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the function of an intentfilter?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Specifies the types of intents that an activity, service, or broadcast receiver can respond to.<br />An intent filter declares the capabilities of its parent component &mdash; what an activity or service can do and what types of broadcasts a receiver can handle. It opens the component to receiving intents of the advertised type, while filtering out those that are not meaningful for the component.<br /><br />Most of the contents of the filter are described by its &lt;action&gt;, &lt;category&gt;, and &lt;data&gt; subelements.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are containers?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Containers, as the name itself implies, holds objects and widgets together, depending on which specific items are needed and in what particular arrangement that is wanted. Containers may hold labels, fields, buttons, or even child containers, as examples.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What do you think are some disadvantages of Android?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>Given that Android is an open-source platform, and the fact that different Android operating systems have been released on different mobile devices, there\'s no clear cut policy to how applications can adapt with various OS versions and upgrades.<br />One app that runs on this particular version of Android OS may or may not run on another version. Another disadvantage is that since mobile devices such as phones and tabs come in different sizes and forms, it poses a challenge for developers to create apps that can adjust correctly to the right screen size and other varying features and specs.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the four essential states of an activity?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Active</strong> &ndash; if the activity is at the foreground.<br /><strong>Paused</strong> &ndash; if the activity is at the background and still visible.<br /><strong>Stopped</strong> &ndash; if the activity is not visible and therefore is hidden or obscured by another activity.<br /><strong>Destroyed</strong> &ndash; when the activity process is killed or completed terminated.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the seven lifecycle methods of Android activity and what is their purpose?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The seven lifecycle methods of Android activity are onCreate(), onStart(), onRestart(), onResume(), onPause(), onStop(), and onDestroy(). Their purpose is to help structure your code around how you want an activity to perform throughout its lifecycle on the device.<br /><br />For example, onCreate() is where you would perform your static setup, from creating views to binding data to lists.<br />It is always immediately followed by onStart(), where the app will be made visible to the user.<br /><br />What you\'re looking for in their response is a solid grasp of the lifecycle of an Android app.<br />The functions of these methods are pretty self-explanatory based on their names.</pre>
           </pre></html>
            ]]>
        </item>
        <!--The last callback in the lifecycle of an activity is onDestroy().
        The system calls this method on your activity as the final signal that your activity instance is being completely
        removed from the system memory. Usually, the system will call onPause() and onStop() before calling onDestroy().
        Describe a scenario, though, where onPause() and onStop() would not be invoked.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>onPause() and onStop() will not be invoked if finish() is called from within the onCreate() method.<br />This might occur, for example, if you detect an error during onCreate() and call finish() as a result.<br />In such a case, though, any cleanup you expected to be done in onPause() and onStop() will not be executed.<br /><br />Although onDestroy() is the last callback in the lifecycle of an activity, it is worth mentioning that this callback may not always be called and should not be relied upon to destroy resources. It is better have the resources created in onStart() and onResume(), and have them destroyed in onStop() and onPause(), respectively.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the importance of settings permissions in app development?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The purpose of a permission is to protect the privacy of an Android user. Android apps must request permission to access sensitive user data (such as contacts and SMS), as well as certain system features (such as camera and internet).<br />Depending on the feature, the system might grant the permission automatically or might prompt the user to approve the request.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Enumerate the three key loops when monitoring an activity-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Entire lifetime</strong> &ndash; activity happens between onCreate and onDestroy.<br /><strong>Visible lifetime</strong> &ndash; activity happens between onStart and onStop.<br /><strong>Foreground lifetime</strong> &ndash; activity happens between onResume and onPause.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the difference between a fragment and an activity? Explain the relationship between the two.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An activity is typically a single, focused operation that a user can perform (such as dial a number, take a picture, send an email, view a map, etc.). Yet at the same time, there is nothing that precludes a developer from creating an activity that is arbitrarily complex.<br /><br />Activity implementations can optionally make use of the Fragment class for purposes such as producing more modular code, building more sophisticated user interfaces for larger screens, helping scale applications between small and large screens, and so on. Multiple fragments can be combined within a single activity and, conversely, the same fragment can often be reused across multiple activities. This structure is largely intended to foster code reuse and facilitate economies of scale.<br /><br />A fragment is essentially a modular section of an activity, with its own lifecycle and input events, and which can be added or removed at will. It is important to remember, though, that a fragment\'s lifecycle is directly affected by its host activity\'s lifecycle; i.e., when the activity is paused, so are all fragments in it, and when the activity is destroyed, so are all of its fragments.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Which method is called only once in a fragment life cycle?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
        <pre>- <strong>onAttached()</strong>;</pre>
        </pre></html>
            ]]>
        </item>
        <!--When is the onStop() method invoked?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>A call to onStop method happens when an activity is no longer visible to the user, either because another activity has taken over or if in front of that activity.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the different states wherein a process is based?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>There are 4 possible states:<br />&ndash; <strong>foreground activity</strong><br />&ndash; <strong>visible activity</strong><br />&ndash; <strong>background activity</strong><br />&ndash; <strong>empty process</strong></pre>
            </pre></html>
            ]]>
        </item>
        <!--How to communicate between fragments?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>In order to reuse the Fragment UI components, you should build each as a completely self-contained, modular component that defines its own layout and behavior. Once you have defined these reusable Fragments, you can associate them with an Activity and connect them with the application logic to realize the overall composite UI.<br /><br />Often you will want one Fragment to communicate with another, for example to change the content based on a user event.<br />All Fragment-to-Fragment communication is done either through a shared ViewModel or through the associated Activity.<br />Two Fragments should never communicate directly.<br /><br />To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.<br /><br /><strong>Example</strong>:<strong> Define an Interface;</strong><br /><em>public class HeadlinesFragment extends ListFragment {</em><br /><em>OnHeadlineSelectedListener mCallback;</em><br /><br /><em>// Container Activity must implement this interface</em><br /><br /><em>public interface OnHeadlineSelectedListener {</em><br /><em>public void onArticleSelected(int position);</em><br /><em>    }</em><br /><br /><em>@Override</em><br /><em>public void onAttach(Activity activity) {</em><br /><em>      super.onAttach(activity);</em><br /><br /><em>// This makes sure that the container activity has implemented</em><br /><em>// the callback interface. If not, it throws an exception</em><br /><em>try {</em><br /><em>    mCallback = (OnHeadlineSelectedListener) activity;</em><br /><em>  } catch (ClassCastException e) {</em><br /><em>throw new ClassCastException(activity.toString()</em><br /><em>+ " must implement OnHeadlineSelectedListener");</em><br /><em>}</em><br /><em>}</em><br /><br /><em>          ...</em><br /><em>}</em><br /><br />Now the fragment can deliver messages to the activity by calling the onArticleSelected() method (or other methods in the interface) using the mCallback instance of the OnHeadlineSelectedListener interface.<br /><br />For example, the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.<br /><br /><strong>Implement The Interface;</strong><br />In order to receive event callbacks from the fragment, the activity that hosts it must implement the interface defined in the fragment class.<br /><br /><em>public static class MainActivity extends Activity</em><br /><em>implements HeadlinesFragment.OnHeadlineSelectedListener{</em><br /><em> ...</em><br /><br /><em>public void onArticleSelected(int position) {</em><br /><em> // The user selected the headline of an article from the HeadlinesFragment</em><br /><em> // Do something here to display that article</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Deliver a Message to a Fragment;</strong><br />The host activity can deliver messages to a fragment by capturing the Fragment instance with findFragmentById(), then directly call the fragment\'s public methods.<br />For instance, imagine that the activity shown above may contain another fragment that\'s used to display the item specified by the data returned in the above callback method. In this case, the activity can pass the information received in the callback method to the other fragment that will display the item:<br /><br /><em>public static class MainActivity extends Activity</em><br /><em>implements HeadlinesFragment.OnHeadlineSelectedListener{</em><br /><em> ...</em><br /><br /><em>public void onArticleSelected(int position) {</em><br /><em>    // The user selected the headline of an article from the HeadlinesFragment</em><br /><em>    // Do something here to display that article</em><br /><br /><em>       ArticleFragment articleFrag = (ArticleFragment)</em><br /><em>       getSupportFragmentManager().findFragmentById(R.id.article_fragment);</em><br /><br /><em>          if (articleFrag != null) {</em><br /><em>       // If article frag is available, we\'re in two-pane layout...</em><br /><br /><em>          // Call a method in the ArticleFragment to update its content</em><br /><em>       articleFrag.updateArticleView(position);</em><br /><em>    } else {</em><br /><em> // Otherwise, we\'re in the one-pane layout and must swap frags...</em><br /><br /><em>          // Create fragment and give it an argument for the selected article</em><br /><em> ArticleFragment newFragment = new ArticleFragment();</em><br /><em> Bundle args = new Bundle();</em><br /><em> args.putInt(ArticleFragment.ARG_POSITION, position);</em><br /><em> newFragment.setArguments(args);</em><br /><br /><em> FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</em><br /><br /><em>       // Replace whatever is in the fragment_container view with this fragment,</em><br /><em>       // and add the transaction to the back stack so the user can navigate back</em><br /><em>    transaction.replace(R.id.fragment_container, newFragment);</em><br /><em> transaction.addToBackStack(null);</em><br /><br /><em>          // Commit the transaction</em><br /><em>       transaction.commit();</em><br /><em>    }</em><br /><em> }</em><br /><em> }</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is ANR, when does it occur and how can it be prevented?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>\'ANR\' in Android is \'Application Not Responding.\' It means when the user is interacting with the activity, and the activity is in the onResume() method, a dialog appears displaying "application not responding."<br /><br />It happens because we start a heavy and long running task like downloading data in the main UI thread.<br />To avoid ANR, an app should perform lengthy database or networking operations in separate threads.<br />For background task-intensive apps, you can alleviate pressure from the UI thread by using the IntentService.<br />Other solution can be to perform your heavy tasks in the background using Async Task class.<br /><br />In general, it helps to always define time-outs for all your web service calls and to remain ever vigilant for infinite loops in complex calculations.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What role does Dalvik play in Android development?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            Dalvik serves as a virtual machine, and it is where every Android application runs.
            Through Dalvik, a device is able to execute multiple virtual machines efficiently through better memory management.
            </pre></html>
            ]]>
        </item>
        <!--What is the AndroidManifest.xml?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Every app project must have an AndroidManifest.xml file (with precisely that name) at the root of the project source set.<br />The manifest file describes essential information about your app to the Android build tools, the Android operating system, and Google Play.<br /><br />Among many other things, the manifest file is required to declare the following:<br /><br />- The app\'s package name, which usually matches your code\'s namespace. The Android build tools use this to determine the location of code entities when building your project. When packaging the app, the build tools replace this value with the application ID from the Gradle build files, which is used as the unique app identifier on the system and on Google Play.<br /><br />- The components of the app, which include all activities, services, broadcast receivers, and content providers.<br />Each component must define basic properties such as the name of its Kotlin or Java class. It can also declare capabilities such as which device configurations it can handle, and intent filters that describe how the component can be started.<br /><br />- The permissions that the app needs in order to access protected parts of the system or other apps.<br />It also declares any permissions that other apps must have if they want to access content from this app.<br /><br />- The hardware and software features the app requires, which affects which devices can install the app from Google Play.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is AIDL and What data types are supported by AIDL?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>AIDL, or Android Interface Definition Language, handles the interface requirements between a client and a service so both can communicate at the same level through interprocess communication or IPC. This process involves breaking down objects into primitives that Android can understand. This part is required simply because a process cannot access the memory of the other process.<br /><br />AIDL has support for the following data types:<br />- string<br />- charSequence<br />- List<br />- Map<br />- all native Java data types like int,long, char and Boolean</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between foreground and visible lifetime?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>The Visible Lifetime</strong>: Although this is termed the "visible lifetime", the app may not be directly visible and interacting with the user at any one time if it is not in the foreground. The feature that distinguishes this lifetime is that, even if not in the foreground, the app maintains resources such that it can instantaneously return to the foreground.<br /><br /><strong>The Foreground Lifetime</strong>: During foreground lifetime the activity is in front of all other activities and interacting with the user.<br /><br />So If you display an Activity on the screen and the user is interacting with it, it is both in the foreground and visible.<br />Between onResume() and onPause() called foreground lifetime.<br /><br />If you start another Activity, which is transparent and shows a dialog box over the previous Activity, then the new Activity (the dialog box) is in the foreground and the old Activity is not in the foreground but still visible.<br />Between onStart() and onStop() called visible lifetime.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between a regular bitmap and a nine-patch image?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In general, a Nine-patch image allows resizing that can be used as background or other image size requirements for the target device. The Nine-patch refers to the way you can resize the image: 4 corners that are unscaled, 4 edges that are scaled in 1 axis, and the middle one that can be scaled into both axes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How many types we can store data in Android Phone, which is better approaches
        in SharedPreferences and SQLite to save small data or large data ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Android provides several options for you to save your app data. The solution you choose depends on your specific needs, such as how much space your data requires, what kind of data you need to store, and whether the data should be private to your app or accessible to other apps and the user.<br /><br />The different data storage options available on Android:<br /><br />- <strong>Internal file storage</strong>: Store app-private files on the device file system.<br />- <strong>External file storage</strong>: Store files on the shared external file system. This is usually for shared user files, such as photos.<br />- <strong>Shared preferences</strong>: Store private primitive data in key-value pairs.<br />- <strong>Databases</strong>: Store structured data in a private database.<br /><br /><strong>Internal File Storage</strong>:<br /><em>Internal Storage</em><br />By default, files saved to the internal storage are private to your app, and other apps cannot access them (nor can the user, unless they have root access). This makes internal storage a good place for internal app data that the user doesn\'t need to directly access. The system provides a private directory on the file system for each app where you can organize any files your app needs.<br /><br />When the user uninstalls your app, the files saved on the internal storage are removed. Because of this behavior, you should not use internal storage to save anything the user expects to persist independently of your app. For example, if your app allows users to capture photos, the user would expect that they can access those photos even after they uninstall your app. So you should instead save those types of files to the public external storage.<br /><br /><em>Internal cache files</em><br />If you\'d like to keep some data temporarily, rather than store it persistently, you should use the special cache directory to save the data. Each app has a private cache directory specifically for these kinds of files. When the device is low on internal storage space, Android may delete these cache files to recover space.<br />However, you should not rely on the system to clean up these files for you. You should always maintain the cache files yourself and stay within a reasonable limit of space consumed, such as 1MB. When the user uninstalls your app, these files are removed.<br /><br /><strong>External File Storage</strong>:<br />Every Android device supports a shared "external storage" space that you can use to save files. This space is called external because it\'s not a guaranteed to be accessible&mdash;it is a storage space that users can mount to a computer as an external storage device, and it might even be physically removable (such as an SD card). Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer.<br /><br />So before you attempt to access a file in external storage in your app, you should check for the availability of the external storage directories as well as the files you are trying to access.<br /><br />Most often, you should use external storage for user data that should be accessible to other apps and saved even if the user uninstalls your app, such as captured photos or downloaded files. The system provides standard public directories for these kinds of files, so the user has one location for all their photos, ringtones, music, and such.<br /><br /><strong>Shared Preferences</strong>:<br />If you don\'t need to store a lot of data and it doesn\'t require structure, you should use SharedPreferences.<br />The SharedPreferences APIs allow you to read and write persistent key-value pairs of primitive data types:<br />booleans, floats, ints, longs, and strings.<br /><br />The key-value pairs are written to XML files that persist across user sessions, even if your app is killed. You can manually specify a name for the file or use per-activity files to save your data.<br /><br />The API name "shared preferences" is a bit misleading because the API is not strictly for saving "user preferences," such as what ringtone a user has chosen. You can use SharedPreferences to save any kind of simple data, such as the user\'s high score.<br /><br /><strong>Databases</strong>:<br />Android provides full support for SQLite databases. Any database you create is accessible only by your app.<br /><br />The SQLite APIs are fairly low-level and require a great deal of time and effort to use. For example:<br /><br />There is no compile-time verification of raw SQL queries.<br />As your schema changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.<br />You need to write lots of boilerplate code to convert between SQL queries and Java data objects.<br /><br />The Room persistence library takes care of these concerns for you while providing an abstraction layer over SQLite.<br />Therefore the Room library provides an object-mapping abstraction layer that allows fluent database access while harnessing the full power of SQLite.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is SQLite? How does it differ from client-server database management systems?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>SQLite is the open-source relational database of choice for Android applications. The SQLite engine is serverless, transactional, and self-contained. Instead of the typical client-server relationship of most database management systems, the SQLite engine is integrally linked with the application. The library can also be called dynamically, and makes use of simple function calls that reduce latency in database access.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is DDMS and what can it do?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>DDMS is short for Dalvik Debug Monitor Server. It ships natively with Android and contains a number of useful debugging features including:<br />- location data spoofing<br />- port-forwarding<br />- network traffic tracking<br />- incoming call/SMS spoofing<br />- thread and heap information<br />- screen capture<br />- and the ability to simulate network state, speed and latency.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is a ContentProvider and what is it typically used for?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <pre>A ContentProvider manages access to a structured set of data. It encapsulates the data and provide mechanisms for defining data security. ContentProvider is the standard interface that connects data in one process with code running in another process.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Under what condition could the code sample below crash your application? How would you modify the code to avoid this -->
        <!--potential problem? Explain your answer.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Sample Code</strong>:<br /><em>Intent sendIntent = new Intent();</em><br /><em>sendIntent.setAction(Intent.ACTION_SEND);</em><br /><em>sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</em><br /><em>sendIntent.setType(HTTP.PLAIN_TEXT_TYPE); // "text/plain" MIME type</em><br /><em>startActivity(sendIntent);</em><br /><br />An implicit intent specifies an action that can invoke any app on the device able to perform the action.<br />Using an implicit intent is useful when your app cannot perform the action, but other apps probably can.<br />If there is more than one application registered that can handle this request, the user will be prompted to select which one to use.<br /><br />However, it is possible that there are no applications that can handle your intent. In this case, your application will crash when you invoke startActivity(). To avoid this, before calling startActivity() you should first verify that there is at least one application registered in the system that can handle the intent. To do this use resolveActivity() on your intent object.<br /><br /><strong>Answer</strong>:<br /><em>// Verify that there are applications registered to handle this intent</em><br /><em>// (resolveActivity returns null if none are registered)</em><br /><em>if (sendIntent.resolveActivity(getPackageManager()) != null) {</em><br /><em>startActivity(sendIntent);</em><br /><em> }</em></pre>
             </pre></html>
            ]]>
        </item>
        <!--Suppose that you are starting a service in an Activity as follows:-->
        <!--\nIntent service = new Intent(context, MyService.class);-->
        <!--\nstartService(service);-->
        <!--\nwhere MyService accesses a remote server via an Internet connection.-->
        <!--\nIf the Activity is showing an animation that indicates some kind of progress, what issue might you encounter and-->
        <!--how could you address it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Responses from a remote service via the Internet can often take some time, either due to networking latencies, or load on the remote server, or the amount of time it takes for the remote service to process and respond to the request.<br /><br />As a result, if such a delay occurs, the animation in the activity (and even worse, the entire UI thread) could be blocked and could appear to the user to be "frozen" while the client waits for a response from the service.<br />This is because the service is started on the main application thread (or UI thread) in the Activity.<br /><br />The problem can (and should) be avoided by relegating any such remote requests to a background thread or, when feasible, using an an asynchronous response mechanism.<br /><br /><strong>Note</strong>: Accessing the network from the UI thread throws a runtime exception in newer Android versions which causes the app to crash.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between Service and IntentService? How is each used?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Service is the base class for Android services that can be extended to create any service. A class that directly extends Service runs on the main thread so it will block the UI (if there is one) and should therefore either be used only for short tasks or should make use of other threads for longer tasks.<br /><br />IntentService is a subclass of Service that handles asynchronous requests (expressed as "Intents") on demand.<br />Clients send requests through startService(Intent) calls. The service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work. Writing an IntentService can be quite simple;<br />just extend the IntentService class and override the onHandleIntent(Intent intent) method where you can manage all incoming requests.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How to run the service even after killing the application in Android?      -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The service will still have a chance of being killed by the kernel in a state of low memory if it is low priority. So you have two options:<br /><br />1) Keep it running in the foreground by calling the startForeground() method.<br /><br />2) Restart the service if it gets killed. Here is a part of the example from the docs where they talk about restarting the service after it is killed:<br /><br /><em>public int onStartCommand(Intent intent, int flags, int startId) {</em><br /><em>Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show();</em><br /><br /><em>// For each start request, send a message to start a job and deliver the</em><br /><em>// start ID so we know which request we\'re stopping when we finish the job</em><br /><em>Message msg = mServiceHandler.obtainMessage();</em><br /><em>msg.arg1 = startId;</em><br /><em>mServiceHandler.sendMessage(msg);</em><br /><br /><em>// If we get killed, after returning from here, restart</em><br /><em>return START_STICKY;</em><br /><em>}</em></pre>
             </pre></html>
            ]]>
        </item>
        <!--Normally, in the process of carrying out a screen reorientation, the Android platform tears down the foreground activity-->
        <!--and recreates it, restoring each of the view values in the activity’s layout.-->
        <!--\nIn an app you’re working on, you notice that a view’s value is not being restored after screen reorientation.-->
        <!--What could be a likely cause of the problem that you should verify, at a minimum, about that particular view?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>You should verify that it has a valid id. In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the android:id attribute.<br /><br />Complete guide about the concept is on <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#java">Android Developers</a>.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the relationship between the life cycle of an AsyncTask and an Activity? What problems can this result in? How can -->
        <!--these problems be avoided?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>An AsyncTask is not tied to the life cycle of the Activity that contains it. So, for example, if you start an AsyncTask inside an Activity and the user rotates the device, the Activity will be destroyed (and a new Activity instance will be created) but the AsyncTask will not die but instead goes on living until it completes.<br /><br />Then, when the AsyncTask does complete, rather than updating the UI of the new Activity, it updates the former instance of the Activity (i.e., the one in which it was created but that is not displayed anymore!).<br />This can lead to an Exception (of the type java.lang.IllegalArgumentException: View not attached to window manager if you use, for instance, findViewById to retrieve a view inside the Activity).<br /><br />There\'s also the potential for this to result in a memory leak since the AsyncTask maintains a reference to the Activity, which prevents the Activity from being garbage collected as long as the AsyncTask remains alive.<br /><br />For these reasons, using AsyncTasks for long-running background tasks is generally a bad idea.<br />Rather, for long-running background tasks, a different mechanism (such as a service) should be employed.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is difference between Serializable and Parcelable ? Which is best approach in Android ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Serializable is a standard Java interface. You simply mark a class Serializable by implementing the interface, and Java will automatically serialize it in certain situations.<br /><br />Parcelable is an Android specific interface where you implement the serialization yourself.<br />It was created to be far more efficient than Serializable, and to get around some problems with the default Java serialization scheme.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are launch modes? What are the two mechanisms by which they can be defined? What specific types of launch modes are supported?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A "launch mode" is the way in which a new instance of an activity is to be associated with the current task.<br /><br />Launch modes may be defined using one of two mechanisms:<br /><br />1- <strong>Manifest file</strong>. When declaring an activity in a manifest file, you can specify how the activity should associate with tasks when it starts. Supported values include:<br />- <strong>standard</strong> (default). Multiple instances of the activity class can be instantiated and multiple instances can be added to the same task or different tasks. This is the common mode for most of the activities.<br />- <strong>singleTop</strong>. The difference from standard is, if an instance of the activity already exists at the top of the current task and the system routes the intent to this activity, no new instance will be created because it will fire off an onNewIntent() method instead of creating a new object.<br />- <strong>singleTask</strong>. A new task will always be created and a new instance will be pushed to the task as the root.<br />However, if any activity instance exists in any tasks, the system routes the intent to that activity instance through the onNewIntent() method call. In this mode, activity instances can be pushed to the same task. This mode is useful for activities that act as the entry points.<br />- <strong>singleInstance</strong>. Same as singleTask, except that the no activities instance can be pushed into the same task of the singleInstance\'s. Accordingly, the activity with launch mode is always in a single activity instance task.<br />This is a very specialized mode and should only be used in applications that are implemented entirely as one activity.<br /><br />2- <strong>Intent flags</strong>. Calls to startActivity() can include a flag in the Intent that declares if and how the new activity should be associated with the current task. Supported values include:<br />- <strong>FLAG_ACTIVITY_NEW_TASK</strong>. Same as singleTask value in Manifest file (see above).<br />- <strong>FLAG_ACTIVITY_SINGLE_TOP</strong>. Same as singleTop value in Manifest file (see above).<br />- <strong>FLAG_ACTIVITY_CLEAR_TOP</strong>. If the activity being started is already running in the current task,<br />then instead of launching a new instance of that activity, all of the other activities on top of it are destroyed and this intent is delivered to the resumed instance of the activity (now on top), through onNewIntent().<br />There is no corresponding value in the Manifest file that produces this behavior.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is a broadcast receiver?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Broadcast Receivers simply respond to broadcast messages from other applications or from the system itself.<br />These messages are sometimes called events or intents. For example, applications can also initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use, so this is broadcast receiver who will intercept this communication and will initiate appropriate action.</pre>
            </pre></html>
            ]]>
        </item>
        <!--When dealing with multiple resources, which one takes precedence?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Assuming that all of these multiple resources are able to match the configuration of a device, the \'locale\' qualifier almost always takes the highest precedence over the others.</pre>
            </pre></html>
            ]]>
        </item>
    </string-array>

    <!--C# Technical Questions-->
    <string-array name="csharpTechnicalQuestions">

         <item>
            What are the features of C#?
        </item>
        <item>
            What are the main differences between Java and C#?
        </item>
        <item>
            Can you describe the difference between the "constant" and the "readonly" variables when using C#? When would you use each one?
        </item>
        <item>
            What are the different types of classes in C#?
        </item>
        <item>
            Explain Code compilation in C#.
        </item>
        <item>
            What is the difference between Virtual method and Abstract method?
        </item>
        <item>
            Explain Namespaces in C#.
        </item>
        <item>
            Can you list the differences between static, public and void? What is the outcome of using each?
        </item>
        <item>
            Can you list the value types in C#? Can you list the reference types in C#?
        </item>
        <item>
            It is possible to store mixed datatypes such as int, string, float, char all in one array?
        </item>
        <item>
            Compare structs and classes in C#. What do they have in common? How do they differ?
        </item>
        <item>
            What is CLR?
        </item>
        <item>
             Does C# supports multiple inheritance.
        </item>
        <item>
            Which class acts as a base class for all exceptions in C#?
        </item>
        <item>
            Describe dependency injection.
        </item>
        <item>
            Describe boxing and unboxing. Provide an example.
        </item>
        <item>
            What is Managed and Unmanaged code?
        </item>
        <item>
            How is Exception Handling implemented in C#?
        </item>
        <item>
            What are C# I/O Classes? What are the commonly used I/O Classes?
        </item>
        <item>
            What is StreamReader/StreamWriter class?
        </item>
        <item>
            What is a Destructor in C#?
        </item>
        <item>
            What is the difference between finally and finalize block?
        </item>
        <item>
            What is the difference between Continue and Break Statement?
        </item>
        <item>
            What is a Delegate? Also What are the different types of Delegates?
        </item>
        <item>
            What are Events?
        </item>
        <item>
            How to use Delegates with Events?
        </item>
        <item>
            Explain Publishers and Subscribers in Events.
        </item>
        <item>
            What are Synchronous and Asynchronous operations?
        </item>
        <item>
            What is Reflection in C#?
        </item>
        <item>
            What is a Generic Class?
        </item>
        <item>
            Explain Get and Set Accessor properties?
        </item>
        <item>
            What are Async and Await?
        </item>
        <item>
            Explain Lock, Monitors, and Mutex Object in Threading.
        </item>
        <item>
            What is a Race Condition?
        </item>
        <item>
            What is Thread Pooling?
        </item>
        <item>
            What is Serialization? Also What are the types of Serialization?
        </item>
        <item>
            What is an XSD file?
        </item>
        <item>
            What is the difference between ref and out keywords?
        </item>
        <item>
            Can "this" be used within a static method?
        </item>
        <item>
            Define Property in C#.net?
        </item>
        <item>
            What is the difference between string and StringBuilder in C#?
        </item>
        <item>
            What is IEnumerable&lt;&gt; in c#?
        </item>
        <item>
            What are the differences between IEnumerable and IQueryable?
        </item>
        <item>
            What is difference between late binding and early binding in C#?
        </item>
        <item>
            What is the Constructor Chaining in C#?
        </item>
        <item>
            Can Multiple Catch Blocks executed in c#?
        </item>
        <item>
            What are Indexer in C# .Net?
        </item>
        <item>
            Difference between is and as operator in C#
        </item>
        <item>
            How to use Nullable&lt;&gt; Types in .Net?
        </item>
        <item>
            What is an Object Pool in .Net?
        </item>
        <item>
            What are generics in c#.net?
        </item>
        <item>
            What are the Difference between Array and ArrayList in C#.Net?
        </item>
        <item>
            What you understand by Value types and Reference types in C#.Net?
        </item>
        <item>
            Explain Anonymous type in C#?
        </item>
        <item>
            Explain Hashtable in C#?
        </item>
        <item>
            What is LINQ in C#?
        </item>
        <item>
            What is File Handling in C#.Net?
        </item>
        <item>
            What is Reflection in C#.Net?
        </item>
        <item>
            What is Method Hiding in C#?
        </item>
        <item>
            Can you name three ways to pass parameters to a method in C#?
        </item>
        <item>
            Explain the difference between the while and for loop. Provide a .NET syntax for both loops.
        </item>
        <item>
            What do the following acronyms in .NET stand for: IL, CIL, MSIL, CLI and JIT?
        </item>
        <item>
            Discuss what garbage collection is and how it works. Provide a code example of how you can enforce garbage collection in .NET.
        </item>
        <item>
            You would know that System.Object is the parent class of all .NET classes; In other words all types in .NET (whether implicit, explicit, or user-created) derive from the System.Object class.
            What are the various methods provided to System.Object\'s deriving classes/types?
        </item>
        <item>
            Explain the difference between a stack and a queue.
        </item>
        <item>
            What is .NET web service?
        </item>
        <item>
            What is JSON data, and what is one way that .NET developers can work with JSON?
        </item>

    </string-array>

    <!--C# Technical Answers-->
    <string-array name="csharpTechnicalAnswers">
        <!--What are the features of C#?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--What are the main differences between Java and C#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Can you describe the difference between the constants and the readonly variables-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are the differenct types of classes -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Explain code compilation in c#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--What is the difference between virtual methods and abstract methods-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Explain namespaces -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Can you list the differences between static, public and void? What is the outcome of using each?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Can you list the value types in C#? Can you list the reference types in C#?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--It is possible to store mixed datatypes such as int, string, float, char -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--compare structs and classes in c#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is clr-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--does c# support multiple inheritance.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--which class acts as a base class for all exceptions-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--describe dependency injection-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--describe boxing and unboxing -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is managed and unmanaged code-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--how is exception handling implemented-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are c# i/o classes? what are the commonly used-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is stremreader / streamwriter-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is a destructor-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the difference between finally and finalize-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the difference between continue and break-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is a delegate-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--how to use delegates with events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--explain publishers and subscribers in events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are synchronous and asynchronous operations-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is reflection-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is a generic class-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--What are async and await-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--explain lock, monitors and mutex object-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is a race condition-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is thread pooling-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is serialization?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--What is an xsd file?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the difference between ref and out -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--can this be used within a static method-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--define property -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the difference between string and stringbuilder-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is ienumerable<>-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are the differences between ienumerable and iqueryable-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the difference between late binding and early binding-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is the constructor chaining-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--can multiple catch blocs executed-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are indexer-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--difference between is and as operator -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--how to use nullable types-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is an object pooling?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are generics -->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what are the difference between array and arraylist-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what do you understand by vaue types and reference types-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--explain anonymous-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--explain hashtable-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is linq-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is file handling-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is reflection-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is method hiding-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--can you name three ways to pass parameters to a method-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--explain the difference between the while and for loop-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what do the following acronyms in .net-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--discuss what garbage collection is and how it works.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--you would know that system.object is the parent class of all.net classes.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--Explain the difference between a stack and a queue-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is .net web service-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>
        <!--what is json data and what is one way that .net developers-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            </pre></html>
            ]]>
        </item>


    </string-array>
</resources>