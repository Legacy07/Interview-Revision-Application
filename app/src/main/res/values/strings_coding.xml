<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--Java Technical Questions-->
    <string-array name="javaTechnicalQuestions">
        <item>
            Explain JVM, JRE and JDK?
        </item>
        <item>
            Explain public static void main(String args[]).
        </item>
        <item>
           Why Java is platform independent?
        </item>
        <item>
            Why java is not 100% Object-oriented?
        </item>
        <item>
            What are wrapper classes?
        </item>
        <item>
            What are constructors in Java?
        </item>
        <item>
            What is singleton class and how can we make a class singleton?
        </item>
        <item>
            What is the difference between Array list, Linked list and Vector?
        </item>
        <item>
            What is the difference between equals() and == ?
        </item>
        <item>
            What are the differences between Heap and Stack Memory?
        </item>
        <item>
           What is Polymorphism and runtime polymorphism or dynamic method dispatch?
        </item>
        <item>
           What is Inheritance?
        </item>
        <item>
           What is Abstraction?
        </item>
        <item>
           What is Encapsulation?
        </item>
        <item>
           What is the difference between abstract classes and interfaces?
        </item>
        <item>
           What is method overloading and method overriding?
        </item>
        <item>
            Can you override a private or static method in Java?
        </item>
        <item>
          What is multiple inheritance? Is it supported by Java?
        </item>
        <item>
           What is association?
        </item>
        <item>
           What do you mean by aggregation?
        </item>
        <item>
           What is composition in Java?
        </item>
        <item>
           What is the difference between Error &amp; Exception and how can you handle Java exceptions??
        </item>
        <item>
           What are the differences between Checked Exception and Unchecked Exception?
        </item>
        <item>
           What purpose does the keywords final, finally, and finalize fulfill?
        </item>
        <item>
           What are the differences between throw and throws?
        </item>
        <item>
            What is Exception Propagation?
        </item>
        <item>
           How to create a custom Exception?
        </item>
        <item>
          What are the important methods of Java Exception Class?
        </item>
        <item>
           What are the differences between processes and threads?
        </item>
        <item>
           What is synchronization?
        </item>
        <item>
            Can we write multiple catch blocks under single try block?
        </item>
        <item>
           What is the difference between double and float variables in Java?
        </item>
        <item>
            Why would it be more secure to store sensitive data (such as a password,
            social security number, etc.) in a character array rather than in a String?
        </item>
        <item>
           What is the ThreadLocal class? How and why would you use it?
        </item>
        <item>
           What is the volatile keyword? How and why would you use it?
        </item>
        <item>
           Compare the sleep() and wait() methods in Java, including when and why you would use one vs. the other.
        </item>
        <item>
           What is the Java Classloader? List and explain the purpose of the three types of class loaders.
        </item>
        <item>
           If one needs a Set, how do you choose between HashSet vs. TreeSet?
        </item>
        <item>
           How are Java enums more powerful than integer constants? How can this capability be used?
        </item>
        <item>
            What are static initializers and when would you use them?
        </item>
        <item>
            What is serialization? How do you implement it?
        </item>
    </string-array>

    <!--Java Technical Answers-->
    <string-array name="javaTechnicalAnswers">
        <!--Explain JVM, JRE and JDK?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>JVM </strong>(<strong>Java Virtual Machine</strong>): It is an abstract machine.<br />It is a specification that provides run-time environment in which java bytecode can be executed. It follows three notations:<br />- <strong>Specification</strong>: It is a document that describes the implementation of the Java virtual machine. It is provided by Sun and other companies.<br />- <strong>Implementation</strong>: It is a program that meets the requirements of JVM specification.<br />- <strong>Runtime Instance</strong>: An instance of JVM is created whenever you write a java command on the command prompt and run the class.<br /><br /><strong>JRE</strong> (<strong>Java Runtime Environment</strong>): JRE refers to a runtime environment in which java bytecode can be executed.<br />It implements the JVM (Java Virtual Machine) and provides all the class libraries and other support files that<br />JVM uses at runtime. So JRE is a software package that contains what is required to run a Java program.<br />Basically, it\'s an implementation of the JVM which physically exists.<br /><br /><strong>JDK</strong> (<strong>Java Development Kit</strong>): It is the tool necessary to compile, document and package Java programs.<br />The JDK completely includes JRE which contains tools for Java programmers. The Java Development Kit is provided free of charge.<br />Along with JRE, it includes an interpreter/loader, a compiler (javac), an archiver (jar), a documentation generator (javadoc) and other tools needed in Java development. In short, it contains JRE + development tools.</p>
            </pre></html>
            ]]>
        </item>
        <!--Explain public static void main(String args[]).-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>public</strong>: Public is an access modifier, which is used to specify who can access this method. Public means that this Method will be accessible by any Class.<br />static: It is a keyword in java which identifies it is class based i.e it can be accessed without creating the instance of a Class.<br /><strong>void</strong>: It is the return type of the method. Void defines the method which will not return any value.<br /><strong>main</strong>: It is the name of the method which is searched by JVM as a starting point for an application with a particular signature only. It is the method where the main execution occurs.<br /><strong>String args[]</strong>: It is the parameter passed to the main method.</p>
            </pre></html>
            ]]>
        </item>
        <!--Why Java is platform independent?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Platform independent practically means "write once run anywhere". Java is called so because of its byte codes which can run on any system irrespective of its underlying operating system.</p>
            </pre></html>
            ]]>
        </item>
        <!--Why java is not 100% Object-oriented?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Java is not 100% Object-oriented because it makes use of eight primitive datatypes such as boolean, byte, char, int, float, double, long, short which are not objects.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are wrapper classes?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Wrapper classes converts the java primitives into the reference types (objects). Every primitive data type has a class dedicated to it. These are known as wrapper classes because they "wrap" the primitive data type into an object of that class.<br />Refer to the below image which displays different primitive type, wrapper class and constructor argument.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are constructors in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <p>In Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.<br /><br />There are two types of constructors:<br />1. Default constructor<br />2. Parameterized constructor</p>
             </pre></html>
            ]]>
        </item>
        <!--What is singleton class and how can we make a class singleton?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Singleton class is a class whose only one instance can be created at any given time, in one JVM. A class can be made singleton by making its constructor private.</p>
             </pre></html>
            ]]>
        </item>
        <!--What is the difference between Array list, Linked list and Vector?-->
        <item>
             <![CDATA[<html><pre style="text-align:center">
            <p>Their main difference is their implementation which causes different performance for different operations.<br />ArrayList is implemented as a resizable array. As more elements are added to ArrayList, its size is increased dynamically.<br />It\'s elements can be accessed directly by using the get and set methods, since ArrayList is essentially an array.<br /><br /><strong>LinkedList</strong> is implemented as a double linked list. Its performance on add and remove is better than Arraylist, but worse on get and set methods. Vector is similar with ArrayList, but it is synchronized.<br /><strong>ArrayList</strong> is a better choice if your program is thread-safe. Vector and ArrayList require space as more elements are added.<br /><br /><strong>Vector</strong> each time doubles its array size, while ArrayList grow 50% of its size each time. LinkedList, however, also implements Queue interface which adds more methods than ArrayList and Vector, such as offer(), peek(), poll(), etc.<br /><br /><strong>Note</strong>: The default initial capacity of an ArrayList is pretty small.<br />It is a good habit to construct the ArrayList with a higher initial capacity. This can avoid the resizing cost.<br />Also, Vector is deprecated.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between equals() and == ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <p>Equals() method is defined in Object class in Java and used for checking equality of two objects defined by business logic.<br />"==" or equality operator in Java is a binary operator provided by Java programming language and used to compare primitives and objects. public boolean equals(Object o) is the method provided by the Object class.<br />The default implementation uses == operator to compare two objects.<br /><br />Therefore the equals() method compares the "value" inside String instances (on the heap) irrespective if the two object references refer to the same String instance or not.<br />On the other hand, the "==" operator compares the value of two object references to see whether they refer to the same String instance.<br /><br /><strong>For example</strong>: method can be overridden like String class. equals() method is used to compare the values of two objects.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between Heap and Stack Memory?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <p>Stack is used for static memory allocation and Heap for dynamic memory allocation, both stored in the computer\'s RAM .<br /><br />Variables allocated on the stack are stored directly to the memory and access to this memory is very fast, and it\'s allocation is dealt with when the program is compiled. When a function or a method calls another function which in turns calls another function etc., the execution of all those functions remains suspended until the very last function returns its value. The stack is always reserved in a LIFO (Last in First out) order, the most recently reserved block is always the next block to be freed. This makes it really simple to keep track of the stack, freeing a block from the stack is nothing more than adjusting one pointer.<br /><br />Variables allocated on the heap have their memory allocated at run time and accessing this memory is a bit slower, but the heap size is only limited by the size of virtual memory. Element of the heap have no dependencies with each other and can always be accessed randomly at any time. You can allocate a block at any time and free it at any time.<br />This makes it much more complex to keep track of which parts of the heap are allocated or free at any given time.<br /><br />You can use the stack if you know exactly how much data you need to allocate before compile time and it is not too big.<br />You can use heap if you don\'t know exactly how much data you will need at runtime or if you need to allocate a lot of data.<br /><br />In a multi-threaded situation each thread will have its own completely independent stack but they will share the heap.<br />Stack is thread specific and Heap is application specific. The stack is important to consider in exception handling and thread executions.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is Polymorphism and runtime polymorphism or dynamic method dispatch?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Polymorphism is briefly described as "one interface, many implementations".<br />Polymorphism is a characteristic of being able to assign a different meaning or usage to something in different contexts specifically, to allow an entity such as a variable, a function, or an object to have more than one form.<br />There are two types of polymorphism:<br />- Compile time polymorphism<br />- Run time polymorphism<br /><br />Compile time polymorphism is method overloading whereas Runtime time polymorphism is done using inheritance and interface.<br /><br />In Java, runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. In this process, an overridden method is called through the reference variable of a superclass.<br /><br /><strong>Example</strong>:</pre>
<pre style="margin: 0; line-height: 125%;"> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Car</em> <br /><em style="color: #333333;"> {</em>
 <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">run</em><em style="color: #333333;">()<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> System</em><em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">("</em><em style="background-color: #ffffff;">car is running"</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Audi</em> <em style="color: #008800; font-weight: bold;">extends</em><em style="background-color: #ffffff;"> Car<br /> </em><em style="color: #333333;">{<br /></em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">run</em><em style="color: #333333;">()<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> System</em><em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">prinltn</em><em style="color: #333333;">("</em><em style="background-color: #ffffff;">Audi is running safely with </em><em style="color: #0000dd; font-weight: bold;">100</em><em style="background-color: #ffffff;">km"</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">static</em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">main</em><em style="color: #333333;">(</em><em style="background-color: #ffffff;">String args</em><em style="color: #333333;">[])<br /></em> <em style="color: #333333;">{<br /></em><em style="background-color: #ffffff;"> Car b</em><em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em><em style="background-color: #ffffff;"> Audi</em><em style="color: #333333;">();</em>    <em style="color: #888888;">//upcasting<br /></em><em style="background-color: #ffffff;"> b</em><em style="color: #333333;">.</em><em style="color: #0000cc;">run</em><em style="color: #333333;">();<br /></em> <em style="color: #333333;">}<br /></em> <em style="color: #333333;">}</em>
</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is inheritance-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>Inheritance is the process wherein characteristics are inherited from ancestors. Similarly, in Java, a subclass inherits the characteristics (properties and methods) of its superclass (ancestor).<br />For example, a vehicle is a superclass and a car is a subclass. The car (subclass) inherits all of the vehicle\'s properties.<br />The inheritance mechanism is very useful in code reuse.<br />The following are some limitations of Java class inheritance: A subclass cannot inherit private members of its superclass.<br />Constructor and initializer blocks cannot be inherited by a subclass. A subclass can have only one superclass.<br /><br />The keyword "extends" is used to derive a subclass from the superclass, as illustrated by the following syntax:</pre>
<pre><em>class Name_of_subclass extends Name_of superclass</em><br />{ //new fields and methods that would define the subclass go here }<br /><br />If you want to derive a subclass Rectangle from a superclass Shapes, you can do it as follows:<br /><em>class Rectangle extends Shapes { &hellip;. }</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Abstraction?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<pre>Data Abstraction is the property by virtue of which only the essential details are displayed to the user.<br />The trivial or the non-essentials units are not displayed to the user.<br />E.g. A car is viewed as a car rather than its individual components.<br /><br />Data Abstraction may also be defined as the process of identifying only the required characteristics of an object ignoring the irrelevant details.The properties and behaviors of an object differentiate it from other objects of similar type and also help in classifying/grouping the objects.<br /><br />Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of car or applying brakes will stop the car but he does not know about how on pressing the accelerator the speed is actually increasing, he does not know about the inner mechanism of the car or the implementation of accelerator, brakes etc in the car. This is what abstraction is.<br /><br />In java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction using interfaces.<br /><br />Abstract classes and Abstract methods:<br />1. An abstract class is a class that is declared with abstract keyword.<br />2. An abstract method is a method that is declared without an implementation.<br />3. An abstract class may or may not have all abstract methods. Some of them can be concrete methods.<br />4. A method defined abstract must always be redefined in the subclass,thus making overriding compulsory OR either make subclass itself abstract.<br />5. Any class that contains one or more abstract methods must also be declared with abstract keyword.<br />6. There can be no object of an abstract class.That is, an abstract class can not be directly instantiated with the new operator.<br />7. An abstract class can have parametrized constructors and default constructor is always present in an abstract class.<br /><br />Consider a classic "shape" example, perhaps used in a computer-aided design system or game simulation.<br />The base type is "shape" and each shape has a color, size and so on. From this, specific types of shapes are derived(inherited)-circle, square, triangle and so on &ndash; each of which may have additional characteristics and behaviors.<br /><br />For example, certain shapes can be flipped. Some behaviors may be different, such as when you want to calculate the area of a shape. The type hierarchy embodies both the similarities and differences between the shapes.<br /><br /><strong>Example</strong>:</pre>
<pre style="margin: 0; line-height: 125%;"><em style="color: #008800; font-weight: bold;">abstract</em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Shape<br /></em><em style="color: #333333;">{<br /></em>String color<em style="color: #333333;">;<br /></em><br /><em style="color: #888888;">// these are abstract methods<br /></em><em style="color: #008800; font-weight: bold;">abstract</em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">();<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">abstract</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">();<br /></em><br /><em style="color: #888888;">// abstract class can have constructor<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Shape</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em> System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Shape constructor called"</em><em style="color: #333333;">);<br /></em> <em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">=</em> color<em style="color: #333333;">;<br /></em> <em style="color: #333333;">}<br /></em>
<br /><em style="color: #888888;">// this is a concrete method<br /></em><em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">getColor</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> color<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><em style="color: #333333;">}<br /></em><em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Circle</em> <em style="color: #008800; font-weight: bold;">extends</em> Shape<br /><em style="color: #333333;">{<br /></em><em style="color: #333399; font-weight: bold;">double</em> radius<em style="color: #333333;">;<br /></em><br /><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Circle</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> radius<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em><br /><em style="color: #888888;">// calling Shape constructor<br /></em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">(</em>color<em style="color: #333333;">);<br /></em> System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Circle constructor called"</em><em style="color: #333333;">);<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">radius</em> <em style="color: #333333;">=</em> radius<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /> <em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em> <em style="color: #008800; font-weight: bold;">return</em> Math<em style="color: #333333;">.</em><em style="color: #0000cc;">PI</em> <em style="color: #333333;">*</em> Math<em style="color: #333333;">.</em><em style="color: #0000cc;">pow</em><em style="color: #333333;">(</em>radius<em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">2</em><em style="color: #333333;">);<br /></em> <em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> <em style="background-color: #fff0f0;">"Circle color is "</em> <em style="color: #333333;">+</em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">+<br /></em><em style="background-color: #fff0f0;">"and area is : "</em> <em style="color: #333333;">+</em> area<em style="color: #333333;">();<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #333333;">}<br /></em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Rectangle</em> <em style="color: #008800; font-weight: bold;">extends</em> Shape<em style="color: #333333;">{<br /></em>
<em style="color: #333399; font-weight: bold;">double</em> length<em style="color: #333333;">;<br /></em> <em style="color: #333399; font-weight: bold;">double</em> width<em style="color: #333333;">;<br /></em><br /><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #0066bb; font-weight: bold;">Rectangle</em><em style="color: #333333;">(</em>String color<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> length<em style="color: #333333;">,</em><em style="color: #333399; font-weight: bold;">double</em> width<em style="color: #333333;">)</em> <em style="color: #333333;">{<br /></em> <em style="color: #888888;">// calling Shape constructor<br /></em><em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">(</em>color<em style="color: #333333;">);<br /></em>System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Rectangle constructor called"</em><em style="color: #333333;">);<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">length</em> <em style="color: #333333;">=</em> length<em style="color: #333333;">;<br /></em><em style="color: #008800; font-weight: bold;">this</em><em style="color: #333333;">.</em><em style="color: #0000cc;">width</em> <em style="color: #333333;">=</em> width<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em> <em style="color: #333399; font-weight: bold;">double</em> <em style="color: #0066bb; font-weight: bold;">area</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em> <em style="color: #008800; font-weight: bold;">return</em> length<em style="color: #333333;">*</em>width<em style="color: #333333;">;<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #555555; font-weight: bold;">@Override<br /></em><em style="color: #008800; font-weight: bold;">public</em> String <em style="color: #0066bb; font-weight: bold;">toString</em><em style="color: #333333;">()</em> <em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">return</em> <em style="background-color: #fff0f0;">"Rectangle color is "</em> <em style="color: #333333;">+</em> <em style="color: #008800; font-weight: bold;">super</em><em style="color: #333333;">.</em><em style="color: #0000cc;">color</em> <em style="color: #333333;">+<br /></em><em style="background-color: #fff0f0;">"and area is : "</em> <em style="color: #333333;">+</em> area<em style="color: #333333;">();<br /></em><em style="color: #333333;">}<br /></em><br /><em style="color: #333333;">}<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">class</em> <em style="color: #bb0066; font-weight: bold;">Test<br /></em><em style="color: #333333;">{<br /></em><em style="color: #008800; font-weight: bold;">public</em> <em style="color: #008800; font-weight: bold;">static</em> <em style="color: #333399; font-weight: bold;">void</em> <em style="color: #0066bb; font-weight: bold;">main</em><em style="color: #333333;">(</em>String<em style="color: #333333;">[]</em> args<em style="color: #333333;">)<br /></em><em style="color: #333333;">{<br /></em>Shape s1 <em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em> Circle<em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Red"</em><em style="color: #333333;">,</em> <em style="color: #6600ee; font-weight: bold;">2.2</em><em style="color: #333333;">);<br /></em>Shape s2 <em style="color: #333333;">=</em> <em style="color: #008800; font-weight: bold;">new</em> Rectangle<em style="color: #333333;">(</em><em style="background-color: #fff0f0;">"Yellow"</em><em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">2</em><em style="color: #333333;">,</em> <em style="color: #0000dd; font-weight: bold;">4</em><em style="color: #333333;">);<br /></em><br />System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em>s1<em style="color: #333333;">.</em><em style="color: #0000cc;">toString</em><em style="color: #333333;">());<br /></em>System<em style="color: #333333;">.</em><em style="color: #0000cc;">out</em><em style="color: #333333;">.</em><em style="color: #0000cc;">println</em><em style="color: #333333;">(</em>s2<em style="color: #333333;">.</em><em style="color: #0000cc;">toString</em><em style="color: #333333;">());<br /></em><em style="color: #333333;">}<br /></em><em style="color: #333333;">}<br /></em>
</pre>
<pre><strong>Output</strong>:<br /><em> Shape constructor called</em><br /><em> Circle constructor called</em><br /><em> Shape constructor called</em><br /><em> Rectangle constructor called</em><br /><em> Circle color is Redand area is : 15.205308443374602</em><br /><em> Rectangle color is Yellowand area is : 8.0</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Encapsulation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Encapsulation in Java is a mechanism of wrapping the data (variables) and code acting on the data (methods) together as a single unit. In encapsulation, the variables of a class will be hidden from other classes, and can be accessed only through the methods of their current class. Therefore, it is also known as data hiding.<br />To achieve encapsulation in Java; <br />- Declare the variables of a class as private.<br />- Provide public setter and getter methods to modify and view the variables values.<br /><br /><strong>Example</strong>:</pre>
<pre><em>/* File name : EncapTest.java */</em><br /><em>public class EncapTest {</em><br /><em>private String name;</em><br /><em>private String idNum;</em><br /><em>private int age;</em><br /><br /><em>public int getAge() {</em><br /><em>return age;</em><br /><em>}</em><br /><br /><em>public String getName() {</em><br /><em>return name;</em><br /><em>}</em><br /><br /><em>public String getIdNum() {</em><br /><em>return idNum;</em><br /><em>}</em><br /><br /><em>public void setAge( int newAge) {</em><br /><em>age = newAge;</em><br /><em>}</em><br /><br /><em>public void setName(String newName) {</em><br /><em>name = newName;</em><br /><em>}</em><br /><br /><em>public void setIdNum( String newId) {</em><br /><em>idNum = newId;</em><br /><em>}</em><br /><em>}</em><br /><br />The public setXXX() and getXXX() methods are the access points of the instance variables of the EncapTest class.<br />Normally, these methods are referred as getters and setters. Therefore, any class that wants to access the variables should<br />access them through these getters and setters.<br />The variables of the EncapTest class can be accessed using the following program; <br /><br /><em>/* File name : RunEncap.java */</em><br /><em>public class RunEncap {</em><br /><br /><em>   public static void main(String args[]) </em><br /><em>   {</em><br /><em>      EncapTest encap = new EncapTest();</em><br /><em>      encap.setName("James");</em><br /><em>      encap.setAge(20);</em><br /><em>      encap.setIdNum("12343ms");</em><br /><br /><em>      System.out.print("Name : " + encap.getName() + " Age : " + encap.getAge());</em><br /><em>   }</em><br /><em>}</em></pre>
<pre>This will produce the following result &minus;<br /><br /><strong>Output</strong><br />Name : James Age : 20</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between abstract classes and interfaces?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>The key technical differences between an <strong>abstract class</strong> and an <strong>interface</strong> are:<br /><br />- Abstract classes can have constants, members, method stubs (methods without a body) and defined methods, whereas interfaces can only have constants and methods stubs.<br /><br />- Methods and members of an abstract class can be defined with any visibility, whereas all methods of an interface must be defined as public (they are defined public by default).<br /><br />- When inheriting an abstract class, a concrete child class must define the abstract methods, whereas an abstract class can extend another abstract class and abstract methods from the parent class don\'t have to be defined.<br /><br />- Similarly, an interface extending another interface is not responsible for implementing methods from the parent interface. This is because interfaces cannot define any implementation.<br /><br />- A child class can only extend a single class (abstract or concrete), whereas an interface can extend or a class can implement multiple other interfaces.<br /><br />- A child class can define abstract methods with the same or less restrictive visibility, whereas a class implementing an interface must define the methods with the exact same visibility (public).</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is method overloading and method overriding?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre><strong>Method Overloading</strong>:<br />- In Method Overloading, Methods of the same class shares the same name but each method must have different number of parameters or parameters having different types and order.<br />- Method Overloading is to "add" or "extend" more to method\'s behavior.<br />- It is a compile time polymorphism.<br />- The methods must have different signature.<br />- It may or may not need inheritance in Method Overloading.</pre>
<pre> <br /><strong>Example</strong>:<br /><em>class Adder {</em><br /><em>Static int add(int a, int b)</em><br /><em>{</em><br /><em>return a+b;</em><br /><em>}</em><br /><em>Static double add( double a, double b)</em><br /><em>{</em><br /><em>return a+b;</em><br /><em>}</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>System.out.println(Adder.add(11,11));</em><br /><em>System.out.println(Adder.add(12.3,12.6));</em><br /><em>}}</em><br /><br /><strong>Method Overriding:</strong><br />- In Method Overriding, sub class have the same method with same name and exactly the same number and type of parameters and same return type as a super class.<br />- Method Overriding is to "Change" existing behavior of method.<br />- It is a run time polymorphism.<br />- The methods must have same signature.<br />- It always requires inheritance in Method Overriding.<br /><br /><strong>Example</strong>:<br /><em>class Car {</em><br /><em>void run(){</em><br /><em>System.out.println("car is running");</em><br /><em>}</em><br /><em>Class Audi extends Car{</em><br /><em>void run()</em><br /><em>{</em><br /><em>System.out.prinltn("Audi is running safely with 100km");</em><br /><em>}</em><br /><em>public static void main( String args[])</em><br /><em>{</em><br /><em>Car b=new Audi();</em><br /><em>b.run();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--Can you override a private or static method in Java?-->
        <item>
             <![CDATA[<html><pre style="text-align:center">
            <pre>You cannot override a private or static method in Java. If you create a similar method with same return type and same method arguments in child class then it will hide the super class method; this is known as method hiding. Similarly, you cannot override a private method in sub class because it\'s not accessible there. What you can do is create another private method with the same name in the child class.<br /><br /><strong>Example</strong>:<br /><em>class Base {</em><br /><em>private static void display() {</em><br /><em>System.out.println("Static or class method from Base");</em><br /><em>}</em><br /><em>public void print() {</em><br /><em>System.out.println("Non-static or instance method from Base");</em><br /><em>}</em><br /><em>class Derived extends Base {</em><br /><em>private static void display() {</em><br /><em>System.out.println("Static or class method from Derived");</em><br /><em>}</em><br /><em>public void print() {</em><br /><em>System.out.println("Non-static or instance method from Derived");</em><br /><em>}</em><br /><em>public class test {</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>Base obj= new Derived();</em><br /><em>obj1.display();</em><br /><em>obj1.print();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is multiple inheritance? Is it supported by Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>If a child class inherits the property from multiple classes is known as multiple inheritance. Java does not allow to extend multiple classes.<br />The problem with multiple inheritance is that if multiple parent classes have a same method name, then at runtime it becomes difficult for the compiler to decide which method to execute from the child class.<br />Therefore, Java doesn\'t support multiple inheritance. The problem is commonly referred as Diamond Problem.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is Association? -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Association</strong> is a relationship where all object have their own lifecycle and there is no owner.<br />Let\'s take an example of Teacher and Student. Multiple students can associate with a single teacher and a single student can associate with multiple teachers but there is no ownership between the objects and both have their own lifecycle. These relationship can be one to one, One to many, many to one and many to many.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What do you mean by aggregation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Aggregation</strong> is a specialized form of Association where all object have their own lifecycle but there is ownership and child object can not belongs to another parent object. Let\'s take an example of Department and teacher.<br />A single teacher can not belong to multiple departments, but if we delete the department teacher object will not destroy.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is composition in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Composition</strong> is again specialized form of Aggregation and we can call this as a "death" relationship.<br />It is a strong type of Aggregation. Child object dose not have their lifecycle and if parent object deletes all child object will also be deleted. Let\'s take again an example of relationship between House and rooms.<br />House can contain multiple rooms there is no independent life of room and any room can not belong to two different house if we delete the house room will automatically delete.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between Error & Exception and how can you handle Java exceptions??-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error.<br />These JVM errors you can not repair them at runtime.Though error can be caught in catch block but the execution of application will come to a halt and is not recoverable.<br />While exceptions are conditions that occur because of bad input or human error etc.<br />e.g. FileNotFoundException will be thrown if the specified file does not exist.<br />Or a NullPointerException will take place if you try using a null reference.<br />In most of the cases it is possible to recover from an exception (probably by giving user a feedback for entering proper values etc).<br /><br />There are five keywords used to handle exceptions in Java:<br />1. try<br />2. catch<br />3. finally<br />4. throw<br />5. throws</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between Checked Exception and Unchecked Exception?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre><strong>Checked Exception</strong><br />- The classes that extend Throwable class except RuntimeException and Error are known as checked exceptions.<br />- Checked exceptions are checked at compile-time.<br />- Example: IOException, SQLException etc.<br /><br /><strong>Unchecked Exception</strong><br />- The classes that extend RuntimeException are known as unchecked exceptions.<br />- Unchecked exceptions are not checked at compile-time.<br />- Example: ArithmeticException, NullPointerException etc.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What purpose does the keywords final, finally, and finalize fulfill?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Final</strong>:<br />Final is used to apply restrictions on class, method and variable. Final class can\'t be inherited, final method can\'t be overridden and final variable value can\'t be changed.<br /><br /><strong>Example</strong>:<br /><em>class FinalVarExample {</em><br /><br /><em>public static void main( String args[])</em><br /><em>{</em><br /><em>final int a=10;   // Final variable</em><br /><em>a=50;             //Error as value can\'t be changed</em><br /><em>}</em><br /><br /><strong>Finally:</strong><br />Finally is used to place important code, it will be executed whether exception is handled or not.<br /><br /><strong>Example</strong>:<br /><em>class FinallyExample {</em><br /><br /><em>public static void main(String args[]){</em><br /><em>try {</em><br /><em>int x=100;</em><br /><em>}</em><br /><em>catch(Exception e) {</em><br /><em>System.out.println(e);</em><br /><em>}</em><br /><em>finally {</em><br /><em>System.out.println("finally block is executing");}</em><br /><em>}}</em><br /><em>}</em><br /><br /><strong>Finalize</strong><br />Finalize is used to perform clean up processing just before object is garbage collected.<br /><br /><strong>Example</strong>:<br /><em>class FinalizeExample {</em><br /><br /><em>public void finalize() {</em><br /><em>System.out.println("Finalize is called");</em><br /><em>}</em><br /><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>FinalizeExample f1=new FinalizeExample();</em><br /><em>FinalizeExample f2=new FinalizeExample();</em><br /><em>f1= NULL;</em><br /><em>f2=NULL;</em><br /><em>System.gc();</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between throw and throws?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>1. throws clause is used to declare an exception and throw keyword is used to throw an exception explicitly.<br />2. If we see syntax wise then throw is followed by an instance variable and throws is followed by exception class names.<br />3. The keyword throw is used inside method body to invoke an exception and throws clause is used in method declaration (signature).<br />4. You cannot declare multiple exceptions with throw. You can declare multiple exception e.g. public void method()throws IOException,SQLException.<br />5. Checked Exceptions can not be propagated with throw only because it is explicitly used to throw an particular exception. Checked exception can be propagated with throws.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is exception propagation?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>After a method throws an exception, the runtime system searches the call stack for a method that contains a block of code(exception handler) that can handle the exception. The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler is found, the runtime system passes the exception to the handler.<br />Also, there\'s a note-worthy point: Only unchecked exceptions are propagated. Checked exceptions throw compilation error.<br /><br />Lets say, we have a chain of methods where method3() calls method2() and method2() calls method1(). So when<br />1) An exception occurs in the method3() and in method3() we don\'t have any exception handler.<br />2) Uncaught exception will be propagated downward in stack i.e it will check appropriate exception handler in the method2().<br />3) Again in method2 if we don\'t have any exception handler then again exception is propagated downward to method1() where it finds exception handler.<br /><br /><strong>Example</strong>:<br /><em>class ExceptionPropagation{</em><br /><br /><em>void method3(){</em><br /><em>      int result = 100 / 0;  //Exception Generated</em><br /><em>}</em><br /><br /><em>void method2(){</em><br /><em>      method3();</em><br /><em>}</em><br /><br /><em>void method1(){</em><br /><em>try{</em><br /><em>   method2();</em><br /><em>} catch(Exception e){</em><br /><em>System.out.println("Exception is handled here");</em><br /><em>}</em><br /><em>}</em><br /><br /><em>public static void main(String args[]){</em><br /><em>ExceptionPropagation obj=new ExceptionPropagation();</em><br /><em>obj.method1();</em><br /><em>System.out.println("Continue with Normal Flow...");</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Exception is handled here<br /><br />Continue with Normal Flow...</pre>
            </pre></html>
            ]]>
        </item>
        <!--How to create a custom Exception?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- class New1Exception extends Exception { }               // this will create Checked Exception<br />- class NewException extends IOException { }             // this will create Checked exception<br />- class NewException extends NullPointerException { }  // this will create UnChecked exception</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the important methods of Java Exception Class?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>Exception and all of it\'s subclasses doesn\'t provide any specific methods and all of the methods are defined in the base class Throwable.<br /><br />1. String getMessage() &ndash; This method returns the message String of Throwable and the message can be provided while creating the exception through it\'s constructor.<br />2. String getLocalizedMessage() &ndash; This method is provided so that subclasses can override it to provide locale specific message to the calling program. Throwable class implementation of this method simply use getMessage() method to return the exception message.<br />3. Synchronized Throwable getCause() &ndash; This method returns the cause of the exception or null id the cause is unknown.<br />4. String toString() &ndash; This method returns the information about Throwable in String format, the returned String contains the name of Throwable class and localized message.<br />5. void printStackTrace() &ndash; This method prints the stack trace information to the standard error stream, this method is overloaded and we can pass PrintStream or PrintWriter as argument to write the stack trace information to the file or stream.<br /><br /></pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the differences between processes and threads?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Key difference: Thread and Process are two closely related terms in multi-threading.<br />The main difference between the two terms is that the threads are a part of a process, i.e. a process may contain one or more threads, but a thread cannot contain a process.<br /><br />In programming, there are two basic units of execution: processes and threads.<br />They both execute a series of instructions. Both are initiated by a program or the operating system.<br />This article helps to differentiate between the two units.<br /><br />Process A process is an instance of a program that is being executed. It contains the program code and its current activity.<br />Depending on the operating system, a process may be made up of multiple threads of execution that execute instructions concurrently. A program is a collection of instructions; a process is the actual execution of those instructions.<br /><br />A process has a self-contained execution environment. It has a complete set of private basic run-time resources;<br />in particular, each process has its own memory space. Processes are often considered similar to other programs or applications.<br />However, the running of a single application may in fact be a set of cooperating processes.<br />To facilitate communication between the processes, most operating systems use Inter Process Communication (IPC) resources, such as pipes and sockets. The IPC resources can also be used for communication between processes on different systems.<br />Most applications in a virtual machine run as a single process. However, it can create additional processes using a process builder object.<br /><br />In computers, a thread can execute even the smallest sequence of programmed instructions that can be managed independently by an operating system. The applications of threads and processes differ from one operating system to another.<br />However, the threads are made of and exist within a process; every process has at least one. Multiple threads can also exist in a process and share resources, which helps in efficient communication between threads.<br /><br />On a single processor, multitasking takes place as the processor switches between different threads; it is known as multithreading. The switching happens so frequently that the threads or tasks are perceived to be running at the same time.<br />Threads can truly be concurrent on a multiprocessor or multi-core system, with every processor or core executing the separate threads simultaneously.<br /><br />In summary, threads may be considered lightweight processes, as they contain simple sets of instructions and can run within a larger process. Computers can run multiple threads and processes at the same time.<br /><br />Comparison between <strong>Process</strong> and <strong>Thread</strong>:<br /><br /><strong>Process</strong>:<br />- An executing instance of a program is called a process.<br />- It has its own copy of the data segment of the parent process.<br />- Processes must use inter-process communication to communicate with sibling processes.<br />- Processes have considerable overhead.<br />- New processes require duplication of the parent process.<br />- Processes can only exercise control over child processes.<br />- Any change in the parent process does not affect child processes.<br />- Run in separate memory spaces.<br />- Most file descriptors are not shared.<br />- There is no sharing of file system context.<br />- It does not share signal handling.<br />- Process is controlled by the operating system.<br />- Processes are independent.<br /><br /><strong>Thread</strong>:<br />- A thread is a subset of the process.<br />- It has direct access to the data segment of its process.<br />- Threads can directly communicate with other threads of its process.<br />- Threads have almost no overhead.<br />- New threads are easily created.<br />- Threads can exercise considerable control over threads of the same process.<br />- Any change in the main thread may affect the behavior of the other threads of the process.<br />- Run in shared memory spaces.<br />- It shares file descriptors.<br />- It shares file system context.<br />- It shares signal handling.<br />- Threads are controlled by programmer in a program.<br />- Threads are dependent.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is synchronizations?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Synchronization</strong> refers to multi-threading. A synchronized block of code can be executed by only one thread at a time.<br />As Java supports execution of multiple threads, two or more threads may access the same fields or objects.<br />Synchronization is a process which keeps all concurrent threads in execution to be in sync. Synchronization avoids memory consistency errors caused due to inconsistent view of shared memory. When a method is declared as synchronized the thread holds the monitor for that method\'s object. If another thread is executing the synchronized method the thread is blocked until that thread releases the monitor.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Can we write multiple catch blocks under single try blocks?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>It is possible to have multiple catch blocks under single try block but the approach should be from specific to general.<br /><br /><strong>Example</strong>:<br /><em>public class Example {</em><br /><em>public static void main(String args[]) {</em><br /><em>try {</em><br /><em>int a[]= new int[10];</em><br /><em>a[10]= 10/0;</em><br /><em>}</em><br /><em>catch(ArithmeticException e)</em><br /><em>{</em><br /><em>System.out.println("Arithmetic exception in first catch block");</em><br /><em>}</em><br /><em>catch(ArrayIndexOutOfBoundsException e)</em><br /><em>{</em><br /><em>System.out.println("Array index out of bounds in second catch block");</em><br /><em>}</em><br /><em>catch(Exception e)</em><br /><em>{</em><br /><em>System.out.println("Any exception in third catch block");</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between double and float variables in Java?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Though both float and double datatype are used to represent floating point numbers in Java, a double data type is more precise than float. A double variable can provide precision up to 15 to 16 decimal points as compared to float precision of 6 to 7 decimal digits. Another significant difference between float and double is their storage requirement, double is more expensive than float. It takes 8 bytes to store a variable while float just takes 4 bytes.<br />Which means, if memory is constraint than its better to use float than double. BTW, the double type also has larger range than float and if your numbers don\'t fit well in float then you have to use double in Java. It\'s also worth noting that floating point numbers or real numbers are by default double in Java. If you want to store them into float variable, you need to either cast them or use a prefix \'f\' or \'F\'.<br /><br /><strong>Also to note that</strong>: float uses 1 bits for sign, 8 bits for exponent and 23 bits for mantissa, while double uses 1 bits for sign, 11 bits for exponent and 52 bits for mantissa.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Why would it be more secure to store sensitive data (such as a password,
        social security number, etc.) in a character array rather than in a String?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In Java, Strings are immutable and are stored in the String pool.<br />What this means is that, once a String is created, it stays in the pool in memory until being garbage collected.<br />Therefore, even after you\'re done processing the string value (e.g., the password), it remains available in memory for an indeterminate period of time thereafter (again, until being garbage collected) which you have no real control over.<br />Therefore, anyone having access to a memory dump can potentially extract the sensitive data and exploit it.<br /><br />In contrast, if you use a mutable object like a character array, for example, to store the value, you can set it to blank once you are done with it with confidence that it will no longer be retained in memory.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the ThreadLocal class? How and why would you use it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A single ThreadLocal instance can store different values for each thread independently.<br />Each thread that accesses the get() or set() method of a ThreadLocal instance is accessing its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or transaction ID).<br />The example below, from the ThreadLocal Javadoc, generates unique identifiers local to each thread.<br />A thread\'s id is assigned the first time it invokes ThreadId.get() and remains unchanged on subsequent calls.<br /><br /><strong>Example</strong>:<br /><em>public class ThreadId {</em><br /><em> // Next thread ID to be assigned</em><br /><em>private static final AtomicInteger nextId = new AtomicInteger(0);</em><br /><br /><em>// Thread local variable containing each thread\'s ID</em><br /><em> private static final ThreadLocal&lt;Integer&gt; threadId =</em><br /><em> new ThreadLocal&lt;Integer&gt;() {</em><br /><em> @Override protected Integer initialValue() {</em><br /><em> return nextId.getAndIncrement();</em><br /><em> }</em><br /><em> };</em><br /><br /><em>// Returns the current thread\'s unique ID, assigning it if necessary</em><br /><em>public static int get() {</em><br /><em>return threadId.get();</em><br /><em>}</em><br /><em> }</em><br /><br />Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the volatile keyword? How and why would you use it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In Java, each thread has its own stack, including its own copy of variables it can access.<br />When the thread is created, it copies the value of all accessible variables into its own stack.<br />The volatile keyword basically says to the JVM "Warning, this variable may be modified in another Thread".<br /><br />In all versions of Java, the volatile keyword guarantees global ordering on reads and writes to a variable.<br />This implies that every thread accessing a volatile field will read the variable\'s current value instead of (potentially) using a cached value.<br /><br />In Java 5 or later, volatile reads and writes establish a happens-before relationship, much like acquiring and releasing a mutex.<br /><br />Using volatile may be faster than a lock, but it will not work in some situations. The range of situations in which volatile is effective was expanded in Java 5; in particular, double-checked locking now works correctly.<br /><br />The volatile keyword is also useful for 64-bit types like long and double since they are written in two operations.<br />Without the volatile keyword you risk stale or invalid values.<br /><br />One common example for using volatile is for a flag to terminate a thread. If you\'ve started a thread, and you want to be able to safely interrupt it from a different thread, you can have the thread periodically check a flag (i.e., to stop it, set the flag to true). By making the flag volatile, you can ensure that the thread that is checking its value will see that it has been set to true without even having to use a synchronized block.<br /><br /><strong>Example</strong>:<br /><em>public class Foo extends Thread {</em><br /><em>private volatile boolean close = false;</em><br /><em>public void run() {</em><br /><em>while(!close) {</em><br /><em>// do work</em><br /><em>}</em><br /><em>}</em><br /><em>public void close() {</em><br /><em>close = true;</em><br /><em>// interrupt here if needed</em><br /><em>}</em><br /><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--Compare the sleep() and wait() methods in Java, including when and why you would use one vs. the other.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>- sleep() is a blocking operation that keeps a hold on the monitor / lock of the shared object for the specified number of milliseconds.<br /><br />- wait(), on the other hand, simply pauses the thread until either (a) the specified number of milliseconds have elapsed or(b) it receives a desired notification from another thread (whichever is first), without keeping a hold on the monitor/lock of the shared object.<br /><br />- sleep() is most commonly used for polling, or to check for certain results, at a regular interval.<br />wait() is generally used in multithreaded applications, in conjunction with notify() / notifyAll(), to achieve synchronization and avoid race conditions.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Java Classloader? List and explain the purpose of the three types of the class loaders.        -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>The Java Classloader is the part of the Java runtime environment that loads classes on demand (lazy loading) into the JVM (Java Virtual Machine). Classes may be loaded from the local file system, a remote file system, or even the web.<br /><br />When the JVM is started, three class loaders are used:<br />1. Bootstrap Classloader: Loads core java API file rt.jar from folder.<br />2. Extension Classloader: Loads jar files from folder.<br />3. System/Application Classloader: Loads jar files from path specified in the CLASSPATH environment variable.</pre>
            </pre></html>
            ]]>
        </item>
        <!--if one needs a Set, how do you choose between HashSet vs TreeSet?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>At first glance, HashSet is superior in almost every way: O(1) add, remove and contains, vs. O(log(N)) for TreeSet.<br /><br />However, TreeSet is indispensable when you wish to maintain order over the inserted elements or query for a range of elements within the set.<br /><br />Consider a Set of timestamped Event objects. They could be stored in a HashSet, with equals and hashCode based on that timestamp. This is efficient storage and permits looking up events by a specific timestamp, but how would you get all events that happened on any given day? That would require a O(n) traversal of the HashSet, but it\'s only a O(log(n)) operation with TreeSet using the tailSet method;<br /><br /><em>public class Event implements Comparable&lt;Event&gt; {</em><br /><em>private final long timestamp;</em><br /><em><br />public Event(long timestamp) {</em><br /><em>      this.timestamp = timestamp;</em><br /><em>}</em><br /><br /><em>@Override <br />public int compareTo(Event that) {</em><br /><em>      return Long.compare(this.timestamp, that.timestamp);</em><br /><em>   }</em><br /><em>}</em><br /><em>         ...<br /></em><br /><em>SortedSet&lt;Event&gt; events = new TreeSet&lt;&gt;();</em><br /><em>events.addAll(...); // events come in</em><br /><br /><em>// all events that happened today</em><br /><em>long midnightToday = ...;</em><br /><em>events.tailSet(new Event(midnightToday));</em><br /><em>}</em><br /><br />If Event happens to be a class that we cannot extend or that doesn\'t implement Comparable, TreeSet allows us to pass in our own Comparator:<br /><br /><em>SortedSet&lt;Event&gt;; events = new TreeSet&lt;&gt;(</em><br /><em>    (left, right) -&gt; Long.compare(left.timestamp, right.timestamp));</em><br /><br />Generally speaking, TreeSet is a good choice when order matters and when reads are balanced against the increased cost of writes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How are Java enums more powerful than integer constants? How can this capability be used?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>Enums are essentially final classes with a fixed number of instances. They can implement interfaces but cannot extend another class.<br />This flexibility is useful in implementing the strategy pattern, for example, when the number of strategies is fixed.<br />Consider an address book that records multiple methods of contact. We can represent these methods as an enum and attach fields, like the filename of the icon to display in the UI, and any corresponding behaviour, like how to initiate contact via that method:<br /><br /><em>public enum ContactMethod {</em><br /><em>PHONE("telephone.png") {</em><br /><em>@Override public void initiate(User user) {</em><br /><em>    Telephone.dial(user.getPhoneNumber());</em><br /><em>    }</em><br /><em>},</em><br /><em>EMAIL("envelope.png") {</em><br /><em>@Override public void initiate(User user) {</em><br /><em>       EmailClient.sendTo(user.getEmailAddress());</em><br /><em>    }</em><br /><em>},</em><br /><em> SKYPE("skype.png") {</em><br /><em>     ...</em><br /><em>};</em><br /><br /><em>ContactMethod(String icon) {</em><br /><em>    this.icon = icon;</em><br /><em>}</em><br /><br /><em>private final String icon;</em><br /><br /><em>public abstract void initiate(User user);</em><br /><br /><em>public String getIcon() {</em><br /><em>     return icon;</em><br /><em>}</em><br /><em>}</em><br /><br />We can dispense with switch statements entirely by simply using instances of ContactMethod:<br /><br /><em>ContactMethod method = user.getPrimaryContactMethod();</em><br /><em>displayIcon(method.getIcon());</em><br /><em>method.initiate(user);</em><br /><br />This is just the beginning of what can be done with enums.<br />Generally, the safety and flexibility of enums means they should be used in place of integer constants, and switch statements can be eliminated with liberal use of abstract methods.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are static initializers and when would you use them?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A static initializer gives you the opportunity to run code during the initial loading of a class and it guarantees that this code will only run once and will finish running before your class can be accessed in any way.<br />They are useful for performing initialization of complex static objects or to register a type with a static registry, as JDBC drivers do.<br />Suppose you want to create a static, immutable Map containing some feature flags.<br />Java doesn\'t have a good one-liner for initializing maps, so you can use static initializers instead:<br /><br /><em>public static final Map&lt;String, Boolean&gt; FEATURE_FLAGS;</em><br /><em>static {</em><br /><em>Map&lt;String, Boolean&gt; flags = new HashMap&lt;&gt;();</em><br /><em>flags.put("frustrate-users", false);</em><br /><em>flags.put("reticulate-splines", true);</em><br /><em>flags.put(...);</em><br /><em>FEATURE_FLAGS = Collections.unmodifiableMap(flags);</em><br /><em>}<br /></em><br />Within the same class, you can repeat this pattern of declaring a static field and immediately initializing it, since multiple static initializers are allowed.</pre>
            </pre></html>
            ]]>
        </item>
        <!--what is serialization? how do you implement it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Serialization is the process of converting an object into a stream of bytes in order to store an object into memory, so that it can be recreated at a later time, while still keeping the object\'s original state and data.<br /><br />After a serialized object has been written into a file, it can be read from the file and deserialized that is, the type information and bytes that represent the object and its data can be used to recreate the object in memory.<br /><br />Most impressive is that the entire process is JVM independent, meaning an object can be serialized on one platform and deserialized on an entirely different platform.<br /><br />Classes ObjectInputStream and ObjectOutputStream are high-level streams that contain the methods for serializing and deserializing an object.<br /><br /><strong>Example</strong>:<br />Suppose that we have the following Employee class, which implements the Serializable interface;<br /><br /><em>public class Employee implements java.io.Serializable {</em><br /><em>public String name;</em><br /><em>public String address;</em><br /><em>public transient int SSN;</em><br /><em>public int number;</em><br /><br /><em>public void mailCheck() {</em><br /><em>      System.out.println("Mailing a check to " + name + " " + address);</em><br /><em>   }</em><br /><em>}</em><br /><br /><strong>Serializing an Object</strong>;<br /><em>import java.io.*;</em><br /><em>public class SerializeDemo {</em><br /><br /><em>public static void main(String [] args) {</em><br /><em>Employee e = new Employee();</em><br /><em> e.name = "Reyan Ali";</em><br /><em> e.address = "Phokka Kuan, Ambehta Peer";</em><br /><em> e.SSN = 11122333;</em><br /><em> e.number = 101;</em><br /><br /><em> try {</em><br /><em> FileOutputStream fileOut =</em><br /><em> new FileOutputStream("/tmp/employee.ser");</em><br /><em> ObjectOutputStream out = new ObjectOutputStream(fileOut);</em><br /><em> out.writeObject(e);</em><br /><em> out.close();</em><br /><em> fileOut.close();</em><br /><em> System.out.printf("Serialized data is saved in /tmp/employee.ser");</em><br /> <br /><em>} catch (IOException i) {</em><br /><em> i.printStackTrace();</em><br /><em> }</em><br /><em> }</em><br /><em> }</em><br /><br /><strong>Note</strong> &minus; When serializing an object to a file, the standard convention in Java is to give the file a .ser extension.<br /><br /><strong>Deserializing an Object</strong>;<br /><em>import java.io.*;</em><br /><em>public class DeserializeDemo {</em><br /><br /><em>public static void main(String [] args) {</em><br /><em>Employee e = null;</em><br /><br /><em>try {</em><br /><em> FileInputStream fileIn = new FileInputStream("/tmp/employee.ser");</em><br /><em> ObjectInputStream in = new ObjectInputStream(fileIn);</em><br /><em> e = (Employee) in.readObject();</em><br /><em> in.close();</em><br /><em> fileIn.close();</em><br /> <br /><em>}</em><br /><em> catch (IOException i) {</em><br /><em> i.printStackTrace();</em><br /><em> return;</em><br /> <br /><em>}</em><br /><em> catch (ClassNotFoundException c) {</em><br /><em> System.out.println("Employee class not found");</em><br /><em> c.printStackTrace();</em><br /><em> return;</em><br /><em> }</em><br /><br /><em> System.out.println("Deserialized Employee...");</em><br /><em> System.out.println("Name: " + e.name);</em><br /><em> System.out.println("Address: " + e.address);</em><br /><em> System.out.println("SSN: " + e.SSN);</em><br /><em> System.out.println("Number: " + e.number);</em><br /><em>  }</em><br /><em> }</em><br /><br /><strong>Output</strong>:<br />Deserialized Employee...<br />Name: Reyan Ali<br />Address:Phokka Kuan, Ambehta Peer<br />SSN: 0<br />Number:101</pre>
            </pre></html>
            ]]>
        </item>
    </string-array>

    <!--Android Technical Questions-->
    <string-array name="androidTechnicalQuestions">
        <item>
            Why did you become an Android developer? What are some of the advantages of the Android platform?
        </item>
        <item>
            What are the latest Android versions? The most important Oreo new features?
        </item>
        <item>
            What Is the Google Android SDK?
        </item>
        <item>
            What is the Android Architecture?
        </item>
        <item>
            Describe the Android Framework.
        </item>
        <item>
             What is AAPT?
        </item>
        <item>
            Mention Native Android Actions?
        </item>
        <item>
            Describe Activities.
        </item>
        <item>
             What do you know about Material design?
        </item>
        <item>
            What’s the difference between Dialog and AlertDialog in Android?
        </item>
        <item>
            What’s the difference between FrameLayout, GridLayout, ConstraintLayout, LinearLayout and RelativeLayout and which has better performance?
        </item>
        <item>
            What are Intents and Describe three common use cases for using an Intent.
        </item>
        <item>
            Where should you use implicit and explicit intent?
        </item>
        <item>
            What is the function of an intent filter?
        </item>
        <item>
            What are containers?
        </item>
        <item>
             What do you think are some disadvantages of Android?
        </item>
        <item>
            What are the four essential states of an activity?
        </item>
        <item>
            What are the seven lifecycle methods of Android activity and what is their purpose?
        </item>
        <item>
            The last callback in the lifecycle of an activity is onDestroy().
            The system calls this method on your activity as the final signal that your activity instance is being completely
            removed from the system memory. Usually, the system will call onPause() and onStop() before calling onDestroy().
            Describe a scenario, though, where onPause() and onStop() would not be invoked.
        </item>
        <item>
            What is the importance of settings permissions in app development?
        </item>
        <item>
            Enumerate the three key loops when monitoring an activity.
        </item>
        <item>
            What is the difference between a fragment and an activity? Explain the relationship between the two.
        </item>
        <item>
            Which method is called only once in a fragment life cycle?
        </item>
        <item>
            When is the onStop() method invoked?
        </item>
        <item>
            What are the different states wherein a process is based?
        </item>
        <item>
            How to communicate between fragments?
        </item>
        <item>
            What is ANR, When does it occur and How can it be prevented?
        </item>
        <item>
            What role does Dalvik play in Android development?
        </item>
        <item>
            What is the AndroidManifest.xml?
        </item>
        <item>
            What is AIDL and What data types are supported?
        </item>
        <item>
            What is the difference between foreground and visible lifetime?
        </item>
        <item>
            What is the difference between a regular bitmap and a nine-patch image?
        </item>
        <item>
            How many types we can store data in Android Phone, which is better approaches
            in SharedPreferences and SQLite to save small data or large data ?
        </item>
        <item>
            What is SQLite? How does it differ from client-server database management systems?
        </item>
        <item>
            What is DDMS and what can it do?
        </item>
        <item>
            What is a ContentProvider and what is it typically used for?
        </item>
        <item>
            Under what condition could the code sample crash your application? How would you modify the code to avoid this potential problem?
            Explain your answer.
        </item>
        <item>
            Suppose that you are starting a service in an Activity as follows:
            \nIntent service = new Intent(context, MyService.class);
            \nstartService(service);
            \nwhere MyService accesses a remote server via an Internet connection.
            \nIf the Activity is showing an animation that indicates some kind of progress, what issue might you encounter and
            how could you address it?
        </item>
        <item>
            What is the difference between Service, IntentService, Thread and AsyncTask? How is each used?
        </item>
        <item>
            How to run the service even after killing the application in android ?
        </item>
        <item>
            Normally, in the process of carrying out a screen reorientation, the Android platform tears down the foreground activity
            and recreates it, restoring each of the view values in the activity’s layout.
            \nIn an app you’re working on, you notice that a view’s value is not being restored after screen reorientation.
            What could be a likely cause of the problem that you should verify, at a minimum, about that particular view?
        </item>
        <item>
            What is the relationship between the life cycle of an AsyncTask and an Activity?
            What problems can this result in? How can these problems be avoided?
        </item>
        <item>
            What is the difference between Serializable and Parcelable ? Which is best approach in Android ?
        </item>
        <item>
            What are "launch modes"? What are the two mechanisms by which they can be defined? What specific types of
            launch modes are supported?
        </item>
        <item>
            What is a broadcast receiver?
        </item>
        <item>
            When dealing with multiple resources, which one takes precedence?
        </item>

    </string-array>

    <!--Android Technical Answers -->
    <string-array name="androidTechnicalAnswers">
        <!--Why did you become an android developer? what are some of the advantages of the Android platform?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>You want a developer who really knows how to play to the strengths of your chosen platform.<br />Some key advantages of Android are listed below for your convenience.<br /><br />- <strong>Open Source</strong>: No licenses, no distribution or development fees.<br />- <strong>DVM</strong> (Dalvik Virtual Machine): DVM is a highly optimized virtual machine for mobile devices.<br />- <strong>Platform Diversity</strong>: Since Android is open-source, it has been adopted by a wide range of manufacturers of mobile devices.<br />- <strong>Experience with Java</strong>: Java is the language of choice for Android app development.<br /><br />Those who already have years of experience in Java will feel right at home developing for Android.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the latest Android versions? The most important Oreo new features?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Android Versions with Code names From 2015 which are supported by Google.<br />- October 2015: Marshmallow 6.0 - 6.0.1, API level 23<br />- August 2016: Nougat 7.0 - 7.1.2, API level 24 - 25<br />- August 2017: Oreo 8.0 - 8.1, API level 26 - 27<br />- May 2018: Android P (Beta) - 9, API level 28<br /><br /><strong>Noticeable Features</strong>:<br />- <strong>Power Saving</strong>:<br />For one, Google has put automatic limits on background app activities in the latest version of Android.<br />This means that the operating system will specifically limit background usage including broadcasts, background services, and location updates. This translates to less energy consumption by apps when you are not actively using them and longer battery life as a result.<br /><br />- <strong>Better and more Secure Apps</strong>:<br />Google is now very active in nudging developers towards optimizing their apps. Google Play Protect is a background service that will quietly analyze the behavior of apps in an effort to detect malware and, if found, automatically remove it from your device and from the Play Store itself (exactly how that part works is still a bit fuzzy right now).<br />Google is also being a bit stricter on developers when it comes to stability and performance.<br />If the app falls in the bottom 25 percent, the dev will get a warning and if there are no improvements, it might result in the app being pulled off the Google Play Store.<br /><br />- <strong>Preventing Boot Loops</strong>:<br />This is a great feature to be introduced in the new Android 8.0 Oreo. Rescue Party is a feature that helps prevent boot loops.<br />Boot loop, if you are unfamiliar with the term, is what happens when the device starts up and restarts immediately over and over.<br />When core systems are not running well, Android will take notice of that and try to return them to their default states.<br />If that doesn\'t work, it will reboot automatically in the Recovery Mode and provide the option of a factory reset as a last ditch effort.<br /><br />- <strong>Wi-Fi Aware</strong>:<br />Compatible smartphones will be able to use Neighbor Awareness Networking and communicate with nearby devices without an internet connection.<br />"Wi-Fi Aware continuously discovers other devices within a user\'s Wi-Fi range prior to association, making it easy to find nearby information and services available that match preferences set by the user. Wi-Fi Aware devices bring users a more interesting, relevant, and productive mobility experience. An individual in a subway station can connect to a person within proximity to play a game, while simultaneously receiving train schedule updates without the need for an internet connection.<br />Co-workers on a lunch break can establish peer-to-peer connections to share photos, while also maintaining a connection to the company network.<br />Wi-Fi Aware is a key enabler of a truly personalized social, local, and mobile experience and works well in crowded environments.<br />Wi-Fi Aware is poised for mass adoption, with native support available in the Android Oreo operating system."<br /><br />- <strong>Google Autofill</strong>:<br />Google resolves this annoyance by bringing Autofill password management to Android. This feature allows you to manage all of your passwords in a single place, and will result in an easier and more secure way to log into your accounts.<br />And the best part is that it syncs across devices, so if you\'ve used Google Autofill while browsing the internet with Chrome, you\'ll have access to all that log in information via your mobile device, too, as long as you\'re using the same Google Account.<br /><br />For developer features, check <a href="https://developer.android.com/about/versions/oreo/android-8.0">Android Developers</a>.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Google Android SDK?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>The Google Android SDK is a toolset that developers need in order to write apps on Android enabled devices.<br />It contains a graphical interface that emulates an Android driven handheld environment, allowing them to test<br />and debug their codes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the Android Architecture?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The Android software stack is typically divided into the five main components detailed below.<br />- <strong>Linux Kernel</strong>: The base layer of an application that directly interfaces with the device hardware - this is the level that deals with hardware drivers like the camera, keypad, and display.<br />- <strong>Native Libraries</strong>: Resting on top of the Linux Kernel are a set of open-source libraries, including the SQLite database, libc, and the WebKit browser engine.<br />- <strong>Android Runtime</strong>: The Dalvik Virtual Machine is in the same level as the Native Libraries and allows every Android app to run its own processes.<br />- <strong>Application Framework</strong>: The next layer up provides higher-level services in the form of Java classes to applications on the device. The key services to know are the Activity Manager, Content Providers, Resource Manager, Notifications Manager, and the View System.<br />- <strong>Applications</strong>: The top layer is the Android App itself. This is the level where applications are actually installed, and the one developers are most familiar with.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Describe the Android Framework?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The Android Framework is an important aspect of the Android Architecture. Here you can find all the classes and methods that developers would need in order to write applications on the Android environment.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is AAPT?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>AAPT is short for Android Asset Packaging Tool. This tool provides developers with the ability to deal with zip-compatible archives, which includes creating, extracting as well as viewing its contents.<br />So It is the default tool of the Android SDK to pack all classes and resources in an APK file.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Mention Native Android actions?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The following non-comprehensive list shows some of the native actions available as static string constants in the Intent class.<br />When creating implicit Intents you can use these actions, called Activity Intents, to start Activities and sub-Activities within your own applications.<br /><br />- <strong>action_answer</strong>: Opens an Activity that handles incoming calls. Currently this is handled by the native in-call screen.<br /><br />- <strong>action_call</strong>: Brings up a phone dialer and immediately initiates a call using the number supplied in the Intent URI.<br />Generally it\'s considered better form to use action_dial if possible.<br /><br />- <strong>action_delete</strong>: Starts an Activity that lets you delete the data specified at the Intent\'s data URI.<br /><br />- <strong>action_dial</strong>: Brings up a dialer application with the number to dial pre-populated from the Intent URI.<br />By default this is handled by the native Android phone dialer. The dialer can normalize most number schemas:<br />for example, <em>tel:555-1234</em> and <em>tel:(212) 555 1212</em> are both valid numbers.<br /><br />- <strong>action_edit</strong>: Requests an Activity that can edit the data at the specified Intent URI.<br /><br />- <strong>action_insert</strong>: Opens an Activity capable of inserting new items into the Cursor specified in the Intent URI.<br />When called as a sub-Activity it should return a URI to the newly inserted item.<br /><br />- <strong>action_pick</strong>: Launches a sub-Activity that lets you pick an item from the Content Provider specified by the Intent URI.<br />When closed it should return a URI to the item that was picked. The Activity launched depends on the data being picked:<br />for example, passing <em>content://contacts/people</em> will invoke the native contacts list.<br /><br />- <strong>action_search</strong>: Launches the Activity used for performing a search. Supply the search term as a string in the Intent\'s<br />extras using thffiearchManager.QUERY key.<br /><br />- <strong>action_sendto</strong>: Launches an Activity to send a message to the contact specified by the Intent URI.<br /><br />- <strong>action_send</strong>: Launches an Activity that sends the data specified in the Intent. The recipient contact needs to be selected by the resolved Activity. Use setType to set the MIME type of the transmitted data.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Describe Activities.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View).<br />While activities are often presented to the user as full-screen windows, they can also be used in other ways:<br />as floating windows (via a theme with windowIsFloating set) or embedded inside of another activity (using ActivityGroup).<br />There are two methods almost all subclasses of Activity will implement:<br /><br />- <strong>onCreate(Bundle)</strong> is where you initialize your activity.<br />Most importantly, here you will usually call setContentView(int) with a layout resource defining your UI, and using<br /><br />- <strong>onPause()</strong> is where you deal with the user leaving your activity. Most importantly, any changes made by the user should at this point be committed (usually to the ContentProvider holding the data).<br /><br />To be of use with Context.startActivity(), all activity classes must have a corresponding &lt;activity&gt;;<br />declaration in their package\'s AndroidManifest.xml.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What do you know about Material Design-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
             <pre>Material design is a comprehensive guide for visual, motion, and interaction design across platforms and devices.<br />To use material design in Android apps, follow the guidelines and use the new components and styles available in the material design support library.<br /><br />Android provides the following features to help you build material design apps:<br /><br />- A material design app theme to style all your UI widgets<br />- Widgets for complex views such as lists and cards<br />- New APIs for custom shadows and animations</pre>
             </pre></html>
            ]]>
        </item>
        <!--What's the difference between Dialog and AlertDialog Android?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Dialogs in Android are used to shows alerts for making decisions or to edit a single value.<br />But there are some differences between an AlertDialog and a BasicDialog.<br />In an AlertDialog you always want to show a message and at least one Button for user interaction.<br />In a BasicDialog you have a custom view to a TextView or something more complex.<br /><br />Furthermore AlertDialog is derived from Dialog and provides additional functionality in terms of Dialog Title, Icon, 3 lines of message you can display to the user.<br />It also provides for lists, checkboxes etc. So you can decide which one to choose yourself.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What’s the difference between FrameLayout, GridLayout, ConstraintLayout, LinearLayout and RelativeLayout
        and which has better performance?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- <strong>ConstraintLayout</strong>: ConstraintLayout allows you to create large and complex layouts with a flat view hierarchy (no nested view groups). It\'s similar to RelativeLayout in that all views are laid out according to relationships between sibling views and the parent layout, but it\'s more flexible than RelativeLayout and easier to use with Android Studio\'s Layout Editor.<br />All the power of ConstraintLayout is available directly from the Layout Editor\'s visual tools, because the layout API and the Layout Editor were specially built for each other. So you can build your layout with ConstraintLayout entirely by drag-and-dropping instead of editing the XML.<br /><br />- <strong>FrameLayout</strong>: FrameLayout is designed to block out an area on the screen to display a single item. Generally, FrameLayout should be used to hold a single child view, because it can be difficult to organize child views in a way that\'s scalable to different screen sizes without the children overlapping each other. You can, however, add multiple children to a FrameLayout and control their position within the FrameLayout by assigning gravity to each child, using the android:layout_gravity attribute.<br />Child views are drawn in a stack, with the most recently added child on top. The size of the FrameLayout is the size of its largest child (plus padding), visible or not (if the FrameLayout\'s parent permits). Views that are GONE are used for sizing only if setConsiderGoneChildrenWhenMeasuring() is set to true.<br /><br />- <strong>GridLayout</strong>: A layout that places its children in a rectangular grid.<br />The grid is composed of a set of infinitely thin lines that separate the viewing area into cells.<br />Throughout the API, grid lines are referenced by grid indices. A grid with N columns has N + 1 grid indices that run from 0 through N inclusive. Regardless of how GridLayout is configured, grid index 0 is fixed to the leading edge of the container and grid index N is fixed to its trailing edge (after padding is taken into account).<br /><br />- <strong>LinearLayout</strong>: LinearLayout is a view group that aligns all children in a single direction, vertically or horizontally. You can specify the layout direction with the android:orientation attribute.<br />All children of a LinearLayout are stacked one after the other, so a vertical list will only have one child per row, no matter how wide they are, and a horizontal list will only be one row high (the height of the tallest child, plus padding).<br />A LinearLayout respects margins between children and the gravity (right, center, or left alignment) of each child.<br /><br />- <strong>RelativeLayout</strong>: RelativeLayout is a view group that displays child views in relative positions.<br />The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent RelativeLayout area (such as aligned to the bottom, left or center).<br />A RelativeLayout is a very powerful utility for designing a user interface because it can eliminate nested view groups and keep your layout hierarchy flat, which improves performance. If you find yourself using several nested LinearLayout groups, you may be able to replace them with a single RelativeLayout.<br /><br /><strong>Conclusion</strong>: A detailed performance testing is made in <a href="https://android-developers.googleblog.com/2017/08/understanding-performance-benefits-of.html">Android Developers</a>.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are intents and Describe three common use cases for using an Intent.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>An Intent is a messaging object you can use to request an action from another app component.<br />Although intents facilitate communication between components in several ways, there are three fundamental use cases:<br /><br />- <strong>Starting an Activity</strong>:<br />An Activity represents a single screen in an app. You can start a new instance of an Activity by passing an Intent to startActivity(). The Intent describes the activity to start and carries any necessary data.<br />\nIf you want to receive a result from the activity when it finishes, call startActivityForResult(). Your activity receives the result as a separate Intent object in your activity\'s onActivityResult() callback. For more information, see the Activities guide.<br /><br />- <strong>Starting a Service</strong>:<br />A Service is a component that performs operations in the background without a user interface.<br />With Android 5.0 (API level 21) and later, you can start a service with JobScheduler.<br />For more information about JobScheduler, see its API-reference documentation.<br />For versions earlier than Android 5.0 (API level 21), you can start a service by using methods of the Service class.<br />You can start a service to perform a one-time operation (such as downloading a file) by passing an Intent to startService().<br />The Intent describes the service to start and carries any necessary data.<br />If the service is designed with a client-server interface, you can bind to the service from another component by passing an Intent to bindService(). For more information, see the Services guide.<br /><br />- <strong>Delivering a Broadcast</strong>:<br />A broadcast is a message that any app can receive. The system delivers various broadcasts for system events, such as when the system boots up or the device starts charging. You can deliver a broadcast to other apps by passing an Intent to sendBroadcast() or sendOrderedBroadcast().<br /><br />There are two types of <strong>intents</strong>:<br /><br />-<strong> Explicit intents</strong> specify which application will satisfy the intent, by supplying either the target app\'s package name or a fully-qualified component class name. You\'ll typically use an explicit intent to start a component in your own app, because you know the class name of the activity or service you want to start. For example, you might start a new activity within your app in response to a user action, or start a service to download a file in the background.<br /><br />- <strong>Implicit intents</strong> do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Where should you use implicit and explicit intent? -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>- You\'ll typically use an explicit intent to start a component in your own app, because you know the class name of the activity or service you want to start. For example, you might start a new activity within your app in response to a user action, or start a service to download a file in the background.<br /><br />- Implicit intents do not name a specific component, but instead declare a general action to perform, which allows a component from another app to handle it. For example, if you want to show the user a location on a map, you can use an implicit intent to request that another capable app show a specified location on a map.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the function of an intentfilter?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Specifies the types of intents that an activity, service, or broadcast receiver can respond to.<br />An intent filter declares the capabilities of its parent component &mdash; what an activity or service can do and what types of broadcasts a receiver can handle. It opens the component to receiving intents of the advertised type, while filtering out those that are not meaningful for the component.<br /><br />Most of the contents of the filter are described by its &lt;action&gt;, &lt;category&gt;, and &lt;data&gt; subelements.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are containers?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Containers, as the name itself implies, holds objects and widgets together, depending on which specific items are needed and in what particular arrangement that is wanted. Containers may hold labels, fields, buttons, or even child containers, as examples.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What do you think are some disadvantages of Android?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>Given that Android is an open-source platform, and the fact that different Android operating systems have been released on different mobile devices, there\'s no clear cut policy to how applications can adapt with various OS versions and upgrades.<br />One app that runs on this particular version of Android OS may or may not run on another version. Another disadvantage is that since mobile devices such as phones and tabs come in different sizes and forms, it poses a challenge for developers to create apps that can adjust correctly to the right screen size and other varying features and specs.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the four essential states of an activity?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre><strong>Active</strong> &ndash; if the activity is at the foreground.<br /><strong>Paused</strong> &ndash; if the activity is at the background and still visible.<br /><strong>Stopped</strong> &ndash; if the activity is not visible and therefore is hidden or obscured by another activity.<br /><strong>Destroyed</strong> &ndash; when the activity process is killed or completed terminated.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the seven lifecycle methods of Android activity and what is their purpose?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The seven lifecycle methods of Android activity are onCreate(), onStart(), onRestart(), onResume(), onPause(), onStop(), and onDestroy(). Their purpose is to help structure your code around how you want an activity to perform throughout its lifecycle on the device.<br /><br />For example, onCreate() is where you would perform your static setup, from creating views to binding data to lists.<br />It is always immediately followed by onStart(), where the app will be made visible to the user.<br /><br />What you\'re looking for in their response is a solid grasp of the lifecycle of an Android app.<br />The functions of these methods are pretty self-explanatory based on their names.</pre>
           </pre></html>
            ]]>
        </item>
        <!--The last callback in the lifecycle of an activity is onDestroy().
        The system calls this method on your activity as the final signal that your activity instance is being completely
        removed from the system memory. Usually, the system will call onPause() and onStop() before calling onDestroy().
        Describe a scenario, though, where onPause() and onStop() would not be invoked.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>onPause() and onStop() will not be invoked if finish() is called from within the onCreate() method.<br />This might occur, for example, if you detect an error during onCreate() and call finish() as a result.<br />In such a case, though, any cleanup you expected to be done in onPause() and onStop() will not be executed.<br /><br />Although onDestroy() is the last callback in the lifecycle of an activity, it is worth mentioning that this callback may not always be called and should not be relied upon to destroy resources. It is better have the resources created in onStart() and onResume(), and have them destroyed in onStop() and onPause(), respectively.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the importance of settings permissions in app development?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The purpose of a permission is to protect the privacy of an Android user. Android apps must request permission to access sensitive user data (such as contacts and SMS), as well as certain system features (such as camera and internet).<br />Depending on the feature, the system might grant the permission automatically or might prompt the user to approve the request.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Enumerate the three key loops when monitoring an activity-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Entire lifetime</strong> &ndash; activity happens between onCreate and onDestroy.<br /><strong>Visible lifetime</strong> &ndash; activity happens between onStart and onStop.<br /><strong>Foreground lifetime</strong> &ndash; activity happens between onResume and onPause.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the difference between a fragment and an activity? Explain the relationship between the two.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>An activity is typically a single, focused operation that a user can perform (such as dial a number, take a picture, send an email, view a map, etc.). Yet at the same time, there is nothing that precludes a developer from creating an activity that is arbitrarily complex.<br /><br />Activity implementations can optionally make use of the Fragment class for purposes such as producing more modular code, building more sophisticated user interfaces for larger screens, helping scale applications between small and large screens, and so on. Multiple fragments can be combined within a single activity and, conversely, the same fragment can often be reused across multiple activities. This structure is largely intended to foster code reuse and facilitate economies of scale.<br /><br />A fragment is essentially a modular section of an activity, with its own lifecycle and input events, and which can be added or removed at will. It is important to remember, though, that a fragment\'s lifecycle is directly affected by its host activity\'s lifecycle; i.e., when the activity is paused, so are all fragments in it, and when the activity is destroyed, so are all of its fragments.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Which method is called only once in a fragment life cycle?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
        <pre>- <strong>onAttached()</strong>;</pre>
        </pre></html>
            ]]>
        </item>
        <!--When is the onStop() method invoked?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
          <pre>A call to onStop method happens when an activity is no longer visible to the user, either because another activity has taken over or if in front of that activity.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are the different states wherein a process is based?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>There are 4 possible states:<br />&ndash; <strong>foreground activity</strong><br />&ndash; <strong>visible activity</strong><br />&ndash; <strong>background activity</strong><br />&ndash; <strong>empty process</strong></pre>
            </pre></html>
            ]]>
        </item>
        <!--How to communicate between fragments?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>In order to reuse the Fragment UI components, you should build each as a completely self-contained, modular component that defines its own layout and behavior. Once you have defined these reusable Fragments, you can associate them with an Activity and connect them with the application logic to realize the overall composite UI.<br /><br />Often you will want one Fragment to communicate with another, for example to change the content based on a user event.<br />All Fragment-to-Fragment communication is done either through a shared ViewModel or through the associated Activity.<br />Two Fragments should never communicate directly.<br /><br />To allow a Fragment to communicate up to its Activity, you can define an interface in the Fragment class and implement it within the Activity. The Fragment captures the interface implementation during its onAttach() lifecycle method and can then call the Interface methods in order to communicate with the Activity.<br /><br /><strong>Example</strong>:<strong> Define an Interface;</strong><br /><em>public class HeadlinesFragment extends ListFragment {</em><br /><em>OnHeadlineSelectedListener mCallback;</em><br /><br /><em>// Container Activity must implement this interface</em><br /><br /><em>public interface OnHeadlineSelectedListener {</em><br /><em>public void onArticleSelected(int position);</em><br /><em>    }</em><br /><br /><em>@Override</em><br /><em>public void onAttach(Activity activity) {</em><br /><em>      super.onAttach(activity);</em><br /><br /><em>// This makes sure that the container activity has implemented</em><br /><em>// the callback interface. If not, it throws an exception</em><br /><em>try {</em><br /><em>    mCallback = (OnHeadlineSelectedListener) activity;</em><br /><em>  } catch (ClassCastException e) {</em><br /><em>throw new ClassCastException(activity.toString()</em><br /><em>+ " must implement OnHeadlineSelectedListener");</em><br /><em>}</em><br /><em>}</em><br /><br /><em>          ...</em><br /><em>}</em><br /><br />Now the fragment can deliver messages to the activity by calling the onArticleSelected() method (or other methods in the interface) using the mCallback instance of the OnHeadlineSelectedListener interface.<br /><br />For example, the following method in the fragment is called when the user clicks on a list item. The fragment uses the callback interface to deliver the event to the parent activity.<br /><br /><strong>Implement The Interface;</strong><br />In order to receive event callbacks from the fragment, the activity that hosts it must implement the interface defined in the fragment class.<br /><br /><em>public static class MainActivity extends Activity</em><br /><em>implements HeadlinesFragment.OnHeadlineSelectedListener{</em><br /><em> ...</em><br /><br /><em>public void onArticleSelected(int position) {</em><br /><em> // The user selected the headline of an article from the HeadlinesFragment</em><br /><em> // Do something here to display that article</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Deliver a Message to a Fragment;</strong><br />The host activity can deliver messages to a fragment by capturing the Fragment instance with findFragmentById(), then directly call the fragment\'s public methods.<br />For instance, imagine that the activity shown above may contain another fragment that\'s used to display the item specified by the data returned in the above callback method. In this case, the activity can pass the information received in the callback method to the other fragment that will display the item:<br /><br /><em>public static class MainActivity extends Activity</em><br /><em>implements HeadlinesFragment.OnHeadlineSelectedListener{</em><br /><em> ...</em><br /><br /><em>public void onArticleSelected(int position) {</em><br /><em>    // The user selected the headline of an article from the HeadlinesFragment</em><br /><em>    // Do something here to display that article</em><br /><br /><em>       ArticleFragment articleFrag = (ArticleFragment)</em><br /><em>       getSupportFragmentManager().findFragmentById(R.id.article_fragment);</em><br /><br /><em>          if (articleFrag != null) {</em><br /><em>       // If article frag is available, we\'re in two-pane layout...</em><br /><br /><em>          // Call a method in the ArticleFragment to update its content</em><br /><em>       articleFrag.updateArticleView(position);</em><br /><em>    } else {</em><br /><em> // Otherwise, we\'re in the one-pane layout and must swap frags...</em><br /><br /><em>          // Create fragment and give it an argument for the selected article</em><br /><em> ArticleFragment newFragment = new ArticleFragment();</em><br /><em> Bundle args = new Bundle();</em><br /><em> args.putInt(ArticleFragment.ARG_POSITION, position);</em><br /><em> newFragment.setArguments(args);</em><br /><br /><em> FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</em><br /><br /><em>       // Replace whatever is in the fragment_container view with this fragment,</em><br /><em>       // and add the transaction to the back stack so the user can navigate back</em><br /><em>    transaction.replace(R.id.fragment_container, newFragment);</em><br /><em> transaction.addToBackStack(null);</em><br /><br /><em>          // Commit the transaction</em><br /><em>       transaction.commit();</em><br /><em>    }</em><br /><em> }</em><br /><em> }</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--What is ANR, when does it occur and how can it be prevented?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>\'ANR\' in Android is \'Application Not Responding.\' It means when the user is interacting with the activity, and the activity is in the onResume() method, a dialog appears displaying "application not responding."<br /><br />It happens because we start a heavy and long running task like downloading data in the main UI thread.<br />To avoid ANR, an app should perform lengthy database or networking operations in separate threads.<br />For background task-intensive apps, you can alleviate pressure from the UI thread by using the IntentService.<br />Other solution can be to perform your heavy tasks in the background using Async Task class.<br /><br />In general, it helps to always define time-outs for all your web service calls and to remain ever vigilant for infinite loops in complex calculations.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What role does Dalvik play in Android development?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            Dalvik serves as a virtual machine, and it is where every Android application runs.
            Through Dalvik, a device is able to execute multiple virtual machines efficiently through better memory management.
            </pre></html>
            ]]>
        </item>
        <!--What is the AndroidManifest.xml?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Every app project must have an AndroidManifest.xml file (with precisely that name) at the root of the project source set.<br />The manifest file describes essential information about your app to the Android build tools, the Android operating system, and Google Play.<br /><br />Among many other things, the manifest file is required to declare the following:<br /><br />- The app\'s package name, which usually matches your code\'s namespace. The Android build tools use this to determine the location of code entities when building your project. When packaging the app, the build tools replace this value with the application ID from the Gradle build files, which is used as the unique app identifier on the system and on Google Play.<br /><br />- The components of the app, which include all activities, services, broadcast receivers, and content providers.<br />Each component must define basic properties such as the name of its Kotlin or Java class. It can also declare capabilities such as which device configurations it can handle, and intent filters that describe how the component can be started.<br /><br />- The permissions that the app needs in order to access protected parts of the system or other apps.<br />It also declares any permissions that other apps must have if they want to access content from this app.<br /><br />- The hardware and software features the app requires, which affects which devices can install the app from Google Play.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is AIDL and What data types are supported by AIDL?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>AIDL, or Android Interface Definition Language, handles the interface requirements between a client and a service so both can communicate at the same level through interprocess communication or IPC. This process involves breaking down objects into primitives that Android can understand. This part is required simply because a process cannot access the memory of the other process.<br /><br />AIDL has support for the following data types:<br />- string<br />- charSequence<br />- List<br />- Map<br />- all native Java data types like int,long, char and Boolean</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between foreground and visible lifetime?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>The Visible Lifetime</strong>: Although this is termed the "visible lifetime", the app may not be directly visible and interacting with the user at any one time if it is not in the foreground. The feature that distinguishes this lifetime is that, even if not in the foreground, the app maintains resources such that it can instantaneously return to the foreground.<br /><br /><strong>The Foreground Lifetime</strong>: During foreground lifetime the activity is in front of all other activities and interacting with the user.<br /><br />So If you display an Activity on the screen and the user is interacting with it, it is both in the foreground and visible.<br />Between onResume() and onPause() called foreground lifetime.<br /><br />If you start another Activity, which is transparent and shows a dialog box over the previous Activity, then the new Activity (the dialog box) is in the foreground and the old Activity is not in the foreground but still visible.<br />Between onStart() and onStop() called visible lifetime.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between a regular bitmap and a nine-patch image?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>In general, a Nine-patch image allows resizing that can be used as background or other image size requirements for the target device. The Nine-patch refers to the way you can resize the image: 4 corners that are unscaled, 4 edges that are scaled in 1 axis, and the middle one that can be scaled into both axes.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How many types we can store data in Android Phone, which is better approaches
        in SharedPreferences and SQLite to save small data or large data ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Android provides several options for you to save your app data. The solution you choose depends on your specific needs, such as how much space your data requires, what kind of data you need to store, and whether the data should be private to your app or accessible to other apps and the user.<br /><br />The different data storage options available on Android:<br /><br />- <strong>Internal file storage</strong>: Store app-private files on the device file system.<br />- <strong>External file storage</strong>: Store files on the shared external file system. This is usually for shared user files, such as photos.<br />- <strong>Shared preferences</strong>: Store private primitive data in key-value pairs.<br />- <strong>Databases</strong>: Store structured data in a private database.<br /><br /><strong>Internal File Storage</strong>:<br /><em>Internal Storage</em><br />By default, files saved to the internal storage are private to your app, and other apps cannot access them (nor can the user, unless they have root access). This makes internal storage a good place for internal app data that the user doesn\'t need to directly access. The system provides a private directory on the file system for each app where you can organize any files your app needs.<br /><br />When the user uninstalls your app, the files saved on the internal storage are removed. Because of this behavior, you should not use internal storage to save anything the user expects to persist independently of your app. For example, if your app allows users to capture photos, the user would expect that they can access those photos even after they uninstall your app. So you should instead save those types of files to the public external storage.<br /><br /><em>Internal cache files</em><br />If you\'d like to keep some data temporarily, rather than store it persistently, you should use the special cache directory to save the data. Each app has a private cache directory specifically for these kinds of files. When the device is low on internal storage space, Android may delete these cache files to recover space.<br />However, you should not rely on the system to clean up these files for you. You should always maintain the cache files yourself and stay within a reasonable limit of space consumed, such as 1MB. When the user uninstalls your app, these files are removed.<br /><br /><strong>External File Storage</strong>:<br />Every Android device supports a shared "external storage" space that you can use to save files. This space is called external because it\'s not a guaranteed to be accessible&mdash;it is a storage space that users can mount to a computer as an external storage device, and it might even be physically removable (such as an SD card). Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer.<br /><br />So before you attempt to access a file in external storage in your app, you should check for the availability of the external storage directories as well as the files you are trying to access.<br /><br />Most often, you should use external storage for user data that should be accessible to other apps and saved even if the user uninstalls your app, such as captured photos or downloaded files. The system provides standard public directories for these kinds of files, so the user has one location for all their photos, ringtones, music, and such.<br /><br /><strong>Shared Preferences</strong>:<br />If you don\'t need to store a lot of data and it doesn\'t require structure, you should use SharedPreferences.<br />The SharedPreferences APIs allow you to read and write persistent key-value pairs of primitive data types:<br />booleans, floats, ints, longs, and strings.<br /><br />The key-value pairs are written to XML files that persist across user sessions, even if your app is killed. You can manually specify a name for the file or use per-activity files to save your data.<br /><br />The API name "shared preferences" is a bit misleading because the API is not strictly for saving "user preferences," such as what ringtone a user has chosen. You can use SharedPreferences to save any kind of simple data, such as the user\'s high score.<br /><br /><strong>Databases</strong>:<br />Android provides full support for SQLite databases. Any database you create is accessible only by your app.<br /><br />The SQLite APIs are fairly low-level and require a great deal of time and effort to use. For example:<br /><br />There is no compile-time verification of raw SQL queries.<br />As your schema changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.<br />You need to write lots of boilerplate code to convert between SQL queries and Java data objects.<br /><br />The Room persistence library takes care of these concerns for you while providing an abstraction layer over SQLite.<br />Therefore the Room library provides an object-mapping abstraction layer that allows fluent database access while harnessing the full power of SQLite.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is SQLite? How does it differ from client-server database management systems?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>SQLite is the open-source relational database of choice for Android applications. The SQLite engine is serverless, transactional, and self-contained. Instead of the typical client-server relationship of most database management systems, the SQLite engine is integrally linked with the application. The library can also be called dynamically, and makes use of simple function calls that reduce latency in database access.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is DDMS and what can it do?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>DDMS is short for Dalvik Debug Monitor Server. It ships natively with Android and contains a number of useful debugging features including:<br />- location data spoofing<br />- port-forwarding<br />- network traffic tracking<br />- incoming call/SMS spoofing<br />- thread and heap information<br />- screen capture<br />- and the ability to simulate network state, speed and latency.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is a ContentProvider and what is it typically used for?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <pre>A ContentProvider manages access to a structured set of data. It encapsulates the data and provide mechanisms for defining data security. ContentProvider is the standard interface that connects data in one process with code running in another process.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Under what condition could the code sample below crash your application? How would you modify the code to avoid this -->
        <!--potential problem? Explain your answer.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre><strong>Sample Code</strong>:<br /><em>Intent sendIntent = new Intent();</em><br /><em>sendIntent.setAction(Intent.ACTION_SEND);</em><br /><em>sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);</em><br /><em>sendIntent.setType(HTTP.PLAIN_TEXT_TYPE); // "text/plain" MIME type</em><br /><em>startActivity(sendIntent);</em><br /><br />An implicit intent specifies an action that can invoke any app on the device able to perform the action.<br />Using an implicit intent is useful when your app cannot perform the action, but other apps probably can.<br />If there is more than one application registered that can handle this request, the user will be prompted to select which one to use.<br /><br />However, it is possible that there are no applications that can handle your intent. In this case, your application will crash when you invoke startActivity(). To avoid this, before calling startActivity() you should first verify that there is at least one application registered in the system that can handle the intent. To do this use resolveActivity() on your intent object.<br /><br /><strong>Answer</strong>:<br /><em>// Verify that there are applications registered to handle this intent</em><br /><em>// (resolveActivity returns null if none are registered)</em><br /><em>if (sendIntent.resolveActivity(getPackageManager()) != null) {</em><br /><em>startActivity(sendIntent);</em><br /><em> }</em></pre>
             </pre></html>
            ]]>
        </item>
        <!--Suppose that you are starting a service in an Activity as follows:-->
        <!--\nIntent service = new Intent(context, MyService.class);-->
        <!--\nstartService(service);-->
        <!--\nwhere MyService accesses a remote server via an Internet connection.-->
        <!--\nIf the Activity is showing an animation that indicates some kind of progress, what issue might you encounter and-->
        <!--how could you address it?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Responses from a remote service via the Internet can often take some time, either due to networking latencies, or load on the remote server, or the amount of time it takes for the remote service to process and respond to the request.<br /><br />As a result, if such a delay occurs, the animation in the activity (and even worse, the entire UI thread) could be blocked and could appear to the user to be "frozen" while the client waits for a response from the service.<br />This is because the service is started on the main application thread (or UI thread) in the Activity.<br /><br />The problem can (and should) be avoided by relegating any such remote requests to a background thread or, when feasible, using an an asynchronous response mechanism.<br /><br /><strong>Note</strong>: Accessing the network from the UI thread throws a runtime exception in newer Android versions which causes the app to crash.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between Service and IntentService? How is each used?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Service is the base class for Android services that can be extended to create any service. A class that directly extends Service runs on the main thread so it will block the UI (if there is one) and should therefore either be used only for short tasks or should make use of other threads for longer tasks.<br /><br />IntentService is a subclass of Service that handles asynchronous requests (expressed as "Intents") on demand.<br />Clients send requests through startService(Intent) calls. The service is started as needed, handles each Intent in turn using a worker thread, and stops itself when it runs out of work. Writing an IntentService can be quite simple;<br />just extend the IntentService class and override the onHandleIntent(Intent intent) method where you can manage all incoming requests.</pre>
            </pre></html>
            ]]>
        </item>
        <!--How to run the service even after killing the application in Android?      -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The service will still have a chance of being killed by the kernel in a state of low memory if it is low priority. So you have two options:<br /><br />1) Keep it running in the foreground by calling the startForeground() method.<br /><br />2) Restart the service if it gets killed. Here is a part of the example from the docs where they talk about restarting the service after it is killed:<br /><br /><em>public int onStartCommand(Intent intent, int flags, int startId) {</em><br /><em>Toast.makeText(this, "service starting", Toast.LENGTH_SHORT).show();</em><br /><br /><em>// For each start request, send a message to start a job and deliver the</em><br /><em>// start ID so we know which request we\'re stopping when we finish the job</em><br /><em>Message msg = mServiceHandler.obtainMessage();</em><br /><em>msg.arg1 = startId;</em><br /><em>mServiceHandler.sendMessage(msg);</em><br /><br /><em>// If we get killed, after returning from here, restart</em><br /><em>return START_STICKY;</em><br /><em>}</em></pre>
             </pre></html>
            ]]>
        </item>
        <!--Normally, in the process of carrying out a screen reorientation, the Android platform tears down the foreground activity-->
        <!--and recreates it, restoring each of the view values in the activity’s layout.-->
        <!--\nIn an app you’re working on, you notice that a view’s value is not being restored after screen reorientation.-->
        <!--What could be a likely cause of the problem that you should verify, at a minimum, about that particular view?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>You should verify that it has a valid id. In order for the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the android:id attribute.<br /><br />Complete guide about the concept is on <a href="https://developer.android.com/guide/components/activities/activity-lifecycle#java">Android Developers</a>.</pre>
             </pre></html>
            ]]>
        </item>
        <!--What is the relationship between the life cycle of an AsyncTask and an Activity? What problems can this result in? How can -->
        <!--these problems be avoided?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>An AsyncTask is not tied to the life cycle of the Activity that contains it. So, for example, if you start an AsyncTask inside an Activity and the user rotates the device, the Activity will be destroyed (and a new Activity instance will be created) but the AsyncTask will not die but instead goes on living until it completes.<br /><br />Then, when the AsyncTask does complete, rather than updating the UI of the new Activity, it updates the former instance of the Activity (i.e., the one in which it was created but that is not displayed anymore!).<br />This can lead to an Exception (of the type java.lang.IllegalArgumentException: View not attached to window manager if you use, for instance, findViewById to retrieve a view inside the Activity).<br /><br />There\'s also the potential for this to result in a memory leak since the AsyncTask maintains a reference to the Activity, which prevents the Activity from being garbage collected as long as the AsyncTask remains alive.<br /><br />For these reasons, using AsyncTasks for long-running background tasks is generally a bad idea.<br />Rather, for long-running background tasks, a different mechanism (such as a service) should be employed.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is difference between Serializable and Parcelable ? Which is best approach in Android ?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Serializable is a standard Java interface. You simply mark a class Serializable by implementing the interface, and Java will automatically serialize it in certain situations.<br /><br />Parcelable is an Android specific interface where you implement the serialization yourself.<br />It was created to be far more efficient than Serializable, and to get around some problems with the default Java serialization scheme.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What are launch modes? What are the two mechanisms by which they can be defined? What specific types of launch modes are supported?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A "launch mode" is the way in which a new instance of an activity is to be associated with the current task.<br /><br />Launch modes may be defined using one of two mechanisms:<br /><br />1- <strong>Manifest file</strong>. When declaring an activity in a manifest file, you can specify how the activity should associate with tasks when it starts. Supported values include:<br />- <strong>standard</strong> (default). Multiple instances of the activity class can be instantiated and multiple instances can be added to the same task or different tasks. This is the common mode for most of the activities.<br />- <strong>singleTop</strong>. The difference from standard is, if an instance of the activity already exists at the top of the current task and the system routes the intent to this activity, no new instance will be created because it will fire off an onNewIntent() method instead of creating a new object.<br />- <strong>singleTask</strong>. A new task will always be created and a new instance will be pushed to the task as the root.<br />However, if any activity instance exists in any tasks, the system routes the intent to that activity instance through the onNewIntent() method call. In this mode, activity instances can be pushed to the same task. This mode is useful for activities that act as the entry points.<br />- <strong>singleInstance</strong>. Same as singleTask, except that the no activities instance can be pushed into the same task of the singleInstance\'s. Accordingly, the activity with launch mode is always in a single activity instance task.<br />This is a very specialized mode and should only be used in applications that are implemented entirely as one activity.<br /><br />2- <strong>Intent flags</strong>. Calls to startActivity() can include a flag in the Intent that declares if and how the new activity should be associated with the current task. Supported values include:<br />- <strong>FLAG_ACTIVITY_NEW_TASK</strong>. Same as singleTask value in Manifest file (see above).<br />- <strong>FLAG_ACTIVITY_SINGLE_TOP</strong>. Same as singleTop value in Manifest file (see above).<br />- <strong>FLAG_ACTIVITY_CLEAR_TOP</strong>. If the activity being started is already running in the current task,<br />then instead of launching a new instance of that activity, all of the other activities on top of it are destroyed and this intent is delivered to the resumed instance of the activity (now on top), through onNewIntent().<br />There is no corresponding value in the Manifest file that produces this behavior.</pre>
            </pre></html>
            ]]>
        </item>
        <!--What is a broadcast receiver?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Broadcast Receivers simply respond to broadcast messages from other applications or from the system itself.<br />These messages are sometimes called events or intents. For example, applications can also initiate broadcasts to let other applications know that some data has been downloaded to the device and is available for them to use, so this is broadcast receiver who will intercept this communication and will initiate appropriate action.</pre>
            </pre></html>
            ]]>
        </item>
        <!--When dealing with multiple resources, which one takes precedence?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Assuming that all of these multiple resources are able to match the configuration of a device, the \'locale\' qualifier almost always takes the highest precedence over the others.</pre>
            </pre></html>
            ]]>
        </item>
    </string-array>

    <!--C# Technical Questions-->
    <string-array name="csharpTechnicalQuestions">
         <item>
            What are the features of C#?
        </item>
        <item>
            What are the main differences between Java and C#?
        </item>
        <item>
            Can you describe the difference between the "constant" and the "readonly" variables when using C#? When would you use each one?
        </item>
        <item>
            What are the different types of classes in C#?
        </item>
        <item>
            Explain Code compilation in C#.
        </item>
        <item>
            What is the difference between Virtual method and Abstract method?
        </item>
        <item>
            Explain Namespaces in C#.
        </item>
        <item>
            Can you list the differences between static, public and void? What is the outcome of using each?
        </item>
        <item>
            What do you understand by Value and Reference Types?
        </item>
        <item>
            It is possible to store mixed datatypes such as int, string, float, char all in one array?
        </item>
        <item>
            Compare structs and classes in C#. What do they have in common? How do they differ?
        </item>
        <item>
            What is CLR?
        </item>
        <item>
             Does C# supports multiple inheritance.
        </item>
        <item>
            Which class acts as a base class for all exceptions in C#?
        </item>
        <item>
            Describe dependency injection.
        </item>
        <item>
            Describe boxing and unboxing. Provide an example.
        </item>
        <item>
            What is Managed and Unmanaged code?
        </item>
        <item>
            How is Exception Handling implemented in C#?
        </item>
        <item>
            What are C# I/O Classes? What are the commonly used I/O Classes?
        </item>
        <item>
            What is StreamReader/StreamWriter class?
        </item>
        <item>
            What is a Destructor in C#?
        </item>
        <item>
            What is the difference between finally and finalize block?
        </item>
        <item>
            What is the difference between Continue and Break Statement?
        </item>
        <item>
            What is a Delegate? Also What are the different types of Delegates?
        </item>
        <item>
            What are Events?
        </item>
        <item>
            How to use Delegates with Events?
        </item>
        <item>
            Explain Publishers and Subscribers in Events.
        </item>
        <item>
            What are Synchronous and Asynchronous operations?
        </item>
        <item>
            What is Reflection in C#?
        </item>
        <item>
            What is a Generic Class?
        </item>
        <item>
            Explain Get and Set Accessor properties?
        </item>
        <item>
            What are Async and Await?
        </item>
        <item>
            What is a Race Condition?
        </item>
        <item>
            What is Thread Pooling?
        </item>
        <item>
            What is Serialization? Also What are the types of Serialization?
        </item>
        <item>
            What is an XSD file?
        </item>
        <item>
            What is the difference between ref and out keywords?
        </item>
        <item>
            Can \"this\" be used within a static method?
        </item>
        <item>
            Define Property in C#.net?
        </item>
        <item>
            What is the difference between string and StringBuilder in C#?
        </item>
        <item>
            What is IEnumerable&lt;&gt; in c#?
        </item>
        <item>
            What are the differences between IEnumerable and IQueryable?
        </item>
        <item>
            What is difference between late binding and early binding in C#?
        </item>
        <item>
            What is the Constructor Chaining in C#?
        </item>
        <item>
            Can Multiple Catch Blocks executed in c#?
        </item>
        <item>
            What are Indexer in C# .Net?
        </item>
        <item>
            Difference between is and as operator in C#
        </item>
        <item>
            How to use Nullable&lt;&gt; Types in .Net?
        </item>
        <item>
            What is an Object Pool in .Net?
        </item>
        <item>
            What are the Difference between Array and ArrayList and List in C#.Net?
        </item>
        <item>
            Explain Anonymous type in C#?
        </item>
        <item>
            What is LINQ in C#?
        </item>
        <item>
            What is File Handling in C#.Net?
        </item>
        <item>
            Can you name three ways to pass parameters to a method in C#?
        </item>
        <item>
            What do the following acronyms in .NET stand for: IL, CIL, MSIL, CLI and JIT?
        </item>
        <item>
            Discuss what garbage collection is and how it works. Provide a code example of how you can enforce garbage collection in .NET.
        </item>
        <item>
            You would know that System.Object is the parent class of all .NET classes; In other words all types in .NET (whether implicit, explicit, or user-created) derive from the System.Object class.
            What are the various methods provided to System.Object\'s deriving classes/types?
        </item>
        <item>
            What is .NET web service?
        </item>
        <item>
            What is JSON data, and what is one way that .NET developers can work with JSON?
        </item>

    </string-array>

    <!--C# Technical Answers-->
    <string-array name="csharpTechnicalAnswers">
        <!--What are the features of C#?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
             <p><strong>Simple -</strong>&nbsp;C# is a simple language in the sense that it provides structured approach (to break the problem into parts), rich set of library functions, data types etc.</p>
<p><strong>Modern Programming Language -</strong> C# programming is based upon the current trend and it is very powerful and simple for building scalable, interoperable and robust applications.</p>
<p><strong>Object Oriented -</strong> C# is object oriented programming language. OOPs makes development and maintenance easier where as in Procedure-oriented programming language it is not easy to manage if code grows as project size grow.</p>
<p><strong>Type Safe -</strong> C# type safe code can only access the memory location that it has permission to execute. Therefore it improves a security of the program.</p>
<p><strong>Interoperability -</strong>&nbsp;Interoperability process enables the C# programs to do almost anything that a native C++ application can do.</p>
<p><strong>Scalable and Updatedable -&nbsp;</strong> C# is automatic scalable and updateable programming language. For updating our application we delete the old files and update them with new ones.</p>
<p><strong>Component Oriented -</strong> C# is component oriented programming language. It is the predominant software development methodology used to develop more robust and highly scalable applications.</p>
<p><strong>Structured Programming Language -</strong> C# is a structured programming language in the sense that we can break the program into parts using functions. So, it is easy to understand and modify.</p>
<p><strong>Rich Library -</strong> C# provides a lot of inbuilt functions that makes the development fast.</p>
<p><strong>Fast Speed</strong>&nbsp;- The compilation and execution time of C# language is fast.</p>
            </pre></html>
            ]]>
        </item>
        <!--What are the main differences between Java and C#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <p>- In Java methods are virtual by default but you can make them final. (In C# they\'re sealed by default, but you can make them virtual.)</p>
<p>- There are plenty of IDEs for Java, both free (e.g. Eclipse, Netbeans) and commercial (e.g. IntelliJ IDEA)</p>
<p>- Generics are completely different between the two; Java generics are just a compile-time "trick" (but a useful one at that). In C# and .NET generics are maintained at execution time too, and work for value types as well as reference types, keeping the appropriate efficiency (e.g. a List&lt;byte&gt; as a byte[] backing it, rather than an array of boxed bytes.)</p>
<p>- C# doesn\'t have checked exceptions</p>
<p>- Java doesn\'t allow the creation of user-defined value types</p>
<p>- Java doesn\'t have operator and conversion overloading</p>
<p>- Java doesn\'t have iterator blocks for simple implemetation of iterators</p>
<p>- Java doesn\'t have anything like LINQ</p>
<p>- Java doesn\'t have expression trees</p>
<p>- C# doesn\'t have anonymous inner classes</p>
<p>- C# doesn\'t have Java\'s inner classes at all, in fact - all nested classes in C# are like Java\'s static nested classes</p>
<p>- Java doesn\'t have static classes (which don\'t have any instance constructors, and can\'t be used for variables, parameters etc)</p>
<p>- Java doesn\'t have any equivalent to the C# 3.0 anonymous types</p>
<p>- Java doesn\'t have implicitly typed local variables</p>
<p>- Java doesn\'t have extension methods</p>
<p>- Java doesn\'t have object and collection initializer expressions</p>
<p>- The access modifiers are somewhat different - in Java there\'s (currently) no direct equivalent of an assembly, so no idea of "internal" visibility; in C# there\'s no equivalent to the "default" visibility in Java which takes account of namespace (and inheritance)</p>
<p>- The order of initialization in Java and C# is subtly different (C# executes variable initializers before the chained call to the base type\'s constructor)</p>
<p>- Java doesn\'t have an equivalent of the using statement for simplified try/finally handling of resources</p>
<p>- Java doesn\'t have properties as part of the language; they\'re a convention of get/set/is methods</p>
<p>- Java doesn\'t have the equivalent of "unsafe" code</p>
<p>- Interop is easier in C# (and .NET in general) than Java\'s JNI</p>
<p>- Java has no preprocessor directives (#define, #if etc in C#).</p>
<p>- Java has no equivalent of C#\'s ref and out for passing parameters by reference</p>
<p>- Java has no equivalent of partial types</p>
<p>- C# interfaces cannot declare fields</p>
<p>- Java has no unsigned integer types</p>
<p>- Java has no language support for a decimal type. (java.math.BigDecimal provides something like System.Decimal - with differences - but there\'s no language support)</p>
<p>- Java has no equivalent of nullable value types</p>
<p>- Boxing in Java uses predefined (but "normal") reference types with particular operations on them. Boxing in C# and .NET is a more transparent affair, with a reference type being created for boxing by the CLR for any value type.</p>
            </pre></html>
            ]]>
        </item>
        <!--Can you describe the difference between the constants and the readonly variables-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>While constants and read-only variable share many similarities, there are some important differences:</p>
<p>- Constants are evaluated at compile time, while the read-only variables are evaluated at run time.</p>
<p>- Constants support only value-type variables, while read-only variables can hold reference-type variables.</p>
<p>- Constants should be used when the value is not changing during run time, and read-only variables are used mostly when their actual value is unknown before run time.</p>
<p>- Read-only variables can only be initialised at the time of declaration or in a constructor.</p>
            </pre></html>
            ]]>
        </item>
        <!--what are the different types of classes -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <p><strong>- Partial class:</strong>&nbsp;Allows its members to be divided or shared with multiple .cs files. It is denoted by the keyword&nbsp;<em>Partial.</em></p>
<p><strong>- Sealed class:</strong>&nbsp;It is a class which cannot be inherited. To access the members of a sealed class, we need to create the object of the class.&nbsp; It is denoted by the keyword&nbsp;<em>Sealed</em>.</p>
<p><strong>- Abstract class:</strong>&nbsp;It is a class whose object cannot be instantiated. The class can only be inherited. It should contain at least one method.&nbsp; It is denoted by the keyword&nbsp;<em>abstract.</em></p>
<p><strong>- Static class:</strong>&nbsp;It is a class which does not allow inheritance. The members of the class are also static.&nbsp; It is denoted by the keyword&nbsp;<em>static</em>. This keyword tells the compiler to check for any accidental instances of the static class.</p>
            </pre></html>
            ]]>
        </item>
        <!--Explain code compilation in c#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>- Compiling the source code into Managed code by C# compiler.</p>
<p>- Combining the newly created code into assemblies.</p>
<p>- Loading the Common Language Runtime(CLR).</p>
<p>- Executing the assembly by CLR.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is the difference between virtual methods and abstract methods-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A&nbsp;<strong>Virtual method</strong>&nbsp;must always have a default implementation. However, it can be overridden in the derived class, though not mandatory. It can be overridden using&nbsp;<em>override</em>&nbsp;keyword.</p>
<p>An&nbsp;<strong>Abstract method</strong>&nbsp;does not have an implementation. It resides in the abstract class. It is mandatory that the derived class implements the abstract method. An&nbsp;<em>override</em>&nbsp;keyword is not necessary here though it can be used.</p>
            </pre></html>
            ]]>
        </item>
        <!--Explain namespaces -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>They are used to organize large code projects. "System" is the most widely used namespace in C#. We can create our own namespace and use one namespace in another, which are called Nested Namespaces.</p>
            </pre></html>
            ]]>
        </item>
        <!--Can you list the differences between static, public and void? What is the outcome of using each?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p>-&nbsp;<strong>public</strong>: Public Modifier in C# is most liberal among all access modifiers, it can access from anywhere inside or outside other class. There is no access restriction in public modifiers .public keyword is used just before the class keyword to declare class as public.<br /><br />-&nbsp;<strong>static</strong>: Static method is used to declare main method global one and we do not need to create instance of that class. We can access methods of static class by using the class name followed by. Operator and method name .The compiler stores Static method\'s address and uses this information before any object is created for execution.<br /><br />-&nbsp;<strong>void</strong>: The void modifier tells that the Main method can\'t return any value.</p>            </pre></html>
            ]]>
        </item>
        <!--what do you understand by value and reference types?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p>In C# data types can be of two types: Value Types and Reference Types. Value type variables contain their object (or data) directly. If we copy one value type variable to another then we are actually making a copy of the object for the second variable. Both of them will independently operate on their values, Value Type member will located into Stack and reference member will located in Heap always.<br /><br /><strong>Let consider each case briefly.</strong>&nbsp;</p>
<p><strong>- Pure Value Type</strong><br />Here I used a structure as a value type. It has an integer member. I created two instances of this structure. After wards I assigned second instance to the first one. Then I changed the state of second instance, but it hasn\'t effect the first one, as whole items are value type and assignments on those types will copy only values not references i.e. in a Value Type assignment, all instances have its own local copy of members.&nbsp;</p>
<p><strong>- Pure Reference Type</strong>&nbsp;<br />I created a class and added a "DataTable" as a Reference Type member for this class. Then I performed the assignments just like below. But the difference is that on changing the state of second instance, the state of first instance will automatically alter. So in a Reference Type assignment both Value and Reference will be assigned i.e. all instances will point to the single object.</p>
<p><strong>- Value Type With Reference Type<br /></strong>This case and the last case to come are more interesting. I used a structure in this particular scenario also. But this time it includes a Reference Type(A Custom Class Object) Member besides a Value Type (An Integer) Member. When you performing the assignments, it seems like a swallow copy, as Value Type member of first instance won\'t effected, but the Reference Type member will alter according to the second instance. So in this particular scenario, assignment of Reference Type member produced a reference to a single object and assignment of Value Type member produced a local copy of that member.&nbsp;</p>
<p><strong>- Reference Type With Value Type</strong>&nbsp;<br />Contrary to the above case, in this scenario, both Reference &amp; Value Types will be effected. I.e. a Value Type member in a Reference Type will be shared among its instances.</p>
<p>There are seven value types which are decimal, byte, double, float, int, enum and long and the four reference types are class, interface, string and object.</p>

             </pre></html>
            ]]>
        </item>
        <!--It is possible to store mixed datatypes such as int, string, float, char -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
             <p>It is possible to do so because the array can be of type&nbsp;<code>object</code>&nbsp;that can not only store any datatype but also the object of the class as shown below:</p>

                <pre><em>using System;</em><br /><em>using System.Collections.Generic;</em><br /><em>using System.Linq;</em><br /><em>using System.Text;</em>
<br /><em>namespace ConsoleApplication8</em><br /><em>{</em><br /><em>    class Program</em>
<em>    {</em><br /><em>        class Customer</em><br /><em>       {</em><br /><em>            public int ID { get; set; }</em><br /><em>            public string Name { get; set; }</em><br /><em>            public override string ToString()</em><br /><em>            {</em><br /><em>                return this.Name;</em><br /><em>            }</em><br /><em>        }</em><br /><em>        static void Main(string[] args)</em><br /><em>        {</em><br /><em>            object[] array = new object[3];</em><br /><em>            array[0] = 101;</em><br /><em>            array[1] = "C#";</em><br /><em>            Customer c = new Customer();</em><br /><em>            c.ID = 55;</em><br /><em>            c.Name = "Manish";</em><br /><em>            array[2] = c;</em><br /><em>            foreach (object obj in array)</em><br /><em>            {</em><br /><em>                Console.WriteLine(obj);</em><br /><em>            }</em><br /><em>            Console.ReadLine();</em><br /><em>        }</em><em>}</em><em>}</em></pre>
            </pre></html>
            ]]>
        </item>
        <!--compare structs and classes in c#-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Classes and Structs in C# do have a few things in common, namely:</strong></p>
<p>- Are compound data types</p>
<p>- Can contain methods and events</p>
<p>- Can support interfaces</p>
<p><strong>But there are a number of differences. Here\'s a comparison:</strong></p>
<p><strong><em>Classes:</em></strong></p>
<p>- Support inheritance</p>
<p>- Are reference (pointer) types</p>
<p>- The reference can be null</p>
<p>- Have memory overhead per new instance</p>
<p><strong><em>Structs:</em></strong></p>
<p>- Do not support inheritance</p>
<p>- Are value types</p>
<p>- Are passed by value (like integers)</p>
<p>- Cannot have a null reference (unless Nullable is used)</p>
<p>- Do not have memory overhead per new instance (unless &ldquo;boxed&rdquo;)</p>
            </pre></html>
            ]]>
        </item>
        <!--what is clr-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p class="">The .NET Framework provides a run-time environment called the common language runtime, which runs the code and provides services that make the development process easier.</p>
<p>Compilers and tools expose the common language runtime\'s functionality and enable you to write code that benefits from this managed execution environment. Code that you develop with a language compiler that targets the runtime is called managed code; it benefits from features such as cross-language integration, cross-language exception handling, enhanced security, versioning and deployment support, a simplified model for component interaction, and debugging and profiling services.</p>
<p class="">To enable the runtime to provide services to managed code, language compilers must emit metadata that describes the types, members, and references in your code. Metadata is stored with the code; every loadable common language runtime portable executable (PE) file contains metadata. The runtime uses metadata to locate and load classes, lay out instances in memory, resolve method invocations, generate native code, enforce security, and set run-time context boundaries.</p>
<p class="">The runtime automatically handles object layout and manages references to objects, releasing them when they are no longer being used. Objects whose lifetimes are managed in this way are called managed data. Garbage collection eliminates memory leaks as well as some other common programming errors. If your code is managed, you can use managed data, unmanaged data, or both managed and unmanaged data in your .NET Framework application. Because language compilers supply their own types, such as primitive types, you might not always know (or need to know) whether your data is being managed.</p>
<p>The common language runtime makes it easy to design components and applications whose objects interact across languages. Objects written in different languages can communicate with each other, and their behaviors can be tightly integrated. For example, you can define a class and then use a different language to derive a class from your original class or call a method on the original class. You can also pass an instance of a class to a method of a class written in a different language. This cross-language integration is possible because language compilers and tools that target the runtime use a common type system defined by the runtime, and they follow the runtime\'s rules for defining new types, as well as for creating, using, persisting, and binding to types.</p>
<p>As part of their metadata, all managed components carry information about the components and resources they were built against. The runtime uses this information to ensure that your component or application has the specified versions of everything it needs, which makes your code less likely to break because of some unmet dependency. Registration information and state data are no longer stored in the registry where they can be difficult to establish and maintain. Instead, information about the types you define (and their dependencies) is stored with the code as metadata, making the tasks of component replication and removal much less complicated.</p>
<p>Language compilers and tools expose the runtime\'s functionality in ways that are intended to be useful and intuitive to developers. This means that some features of the runtime might be more noticeable in one environment than in another. How you experience the runtime depends on which language compilers or tools you use. For example, if you are a Visual Basic developer, you might notice that with the common language runtime, the Visual Basic language has more object-oriented features than before. The runtime provides the following benefits:</p>
<p>- Performance improvements.</p>
<p>- The ability to easily use components developed in other languages.</p>
<p>- Extensible types provided by a class library.</p>
<p>- Language features such as inheritance, interfaces, and overloading for object-oriented programming.</p>
<p>- Support for explicit free threading that allows creation of multithreaded, scalable applications.</p>
<p>- Support for structured exception handling.</p>
<p>- Support for custom attributes.</p>
<p>- Garbage collection.- Use of delegates instead of function pointers for increased type safety and security. For more information about delegates, see&nbsp;<a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/common-type-system" data-linktype="relative-path">Common Type System</a>.</p>
            </pre></html>
            ]]>
        </item>
        <!--does c# support multiple inheritance.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>C# does not support multiple inheritance.</p>
            </pre></html>
            ]]>
        </item>
        <!--which class acts as a base class for all exceptions-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>C# exceptions are represented by classes. The exception classes in C# are mainly directly or indirectly derived from the <em>System.Exception</em> class. Some of the exception classes derived from the<em> System.Exception</em> class are the <em>System.ApplicationException</em> and <em>System.SystemException</em> classes.</p>
            </pre></html>
            ]]>
        </item>
        <!--describe dependency injection-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Dependency injection is a way to de-couple tightly linked classes, thereby reducing the direct dependency of classes upon each other. There are different ways by which dependency injection can be achived:</p>
<p>1. Constructor dependency</p>
<p>2. Property dependency</p>
<p>3. Method dependency</p>
            </pre></html>
            ]]>
        </item>
        <!--describe boxing and unboxing -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Boxing is an implicit conversion of a value type to the type&nbsp;<code>object</code>&nbsp;or to any interface type implemented by the value type. Boxing a value type creates an object instance containing the value and stores it on the heap.</p>
<p><strong>Example:</strong></p>
<p><em><code>int x = 101;
</code></em></p>
<p><em><code>object o = x;  // boxing value of x into object o</code></em></p>
<p><em><code>o = 999;</code></em></p>
<p><em><code>x = (int)o;    // unboxing value of o into integer x</code></em></p>
            </pre></html>
            ]]>
        </item>
        <!--what is managed and unmanaged code-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Managed code</strong> is a code which is executed by CLR (Common Language Runtime) i.e all application code based on .Net Platform. It is considered as managed because of the .Net framework which internally uses the garbage collector to clear up the unused memory.</p>
<p><strong>Unmanaged code</strong> is any code that is executed by application runtime of any other framework apart from .Net. The application runtime will take care of memory, security and other performance operations.</p>
            </pre></html>
            ]]>
        </item>
        <!--how is exception handling implemented-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>- try:</strong>&nbsp;Contains a block of code for which an exception will be checked.</p>
<p><strong>- catch:</strong>&nbsp;It is a program that catches an exception with the help of exception handler.</p>
<p><strong>- finally:</strong>&nbsp;It is a block of code written to execute regardless whether an exception is caught or not.</p>
<p><strong>- Throw:</strong>&nbsp;Throws an exception when a problem occurs.</p>
            </pre></html>
            ]]>
        </item>
        <!--what are c# i/o classes? what are the commonly used-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>C# has System.IO namespace, consisting of classes that are used to perform various operations on files like creating, deleting, opening, closing etc.</p>
<p><strong>Some commonly used I/O classes are:</strong></p>
<p><strong>- File:&nbsp;</strong>Helps in manipulating a file.</p>
<p><strong>- StreamWriter:</strong>&nbsp;Used for writing characters to a stream.</p>
<p><strong>- StreamReader:</strong>&nbsp;Used for reading characters to a stream.</p>
<p><strong>- StringWriter:</strong>&nbsp;Used for reading a string buffer.</p>
<p><strong>- StringReader:</strong>&nbsp;Used for writing a string buffer.</p>
<p><strong>- Path:</strong>&nbsp;Used for performing operations related to path information.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is streamreader / streamwriter-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>StreamReader and StreamWriter</strong>&nbsp;are classes of namespace System.IO. They are used when we want to read or write charact90, Reader-based data, respectively.</p>
<p><strong>Some of the members of StreamReader are:</strong>&nbsp;Close(), Read(), Readline().</p>
<p><strong>Members of StreamWriter are:</strong>&nbsp;Close(), Write(), Writeline().</p>

<em>Class Program1</em>
<em><br>{</em>
<em><br>using(StreamReader sr = new StreamReader(&ldquo;C:\ReadMe.txt&rdquo;)</em>
<em><br>{</em>
<em><br>//----------------code to read-------------------//</em>
<em><br>}</em>
<br>
<em><br>using(StreamWriter sw = new StreamWriter(&ldquo;C:\ReadMe.txt&rdquo;))</em>
<em><br>{</em>
<em><br>//-------------code to write-------------------//</em>
<em><br>}}</em>

            </pre></html>
            ]]>
        </item>
        <!--what is a destructor-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A&nbsp;<strong>Destructor</strong>&nbsp;is used to clean up the memory and free the resources. But in C# this is done by the garbage collector on its own. <em>System.GC.Collect()</em> is called internally for cleaning up. But sometimes it may be necessary to implement destructors manually.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is the difference between finally and finalize-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong><em>finally</strong></em>&nbsp;block&nbsp;is called after the execution of try and catch block. It is used for exception handling. Regardless of whether an exception is caught or not, this block of code will be executed. Usually, this block will have clean-up code.</p>
<p><strong>finalize</strong> method is called just before garbage collection. It is used to perform clean up operations of Unmanaged code. It is automatically called when a given instance is not subsequently called.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is the difference between continue and break-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Break</strong> statement breaks the loop. It makes the control of the program to exit the loop.&nbsp;<strong>Continue statement</strong>&nbsp;makes the control of the program to exit only the current iteration. It does not break the loop.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is a delegate-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A&nbsp;<strong>Delegate</strong>&nbsp;is a variable that holds the reference to a method. Hence it is a function pointer of reference type. All Delegates are derived from System.Delegate namespace. Both Delegate and the method that it refers to can have the same signature.</p>
<p>Declaring a delegate:&nbsp;<em>public delegate void AddNumbers(int n);</em></p>
<p>After the declaration of a delegate, the object must be created of the delegate using the new keyword.</p>
<p><em>AddNumbers an1 = new AddNumbers(number);</em></p>
<p>The delegate provides a kind of encapsulation to the reference method, which will internally get called when a delegate is called.</p>

<p><em>public delegate int myDel(int number); </em><br /><em>public class Program{</em> <br /><em> public int AddNumbers(int a) </em> <br /><em>{ </em> <br /><em>int Sum = a + 10; </em> <br /><em>return Sum; </em> <br /><em>} </em> <br /><br /><em>public void Start() </em> <br /><em>{ </em> <br /><em>myDel DelegateExample = AddNumbers; </em> <br /><em>}} </em></p>

<p>In the above example, we have a delegate myDel which takes an integer value as a parameter. Class Program has a method of the same signature as the delegate, called AddNumbers().</p>
<p>If there is another method called Start() which creates an object of the delegate, then the object can be assigned to AddNumbers as it has the same signature as that of the delegate.</p>
            </pre></html>
            ]]>
        </item>
        <!--what are events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Events</strong>&nbsp;are user actions that generate notifications to the application to which it must respond. The user actions can be mouse movements, keypress and so on.</p>
<p>Programmatically, a class that raises an event is called a publisher and a class which responds/receives the event is called a subscriber. An Event should have at least one subscriber else that event is never raised.</p>
<p>Delegates are used to declare Events.</p>
    <p><em>Public delegate void PrintNumbers();</em><br/>
<em>Event PrintNumbers myEvent;</em></p>
            </pre></html>
            ]]>
        </item>
        <!--how to use delegates with events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Delegates are used to raise events and handle them. Always a delegate needs to be declared first and then the Events are declared.</p>
<p><strong>Example:</strong></p>
<p>Consider a class called Patient. Consider two other classes, Insurance, and Bank which requires Death information of the Patient from patient class. Here, Insurance and Bank are the subscribers and the Patient class becomes the Publisher. It triggers the death event and the other two classes should receive the event.</p>

<p><em>namespace ConsoleApp2</em> <em><br />{</em> <em><br />public class Patient</em> <em><br />{</em> <em><br />public delegate void deathInfo();//Declaring a Delegate//</em> <em><br />public event deathInfo deathDate;//Declaring the event//</em> <em><br />public void Death()</em> <em><br />{</em> <em><br />deathDate();</em> <em><br />}</em> <em><br />}</em> <em><br />public class Insurance</em> <em><br />{</em> <em><br />Patient myPat = new Patient();</em> <em><br />void GetDeathDetails()</em> <em><br />{</em> <em><br />//-------Do Something with the deathDate event------------//</em> <em><br />}</em> <em><br />void Main()</em> <em><br />{</em> <em><br />//--------Subscribe the function GetDeathDetails----------//</em> <em><br />myPat.deathDate += GetDeathDetails;</em> <em><br />}</em> <em><br />}</em> <em><br />public class Bank</em> <em><br />{</em> <em><br />Patient myPat = new Patient();</em> <em><br />void GetPatInfo ()</em> <em><br />{</em> <em><br />//-------Do Something with the deathDate event------------//</em> <em><br />}</em> <em><br />void Main()</em> <em><br />{</em> <em><br />//--------Subscribe the function GetPatInfo ----------//</em> <em><br />myPat.deathDate += GetPatInfo;</em> <em><br />}</em> <em><br />}</em> <em><br />}</em></p>
            </pre></html>
            ]]>
        </item>
        <!--explain publishers and subscribers in events-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>A Publisher</strong>&nbsp;is a class responsible for publishing a message of different types of other classes. The message is nothing but Event as discussed in the above questions.</p>
<p>From the&nbsp;<strong>Example</strong>&nbsp;in Question 26, Class Patient is the Publisher class. It is generating an Event&nbsp;<em>deathEvent</em>, which the other classes receive.</p>
<p><strong>Subscribers</strong>&nbsp;capture the message of the type that it is interested in. Again, from the&nbsp;<strong>Example</strong>&nbsp;of Question 26, Class Insurance and Bank are Subscribers. They are interested in event&nbsp;<em>deathEvent</em>&nbsp;of type&nbsp;<em>void</em>.</p>
            </pre></html>
            ]]>
        </item>
        <!--what are synchronous and asynchronous operations-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Synchronization</strong> is a way to create a thread-safe code where only one thread can access the resource at any given time.</p>
<p><strong>Asynchronous call</strong> waits for the method to complete before continuing with the program flow. Synchronous programming badly affects the UI operations, when the user tries to perform time-consuming operations since only one thread will be used.</p>
<p>In Asynchronous operation, the method call will immediately return so that the program can perform other operations while the called method completes its work in certain situations.</p>
<p>In C#, <strong>Async</strong> and <strong>Await</strong> keywords are used to achieve asynchronous programming. Look at&nbsp;<strong>Question 33</strong>&nbsp;for more details on synchronous programming.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is reflection-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Reflection is the ability of a code to access the metadata of the assembly during runtime. A program reflects upon itself and uses the metadata to inform the user or modify its behavior. Metadata refers to information about objects, methods.</p>
<p>The namespace System.Reflection contains methods and classes that manage the information of all the loaded types and methods. It is mainly used for windows applications, for&nbsp;<strong>Example</strong>, to view the properties of a button in a windows form.</p>
<p>The MemberInfo object of the class reflection is used to discover the attributes associated with a class.</p>
<p>Reflection is implemented in two steps, first, we get the type of the object, and then we use the type to identify members such as methods and properties.</p>
<p>To get type of a class, we can simply use</p>
<p><em>Type mytype = myClass.GetType();</em></p>
<p>Once we have a type of class, the other information of the class can be easily accessed.</p>
<p><em>System.Reflection.MemberInfo Info =&nbsp;mytype.GetMethod(&ldquo;AddNumbers&rdquo;);</em></p>
<p>Above statement tries to find a method with name&nbsp;<em>AddNumbers</em>&nbsp;in the class&nbsp;<em>myClass</em>.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is a generic class-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            Generics or Generic class is used to create classes or objects which do not have any specific data type. The data type can be assigned during runtime, i.e when it is used in the program.

            <p><em>using System;</em><br /><em>using System.Collections.Generic;</em></p>
<p><em>namespace GenericApplication {</em><br /><em>public class MyGenericArray&lt;T&gt; {</em><br /><em>private T[] array;</em></p>
<p><em>public MyGenericArray(int size) {</em><br /><em>array = new T[size + 1];</em><br /><em>}</em><br /><em>public T getItem(int index) {</em><br /><em>return array[index];</em><br /><em>}</em><br /><em>public void setItem(int index, T value) {</em><br /><em>array[index] = value;</em><br /><em>}</em><br /><em>}</em></p>
<p><br /><em>class Tester {</em><br /><em>static void Main(string[] args) {</em></p>
<p><em>//declaring an int array</em><br /><em>MyGenericArray&lt;int&gt; intArray = new MyGenericArray&lt;int&gt;(5);</em></p>
<p><em>//setting values</em><br /><em>for (int c = 0; c &lt; 5; c++) {</em><br /><em>intArray.setItem(c, c*5);</em><br /><em>}</em></p>
<p><em>//retrieving the values</em><br /><em>for (int c = 0; c &lt; 5; c++) {</em><br /><em>Console.Write(intArray.getItem(c) + " ");</em><br /><em>}</em></p>
<p><em>Console.WriteLine();</em></p>
<p><em>//declaring a character array</em><br /><em>MyGenericArray&lt;char&gt; charArray = new MyGenericArray&lt;char&gt;(5);</em></p>
<p><em>//setting values</em><br /><em>for (int c = 0; c &lt; 5; c++) {</em><br /><em>charArray.setItem(c, (char)(c+97));</em><br /><em>}</em></p>
<p><em>//retrieving the values</em><br /><em>for (int c = 0; c&lt; 5; c++) {</em><br /><em>Console.Write(charArray.getItem(c) + " ");</em><br /><em>}</em><br /><em>Console.WriteLine();</em><br /><em>Console.ReadKey();</em><br /><em>}</em><em>}</em><em>}</em></p>
            </pre></html>
            ]]>
        </item>
        <!--explain get and set accessor properties?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">

            <p class="">- Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.</p>
<p class="">- A <em><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/get" data-linktype="relative-path">get</a></em> property accessor is used to return the property value, and a <em><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/set" data-linktype="relative-path">set</a></em> property accessor is used to assign a new value. These accessors can have different access levels. For more information, see <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/restricting-accessor-accessibility" data-linktype="relative-path">Restricting Accessor Accessibility</a>.</p>
<p class="">- The <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/value" data-linktype="relative-path">value</a> keyword is used to define the value being assigned by the <code>set</code> accessor.</p>
<p class="">- Properties can be <em>read-write</em> (they have both a <em><code>get</code></em> and a <em><code>set</code></em> accessor), <em>read-only</em> (they have a <code><em>get</em> </code>accessor but no <em><code>set</code></em> accessor), or <em>write-only</em> (they have a <em><code>set</code></em> accessor, but no <em><code>get</code></em> accessor). Write-only properties are rare and are most commonly used to restrict access to sensitive data.</p>
<p class="">- Simple properties that require no custom accessor code can be implemented either as expression body definitions or as <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/auto-implemented-properties" data-linktype="relative-path">auto-implemented properties</a>.</p>
<p class=""><strong>Properties with backing fields</strong></p>
<p class="">One basic pattern for implementing a property involves using a private backing field for setting and retrieving the property value. The <em><code>get</code></em> accessor returns the value of the private field, and the <em><code>set</code></em> accessor may perform some data validation before assigning a value to the private field. Both accessors may also perform some conversion or computation on the data before it is stored or returned.</p>
<p class="">The following example illustrates this pattern. In this example, the <code>TimePeriod</code> class represents an interval of time. Internally, the class stores the time interval in seconds in a private field named <code>_seconds</code>. A read-write property named <code>Hours</code> allows the customer to specify the time interval in hours. Both the <code>get</code> and the <code>set</code>accessors perform the necessary conversion between hours and seconds. In addition, the <code>set</code> accessor validates the data and throws an <a class="xref" href="https://docs.microsoft.com/en-us/dotnet/api/system.argumentoutofrangeexception" data-linktype="absolute-path">ArgumentOutOfRangeException</a> if the number of hours is invalid.</p>
<p class=""><strong>Example</strong>:</p>
<p><em>using System;</em></p>
<p><em>class TimePeriod</em><br /><em>{</em><br /><em>private double _seconds;</em></p>
<p><em>public double Hours</em><br /><em>{</em><br /><em>get { return _seconds / 3600; }</em><br /><em>set { </em><br /><em>if (value &lt; 0 || value &gt; 24)</em><br /><em>throw new ArgumentOutOfRangeException(</em><br /><em>$"{nameof(value)} must be between 0 and 24.");</em></p>
<p><em>_seconds = value * 3600; </em><br /><em>}</em><br /><em>}</em><br /><em>}</em></p>
<p><em>class Program</em><br /><em>{</em><br /><em>static void Main()</em><br /><em>{</em><br /><em>TimePeriod t = new TimePeriod();</em><br /><em>// The property assignment causes the \'set\' accessor to be called.</em><br /><em>t.Hours = 24;</em></p>
<p><em>// Retrieving the property causes the \'get\' accessor to be called.</em><br /><em>Console.WriteLine($"Time in hours: {t.Hours}");</em><br /><em>}</em><br /><em>}</em></p>
<p><br /><em>// The example displays the following output:</em><br /><em>// Time in hours: 24</em></p>
<p class=""><strong>Auto-Implemented Properties</strong></p>
<p class="">In some cases, property <em><code>get</code></em> and <em><code>set</code></em> accessors just assign a value to or retrieve a value from a backing field without including any additional logic. By using auto-implemented properties, you can simplify your code while having the C# compiler transparently provide the backing field for you.</p>
<p class="">If a property has both a <em><code>get</code></em> and a <em><code>set</code></em> accessor, both must be auto-implemented. You define an auto-implemented property by using the <em><code>get</code></em> and <em><code>set</code></em> keywords without providing any implementation.</p>
<p class=""><strong>Example</strong>:</p>
<p><em>using System;</em></p>
<p><em>public class SaleItem </em><br /><em>{</em><br /><em>public string Name </em><br /><em>{ get; set; } </em><br /><br /><em>public decimal Price </em><br /><em>{ get; set; } </em><br /><em>}</em></p>
<p><em>class Program</em><br /><em>{ </em><br /><em>static void Main(string[] args)</em><br /><em>{</em><br /><em>var item = new SaleItem{ Name = "Shoes", Price = 19.95m }; </em><br /><em>Console.WriteLine($"{item.Name}: sells for {item.Price:C2}"); </em><br /><em>} }</em></p>
<p><em>// The example displays output like the following: // Shoes: sells for $19.95</em></p>
            </pre></html>
            ]]>
        </item>
        <!--What are async and await-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Async and Await keywords are used to create asynchronous methods in C.</p>
<p>Asynchronous programming means that the process runs independently of main or other processes.</p>
<p>- Async keyword is used for the method declaration.</p>
<p>- The count is of a task of type int which calls the method CalculateCount().</p>
<p>- Calculatecount() starts execution and calculates something.</p>
<p>- Independent work is done on my thread and then await count statement is reached.</p>
<p>- If the Calculatecount is not finished, myMethod will return to its calling method, thus the main thread doesn\'t get blocked.</p>
<p>- If the Calculatecount is already finished, then we have the result available when the control reaches await count. So the next step will continue in the same thread. However, it is not the situation in the above case where Delay of 1 second is involved.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is a race condition-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A&nbsp;<strong>Race condition</strong>&nbsp;occurs when two threads access the same resource and are trying to change it at the same time. The thread which will be able to access the resource first cannot be predicted.</p>
<p>If we have two threads, T1 and T2, and they are trying to access a shared resource called X. And if both the threads try to write a value to X, the last value written to X will be saved.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is thread pooling-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A&nbsp;<strong>Thread pool</strong>&nbsp;is a collection of threads. These threads can be used to perform tasks without disturbing the primary thread. Once the thread completes the task, the thread returns to the pool.</p>
<p>System.Threading.ThreadPool namespace has classes which manage the threads in the pool and its operations.</p>
<pre><em>System.Threading.ThreadPool.QueueUserWorkItem(new System.Threading.WaitCallback(SomeTask));</em></pre>
<p>The above line queues a task. SomeTask methods should have a parameter of type Object.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is serialization?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>Serialization</strong>&nbsp;is a process of converting a code to its binary format. Once it is converted to bytes, it can be easily stored and written to a disk or any such storage devices. Serializations are mainly useful when we do not want to lose the original form of the code and it can be retrieved anytime in the future.</p>
<p>Any class which is marked with the attribute [Serializable] will be converted to its binary form.</p>
<p>The reverse process of getting the c# code back from the binary form is called&nbsp;<strong>Deserialization</strong>.</p>
<p>To Serialize an object we need the object to be serialized, a stream which can contain the serialized object and namespace System.Runtime.Serialization can contain classes for serialization.</p>
            </pre></html>
            ]]>
        </item>
        <!--What is an xsd file?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>An <strong>XSD</strong> file stands for XML Schema Definition. It gives a structure for the XML file. It means it decides the elements that the XML should have and in what order and what properties should be present. Without an XSD file associated with XML, the XML can have any tags, any attributes, and any elements.</p>
<p><strong>Xsd.exe</strong> tool converts the files to XSD format. During Serialization of C# code, the classes are converted to XSD compliant format by xsd.exe.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is the difference between ref and out -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p>In C Sharp (C#) we can have three types of parameters in a function. The parameters can be in parameter (which is not returned back to the caller of the function), out parameter and ref parameter. We have lots of differences in both of them.</p>
<p>Output parameters are similar to reference parameters, except that they transfer data out of the method rather than into it. Reference parameter copies the reference to the memory location of an argument into the formal parameter. This means that changes made to the parameter affect the argument.</p>
            </pre></html>
            ]]>
        </item>
        <!--can this be used within a static method-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <p>We can\'t use this in static method because keyword \'this\' returns a reference to the current instance of the class containing it. Static methods (or any static member) do not belong to a particular instance. They exist without creating an instance of the class and call with the name of a class not by instance so we can\'t use this keyword in the body of static Methods, but in case of Extension Methods we can use it the functions parameters. Let\'s have a look on \"this\" keyword.<br /><br />The \"<strong>this</strong>\" keyword is a special type of reference variable that is implicitly defined within each constructor and non-static method as a first parameter of the type class in which it is defined. For example, consider the following class written in C#.</p>
            </pre></html>
            ]]>
        </item>
        <!--define property -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Properties are members that provide a flexible mechanism to read, write or compute the values of private fields, in other words by the property we can access private fields. In other words we can say that a property is a return type function/method with one parameter or without a parameter. These are always public data members. It uses methods to access and assign values to private fields called accessors.<br /><br />Now question is what are accessors?<br /><br />The get and set portions or blocks of a property are called accessors. These are useful to restrict the accessibility of a property, the set accessor specifies that we can assign a value to a private field in a property and without the set accessor property it is like a read-only field. By the get accessor we can access the value of the private field, in other words it returns a single value. A Get accessor specifies that we can access the value of a field publically.<br /><br />We have the three types of properties&nbsp;</p>
<p>- Read/Write.</p>
<p>- ReadOnly.</p>
<p>- WriteOnly.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is the difference between string and stringbuilder-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>StringBuilder and string both use to store string value but both have many differences on the bases of instance creation and also for performance:<br /><br /><strong>String:&nbsp;</strong><br /><br />String is an immutable object. Immutable like when we create string object in code so we cannot modify or change that object in any operations like insert new value, replace or append any value with existing value in string object, when we have to do some operations to change string simply it will dispose the old value of string object and it will create new instance in memory for hold the new value in string object.</p>
<p><strong>Note:</strong></p>
<p>- It\'s an immutable object that hold string value.<br /><br /></p>
<p>- Performance wise string is slow because its\' create a new instance to override or change the previous value.<br /><br /></p>
<p>- String belongs to System namespace.</p>
<p><strong>StringBuilder:<br /><br /></strong>System.Text.Stringbuilder is mutable object which also hold the string value, mutable means once we create a System.Text.Stringbuilder object we can use this object for any operation like insert value in existing string with insert functions also replace or append without creating new instance of System.Text.Stringbuilder for every time so it\'s use the previous object so it\'s work fast as compare than System.String.</p>
<p><strong>Note:</strong></p>
<p>- StringBuilder is a mutable object.</p>
<p>- Performance wise StringBuilder is very fast because it will use same instance of StringBuilder object to perform any operation like insert value in existing string.</p>
<p>- StringBuilder belongs to System.Text.Stringbuilder namespace.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is ienumerable<>-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p><strong>IEnumerable</strong> is the parent interface for all non-generic collections in System.Collections namespace like ArrayList, HastTable etc. that can be enumerated. For the generic version of this interface as IEnumerable&lt;T&gt; which a parent interface of all generic collections class in System.Collections.Generic namespace like List&lt;&gt; and more.&nbsp;<br /><br />In System.Collections.Generic.IEnumerable&lt;T&gt; have only a single method which is GetEnumerator() that returns an IEnumerator. IEnumerator provides the power to iterate through the collection by exposing a Current property and Move Next and Reset methods, if we don\'t have this interface as a parent so we can\'t use iteration by foreach loop or can\'t use that class object in our LINQ query.</p>
<p>&nbsp;</p>
            </pre></html>
            ]]>
        </item>
        <!--what are the differences between ienumerable and iqueryable-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p><strong>IEnumerable:</strong><br /><br />Is the parent interface for all non-generic collections in System.Collections namespace like ArrayList, HastTable etc. that can be enumerated. For the generic version of this interface as IEnumerable&lt;T&gt; which a parent interface of all generic collections class in System.Collections.Generic namespace like List&lt;&gt; and more.&nbsp;<br /><br /><strong>IQueryable:<br /></strong><br />As per MSDN IQueryable interface is intended for implementation by query providers. It is only supposed to be implemented by providers that also implement IQueryable&lt;T&gt;. If the provider does not also implement IQueryable&lt;T&gt;, the standard query operators cannot be used on the provider\'s data source.<br /><br />The IQueryable interface inherits the IEnumerable interface so that if it represents a query, the results of that query can be enumerated. Enumeration causes the expression tree associated with an IQueryable object to be executed. The definition of "executing an expression tree" is specific to a query provider. For example, it may involve translating the expression tree to an appropriate query language for the underlying data source. Queries that do not return enumerable results are executed when the Execute method is called.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is the difference between late binding and early binding-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
<p>Early Binding and Late Binding concepts belongs to polymorphism so let\'s see first about polymorphism:<br /><br />Polymorphism is an ability to take more than one form of a function means with a same name we can write multiple functions code in a same class or any derived class.<br /><br />Polymorphism we have 2 different types to achieve that:&nbsp;</p>
<p>- Compile Time also known as Early Binding or Overloading.</p>
<p>- Run Time also known as Late Binding or Overriding.</p>
<p><strong>Compile Time Polymorphism or Early Binding:</strong></p>
<p>In Compile time polymorphism or Early Binding we will use multiple methods with same name but different type of parameter or may be the number or parameter because of this we can perform different-different tasks with same method name in the same class which is also known as Method overloading.</p>

<div>&nbsp;</div>
<div><strong>Run Time Polymorphism or Late Binding:</strong></div>
<div>Run time polymorphism also known as late binding, in Run Time polymorphism or Late Binding we can do use same method names with same signatures means same type or same number of parameters but not in same class because compiler doesn\'t allowed that at compile time so we can use in derived class that bind at run time when a child class or derived class object will instantiated that\'s way we says that Late Binding. For that we have to create my parent class functions as partial and in driver or child class as override functions with override keyword.</div>
<div>&nbsp;</div>
            </pre></html>
            ]]>
        </item>
        <!--what is the constructor chaining-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Constructor chaining is a way to connect two or more classes in a relationship as Inheritance, in Constructor Chaining every child class constructor is mapped to parent class Constructor implicitly by base keyword so when you create an instance of child class to it\'ll call parent\'s class Constructor without it inheritance is not possible.</p>
            </pre></html>
            ]]>
        </item>
        <!--can multiple catch blocs executed-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>We can use multiple Catches block with every try but when any Exceptions is thrown by debugger so every catches match this exception type with their signature and catch the exception by any single catch block so that means we can use multiple catches blocks but only one can executed at once like:&nbsp;</p>
<div class="dp-highlighter">
<p><em><span class="keyword">using</span>&nbsp;System;&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">class</span>&nbsp;MyClient&nbsp;{&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">void</span>&nbsp;Main()&nbsp;{&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">int</span>&nbsp;x&nbsp;=&nbsp;0;&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">int</span>&nbsp;div&nbsp;=&nbsp;0;&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">try</span>&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>div&nbsp;=&nbsp;100&nbsp;/&nbsp;x;&nbsp;&nbsp;</em></p>
<p><em>&nbsp;Console.WriteLine(<span class="string">"Not&nbsp;executed&nbsp;line"</span>);&nbsp;&nbsp;</em></p>
<p><em>}&nbsp;<span class="keyword">catch</span>&nbsp;(DivideByZeroException&nbsp;de)&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"DivideByZeroException"</span>);&nbsp;&nbsp;</em></p>
<p><em>}&nbsp;<span class="keyword">catch</span>&nbsp;(Exception&nbsp;ee)&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"Exception"</span>);&nbsp;&nbsp;</em></p>
<p><em>}&nbsp;<span class="keyword">finally</span>&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;Console.WriteLine(<span class="string">"Finally&nbsp;Block"</span>);&nbsp;&nbsp;</em></p>
<p><em>}&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"Result&nbsp;is&nbsp;{0}"</span>,&nbsp;div);&nbsp;&nbsp;</em></p>
<p><em>&nbsp;}&nbsp;&nbsp;} &nbsp;</em></p>
</div>
            </pre></html>
            ]]>
        </item>
        <!--what are indexer-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Indexer allows classes to be used in more intuitive manner. C# introduces a new concept known as Indexers which are used for treating an object as an array. The indexers are usually known as smart arrays in C#. They are not essential part of object-oriented programming.<br /><br />An indexer, also called an indexed property, is a class property that allows you to access a member variable of a class using the features of an array.<br /><br />Defining an indexer allows you to create classes that act like virtual arrays. Instances of that class can be accessed using the [] array access operator.<br /><br /><strong>Example:</strong></p>
<div class="dp-highlighter">
<p><em>public&nbsp;</em></p>
<p><em>int &gt;&nbsp;<span class="keyword">this</span>[argument&nbsp;list]&nbsp;{&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">&nbsp; &nbsp; &nbsp; get</span>&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;<span class="comment">//&nbsp;your&nbsp;get&nbsp;block&nbsp;code</span>&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">set</span>&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;your&nbsp;set&nbsp;block&nbsp;code</span>&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</em></p>
<p><em>} &nbsp;</em></p>
</div>
            </pre></html>
            ]]>
        </item>
        <!--difference between is and as operator -->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p><strong>"is" operator<br /></strong><br />In the C# language, we use the "is" operator to check the object type. If the two objects are of the same type, it returns true and false if not.<br /><br /><strong>Example</strong>:</p>
<p>We defined the following two classes:</p>
<div class="dp-highlighter">
<p><em><span class="keyword">class</span>&nbsp;Speaker&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">string</span>&nbsp;Name&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">get</span>;&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">set</span>;&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</em></p>
<p><em>}&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">class</span>&nbsp;Author&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;<span class="keyword">string</span>&nbsp;Name&nbsp;{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">get</span>;&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">set</span>;&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;</em></p>
<p><em>} &nbsp;</em></p>
</div>
<p>Now, let\'s try to check the preceding types as:</p>
<div class="dp-highlighter">
<p><em>var&nbsp;speaker&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Speaker&nbsp;{&nbsp;Name=<span class="string">"Gaurav&nbsp;Kumar&nbsp;Arora"</span>}; &nbsp;</em></p>
</div>
<p>We declared an object of Speaker as in the following:</p>
<div class="dp-highlighter">
<p><em>var&nbsp;isTrue&nbsp;=&nbsp;speaker&nbsp;<span class="keyword">is</span>&nbsp;Speaker; &nbsp;&nbsp;</em></p>
</div>
<p>In the preceding, we are just checking the matching type. Yes, our speaker is an object of Speaker type.</p>
<div class="dp-highlighter">
<p><em>Console.WriteLine(<span class="string">"speaker&nbsp;is&nbsp;of&nbsp;Speaker&nbsp;type:{0}"</span>,&nbsp;isTrue); &nbsp;&nbsp;</em></p>
</div>
<p>So, the results as true.<br /><br />But, here we get false:</p>
<div class="dp-highlighter">
<p><em>var&nbsp;author&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Author&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span class="string">"Gaurav&nbsp;Kumar&nbsp;Arora"</span>&nbsp;};&nbsp;&nbsp;&nbsp;</em></p>
<p><em>var&nbsp;isTrue&nbsp;=&nbsp;speaker&nbsp;<span class="keyword">is</span>&nbsp;Author;&nbsp;&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"speaker&nbsp;is&nbsp;of&nbsp;Author&nbsp;type:{0}"</span>,&nbsp;isTrue); &nbsp;</em></p>
</div>
<p>Because our our speaker is not an object of Author type.<br /><br /><strong>"as" operator:</strong></p>
<div>The "as" operator behaves similar to the "is" operator. The only difference is it returns the object if both are compatible to that type else it returns null.</div>
<div><strong>Example</strong>:</div>
<p>Let\'s understand the preceding with a small snippet as in the following:</p>
<div class="dp-highlighter">
<p><em><span class="keyword">public</span>&nbsp;<span class="keyword">static</span>&nbsp;<span class="keyword">string</span>&nbsp;GetAuthorName(dynamic&nbsp;obj)&nbsp;&nbsp;&nbsp;</em></p>
<p><em>{&nbsp;&nbsp;&nbsp;</em></p>
<p><em>Author&nbsp;authorObj&nbsp;=&nbsp;obj&nbsp;<span class="keyword">as</span>&nbsp;Author;&nbsp;&nbsp;&nbsp;</em></p>
<p><em><span class="keyword">return</span>&nbsp;(authorObj&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;?&nbsp;authorObj.Name&nbsp;:&nbsp;<span class="keyword">string</span>.Empty;&nbsp;&nbsp;&nbsp;</em></p>
<p><em>} &nbsp;</em>&nbsp;</p>
</div>
<p>We have a method that accepts dynamic objects and returns the object name property if the object is of the Author type.&nbsp;<br /><br /><strong>Here, we declared two objects:</strong></p>
<div class="dp-highlighter">
<p><em>var&nbsp;speaker&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Speaker&nbsp;{&nbsp;Name=<span class="string">"Gaurav&nbsp;Kumar&nbsp;Arora"</span>};&nbsp;&nbsp;&nbsp;</em></p>
<p><em>var&nbsp;author&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;Author&nbsp;{&nbsp;Name&nbsp;=&nbsp;<span class="string">"Gaurav&nbsp;Kumar&nbsp;Arora"</span>&nbsp;}; &nbsp;&nbsp;</em></p>
</div>
<p><strong>The following returns the "Name" property:</strong></p>
<div class="dp-highlighter">
<p><em>var&nbsp;authorName&nbsp;=&nbsp;GetAuthorName(author);&nbsp;&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"Author&nbsp;name&nbsp;is:{0}"</span>,&nbsp;authorName);&nbsp;&nbsp;&nbsp;</em></p>
</div>
<p><strong>It returns an empty string:</strong></p>
<div class="dp-highlighter">
<p><em>authorName&nbsp;=&nbsp;GetAuthorName(speaker);&nbsp;&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"Author&nbsp;name&nbsp;is:{0}"</span>,&nbsp;authorName); &nbsp;</em></p>
</div>
            </pre></html>
            ]]>
        </item>
        <!--how to use nullable types-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>A nullable Type is a data type is that contain the defined data type or the value of null.<br /><br />You should note here that here variable datatype has been given and then only it can be used.<br /><br />This nullable type concept is not comaptible with "var".<br /><br />I will explain this with syntax in next section.<br /><br /><strong>Declaration:</strong></p>
<div>Any DataType can be declared nullable type with the help of operator "?".</div>
<p>Example of the syntax is as Follows :-</p>
<div class="dp-highlighter">
<p><em><span class="keyword">int</span>?&nbsp;i&nbsp;=&nbsp;<span class="keyword">null</span>; &nbsp;</em></p>
</div>
<p>As discussed in previous section "var" is not compatible with this Nullable Type.&nbsp;<br /><br />So we will have Compile Time error if we are declaring something like: -</p>
<div class="dp-highlighter">
<p><em>var?&nbsp;i&nbsp;=&nbsp;<span class="keyword">null</span>; &nbsp;</em></p>
</div>
<p>though following syntax is completely fine :-&nbsp;</p>
<div class="dp-highlighter">
<p><em>var&nbsp;i&nbsp;=&nbsp;4;&nbsp;</em></p>
</div>
            </pre></html>
            ]]>
        </item>
        <!--what is an object pooling?-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
                <p>Object Pooling is something that tries to keep a pool of objects in memory to be re-used later and hence it will reduce the load of object creation to a great extent. This article will try to explain this in detail. The example is for an Employee object, but you can make it general by using Object base class.<br /><br /><strong>What does it mean?</strong><br /><br />Object Pool is nothing but a container of objects that are ready for use. Whenever there is a request for a new object, the pool manager will take the request and it will be served by allocating an object from the pool.<br /><br /><strong>How it works?</strong><br /><br />We are going to use Factory pattern for this purpose. We will have a factory method, which will take care about the creation of objects. Whenever there is a request for a new object, the factory method will look into the object pool (we use Queue object). If there is any object available within the allowed limit, it will return the object (value object), otherwise a new object will be created and give you back.</p>
            </pre></html>
            ]]>
        </item>
        <!--what are the difference between array and arraylist and list-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>They are different object types. They have different capabilities and store their data in different ways.</p>
<p>An Array (<code>System.Array</code>) is fixed in size once it is allocated. You can\'t add items to it or remove items from it. Also, all the elements must be the same type. As a result, it is type safe, and is also the most efficient of the three, both in terms of memory and performance. Also, System.Array supports multiple dimensions (i.e. it has a&nbsp;<a href="https://msdn.microsoft.com/en-us/library/system.array.rank(v=vs.110).aspx">Rank</a>&nbsp;property) while List and ArrayList do not (although you can create a List of Lists or an ArrayList of ArrayLists, if you want to).</p>
<p>An&nbsp;<code>ArrayList</code>&nbsp;is a flexible array which contains a list of objects. You can add and remove items from it and it automatically deals with allocating space. If you store value types in it, they are boxed and unboxed, which can be a bit inefficient. Also, it is not type-safe.</p>
<p>A&nbsp;<code>List&lt;&gt;</code>&nbsp;leverages generics; it is essentially a type-safe version of ArrayList. This means there is no boxing or unboxing (which improves performance) and if you attempt to add an item of the wrong type it\'ll generate a compile-time error.</p>
            </pre></html>
            ]]>
        </item>
        <!--explain anonymous-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Anonymous types allow us to create new type without defining them. This is way to defining read only properties into a single object without having to define type explicitly. Here Type is generating by the compiler and it is accessible only for the current block of code. The type of properties is also inferred by the compiler.<br /><br />We can create anonymous types by using "new" keyword together with the object initializer.&nbsp;<br /><br /><strong>Example</strong>&nbsp;</p>
<div class="dp-highlighter">
<p><em>var&nbsp;anonymousData&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;&nbsp;&nbsp;</em></p>
<p><em>{&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;ForeName&nbsp;=&nbsp;<span class="string">"Jignesh"</span>,&nbsp;&nbsp;</em></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;SurName&nbsp;=&nbsp;<span class="string">"Trivedi"</span>&nbsp;&nbsp;</em></p>
<p><em>};&nbsp;&nbsp;</em></p>
<p><em>Console.WriteLine(<span class="string">"First&nbsp;Name&nbsp;:&nbsp;"</span>&nbsp;+&nbsp;anonymousData.ForeName); &nbsp;</em></p>
</div>
            </pre></html>
            ]]>
        </item>
        <!--what is linq-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>LINQ stands for Language Integrated Query. LINQ is a data querying methodology which provides querying capabilities to .NET languages with a syntax similar to a SQL query.<br /><br />LINQ has a great power of querying on any source of data. The data source could be collections of objects, database or XML files. We can easily retrieve data from any object that implements the IEnumerable&lt;T&gt; interface.</p>
<p>1. LINQ offers an object-based, language-integrated way to query over data no matter where that data came from. So through LINQ we can query database, XML as well as collections.&nbsp;</p>
<p><br />2. Compile time syntax checking.<br /><br /></p>
<p>3. It allows you to query collections like arrays, enumerable classes etc in the native language of your application, like VB or C# in much the same way as you would query a database using SQL.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is file handling-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>The System.IO namespace provides four classes that allow you to manipulate individual files, as well as interact with a machine directory structure. The Directory and File directly extends System.Object and supports the creation, copying, moving and deletion of files using various static methods. They only contain static methods and are never instantiated. The FileInfo and DirecotryInfo types are derived from the abstract class FileSystemInfo type and they are typically, employed for obtaining the full details of a file or directory because their members tend to return strongly typed objects. They implement roughly the same public methods as a Directory and a File but they are stateful and the members of these classes are not static.</p>
            </pre></html>
            ]]>
        </item>
        <!--can you name three ways to pass parameters to a method-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>There are three ways that parameters can be passed to a method &minus;</p>
<p><strong>- Value parameters:</strong>&nbsp;This method copies the actual value of an argument into the formal parameter of the function. In this case, changes made to the parameter inside the function have no effect on the argument.</p>
<p><strong>- Reference parameters:</strong>&nbsp;This method copies the reference to the memory location of an argument into the formal parameter. This means that changes made to the parameter affect the argument.</p>
<p><strong>- Output parameters:</strong>&nbsp;This method helps in returning more than one value.</p>
            </pre></html>
            ]]>
        </item>
        <!--what do the following acronyms in .net-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>IL, or Intermediate Language, is a CPU independent partially compiled code. IL code will be compiled to native machine code using current environmental properties by Just-In-Time compiler (JIT). JIT compiler translates the IL code to an assembly code and uses the CPU architecture of the target machine to execute a .NET application. In .NET, IL is called Common Intermediate Language (CIL), and in the early .NET days it was called Microsoft Intermediate Language (MSIL).</p>
<p>CLI, or Common Language Infrastructure, is an open specification developed by Microsoft. It is a compiled code library used for deployment, versioning, and security. In .NET there are two CLI types: process assemblies (EXE) and library assemblies (DLL). CLI assemblies contain code in CIL, and as mentioned, during compilation of CLI programming languages, the source code is translated into CIL code rather than into platform or processor specific object code.</p>
<p><strong>To summarize</strong>:</p>
<p>1. When compiled, source code is first translated to IL (in .NET, that is CIL, and previously called MSIL).</p>
<p>2. CIL is then assembled into a bytecode and a CLI assembly is created.</p>
<p>3. Before code execution, CLI code is passed through the runtime\'s JIT compiler to generate native machine code.</p>
<p>4. The computer\'s processor executes the native machine code.</p>
            </pre></html>
            ]]>
        </item>
        <!--discuss what garbage collection is and how it works.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>Garbage collection is a low-priority process that serves as an automatic memory manager which manages the allocation and release of memory for the applications. Each time a new object is created, the common language runtime allocates memory for that object from the managed Heap. As long as free memory space is available in the managed Heap, the runtime continues to allocate space for new objects. However, memory is not infinite, and once an application fills the Heap memory space, garbage collection comes into play to free some memory. When the garbage collector performs a collection, it checks for objects in the managed Heap that are no longer being used by the application and performs the necessary operations to reclaim the memory. Garbage collection will stop all running threads, it will find all objects in the Heap that are not being accessed by the main program and delete them. It will then reorganize all the objects left in the Heap to make space and adjust all the Pointers to these objects in both the Stack and the Heap.</p>
<p>To enforce garbage collection in your code manually, you can run the following command (written in C#):</p>
<pre><em><code>System.GC.Collect();</code></em></pre>
            </pre></html>
            ]]>
        </item>
        <!--you would know that system.object is the parent class of all.net classes.-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>System.Object provides the following important methods, among others:</p>
<p><em>1. <code>ToString</code></em>&mdash;Returns a string that represents the current object</p>
<p>2. both overrides of<em>&nbsp;<code>Equals(object)</code>,&nbsp;<code>Equals(object, object)</code></em></p>
<p><em>3. <code>GetHashCode</code></em></p>
<p><em>4. <code>Finalize</code></em></p>
<p><em>5. <code>GetType</code></em></p>
<p><em>6. <code>ReferenceEquals</code></em></p>
<p><em>7. <code>MemberwiseClone</code></em></p>
<p>Most of these methods provide the basic implementation required of any type that a developer will work with in the .NET stack.</p>

          </pre></html>
            ]]>
        </item>
        <!--what is .net web service-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
             <p>Web services are reusable components that allow developers to publish an application\'s function over the internet to make it accessible and directly interactable with other applications and objects online. Web services communicate by using standard web protocols and data formats &mdash; including HTTP, XML and SOAP &mdash; that allow them to connect across different platforms and programming languages. ASP.NET provides a simple way to develop web services. The .NET framework provides built-in classes for building and consuming web services.</p>
            </pre></html>
            ]]>
        </item>
        <!--what is json data and what is one way that .net developers-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <p>JSON (JavaScript Object Notation) provides developers with a way to organize and store data in a way that is easy to access and read. JSON is important for developers because it allows them to manipulate JSON feeds from other sites and to load them more quickly and easily than via SML/RSS feeds. Json.NET provides a way for .NET developers to define classes to parse objects and arrays from JSON text. You can also use Json.NET if you need to serialize value types into JSON text. Json.NET runs on .NET2, .NET3 and .NET4.</p>
            </pre></html>
            ]]>
        </item>


    </string-array>
</resources>