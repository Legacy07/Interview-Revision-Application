<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="graph_algorithms">
        <item>
            Representations of graphs
        </item>
        <item>
            Breadth-First Search
        </item>
        <item>
            Depth-First Search
        </item>
        <item>
            Topological Sort
        </item>
        <item>
            Strongly Connected Components
        </item>
        <item>
            Minimum Spanning Trees
        </item>
        <item>
            Greedy Algorithms
        </item>
        <item>
            Kruskal\'s Algorithm
        </item>
        <item>
            Prim\'s Algorithm
        </item>
        <item>
            Dijkstra\'s Algorithm
        </item>
        <item>
            The Floyd-Warshall Algorithm
        </item>
        <item>
            Flow Networks
        </item>
        <item>
            The Ford Fulkerson method
        </item>
        <!--<item>-->
            <!--Maximum Bipartite Matching-->
        <!--</item>-->
        <!--<item>-->
            <!--Push relabel Algorithm-->
        <!--</item>-->

    </string-array>
    <string-array name="graph_algorithms_answers">
        <!--Representations of graphs-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Graph is a data structure that consists of following two components:<br />1. A finite set of vertices also called as nodes.<br />2. A finite set of ordered pair of the form (u, v) called as edge.<br />The pair is ordered because (u, v) is not same as (v, u) in case of a directed graph(di-graph).<br />The pair of the form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.<br /><br />Graphs are used to represent many real-life applications: Graphs are used to represent networks.<br />The networks may include paths in a city or telephone network or circuit network.<br />Graphs are also used in social networks like linkedIn, Facebook.<br />For example, in Facebook, each person is represented with a vertex(or node).<br />Each node is a structure and contains information like person id, name, gender and locale.<br /><br />Following two are the most commonly used representations of a graph.<br />1. Adjacency Matrix<br />2. Adjacency List<br />There are other representations also like, Incidence Matrix and Incidence List.<br />The choice of the graph representation is situation specific. It totally depends on the type of operations to be performed and ease of use.<br /><br /><em>Adjacency Matrix</em>:<br />Adjacency Matrix is a 2D array of size V x V where V is the number of vertices in a graph.<br />Let the 2D array be adj[][], a slot adj[i][j] = 1 indicates that there is an edge from vertex i to vertex j.<br />Adjacency matrix for undirected graph is always symmetric. Adjacency Matrix is also used to represent weighted graphs.<br />If adj[i][j] = w, then there is an edge from vertex i to vertex j with weight w.<br /><br /><em>Adjacency List</em>:<br />An array of linked lists is used. Size of the array is equal to the number of vertices.<br />Let the array be array[]. An entry array[i] represents the linked list of vertices adjacent to the ith vertex.<br />This representation can also be used to represent a weighted graph. The weights of edges can be stored in nodes of linked lists.<br /><br /><strong>Example</strong>:<br /><em><br />// Java Program to demonstrate adjacency list</em><br /><em>// representation of graphs</em><br /><em>import java.util.LinkedList;</em><br /><br /><em>public class GFG</em><br /><em>{</em><br /><em>// A user define class to represent a graph.</em><br /><em>// A graph is an array of adjacency lists.</em><br /><em>// Size of array will be V (number of vertices</em><em> in graph)</em><br /><em>            <br />static class Graph</em><br /><em>{</em><br /><em>int V;</em><br /><em>LinkedList&lt;Integer&gt; adjListArray[];</em><br />            <br /><em>// constructor</em><br /><em>Graph(int V)</em><br /><em>{</em><br /><em>this.V = V;</em><br />            <br /><em>// define the size of array as</em><br /><em>// number of vertices</em><br /><em>adjListArray = new LinkedList[V];</em><br />            <br /><em>// Create a new list for each vertex</em><br /><em>// such that adjacent nodes can be stored</em><br /><em>for(int i = 0; i &lt; V ; i++){</em><br /><em>adjListArray[i] = new LinkedList&lt;&gt;();</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br />            <br /><em>// Adds an edge to an undirected graph</em><br /><em>static void addEdge(Graph graph, int src, int dest)</em><br /><em>{</em><br /><em>// Add an edge from src to dest.</em><br /><em>graph.adjListArray[src].addFirst(dest);</em><br />            <br /><em>// Since graph is undirected, add an edge from dest </em><em>to src also<br /></em><em>graph.adjListArray[dest].addFirst(src);</em><br /><em>}</em><br />            <br /><em>// A utility function to print the adjacency list </em><em>representation of graph</em><br /><em>static void printGraph(Graph graph)</em><br /><em>{</em><br /><em>for(int v = 0; v &lt; graph.V; v++)</em><br /><em>{</em><br /><em>System.out.println("Adjacency list of vertex "+ v);</em><br /><em>System.out.print("head");</em><br /><em>for(Integer pCrawl: graph.adjListArray[v]){</em><br /><em>System.out.print(" -&gt; "+pCrawl);</em><br /><em>}</em><br /><em>System.out.println("");</em><br /><em>}</em><br /><em>}</em><br />            <br /><em>// Driver program to test above functions</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>// create the graph given in above figure</em><br /><em>int V = 5;</em><br /><em>Graph graph = new Graph(V);</em><br /><em>addEdge(graph, 0, 1);</em><br /><em>addEdge(graph, 0, 4);</em><br /><em>addEdge(graph, 1, 2);</em><br /><em>addEdge(graph, 1, 3);</em><br /><em>addEdge(graph, 1, 4);</em><br /><em>addEdge(graph, 2, 3);</em><br /><em>addEdge(graph, 3, 4);</em><br />            <br /><em>// print the adjacency list representation of </em><em>the above graph</em><br /><em>printGraph(graph);</em><br /><em>}            </em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Adjacency list of vertex 0<br />head -&gt; 1-&gt; 4<br />            <br />Adjacency list of vertex 1<br />head -&gt; 0-&gt; 2-&gt; 3-&gt; 4<br />            <br />Adjacency list of vertex 2<br />head -&gt; 1-&gt; 3<br />            <br />Adjacency list of vertex 3<br />head -&gt; 1-&gt; 2-&gt; 4<br />            <br />Adjacency list of vertex 4<br />head -&gt; 0-&gt; 1-&gt; 3</pre>
            </pre></html>
            ]]>
        </item>
        <!--Breadth-First Search-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree.<br />The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again.<br />To avoid processing a node more than once, we use a boolean visited array.<br />For simplicity, it is assumed that all vertices are reachable from the starting vertex.<br /><br />Breadth-first search assigns two values to each vertex v:<br /><br />- A distance, giving the minimum number of edges in any path from the source vertex to vertex v.<br />- The predecessor vertex of v vv along some shortest path from the source vertex.<br />The source vertex\'s predecessor is some special value, such as null, indicating that it has no predecessor.<br /><br />In BFS, we initially set the distance and predecessor of each vertex to the special value (null).<br />We start the search at the source and assign it a distance of 0. Then we visit all the neighbors of the source and give each<br />neighbor a distance of 1 and set its predecessor to be the source. Then we visit all the neighbors of the vertices whose<br />distance is 1 and that have not been visited before, and we give each of these vertices a distance of 2 and set its predecessor<br />to be vertex from which we visited it. We keep going until all vertices reachable from the source vertex have been visited,<br />always visiting all vertices at distance k from the source before visiting any vertex at distance k+1, plus, 1.<br /><br /><strong>Example</strong>:<br /><br /><em>// Java program to print BFS traversal from a given source vertex.</em><br /><em>// BFS(int s) traverses vertices reachable from s.</em><br /><em>import java.io.*;</em><br /><em>import java.util.*;</em><br /><br /><em>// This class represents a directed graph using adjacency list</em><br /><em>// representation</em><br /><em>class Graph</em><br /><em>{</em><br /><em>private int V;   // No. of vertices</em><br /><em>private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists</em><br /><br /><em>// Constructor</em><br /><em>Graph(int v)</em><br /><em>{</em><br /><em>V = v;</em><br /><em>adj = new LinkedList[v];</em><br /><em>for (int i=0; i&lt;v; ++i)</em><br /><em>adj[i] = new LinkedList();</em><br /><em>}</em><br /><br /><em>// Function to add an edge into the graph</em><br /><em>void addEdge(int v,int w)</em><br /><em>{</em><br /><em>adj[v].add(w);</em><br /><em>}</em><br /><br /><em>// prints BFS traversal from a given source s</em><br /><em>void BFS(int s)</em><br /><em>{</em><br /><em>// Mark all the vertices as not visited(By default</em><br /><em>// set as false)</em><br /><em>boolean visited[] = new boolean[V];</em><br /><br /><em>// Create a queue for BFS</em><br /><em>LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</em><br /><br /><em>// Mark the current node as visited and enqueue it</em><br /><em>visited[s]=true;</em><br /><em>queue.add(s);</em><br /><br /><em>while (queue.size() != 0)</em><br /><em>{</em><br /><em>// Dequeue a vertex from queue and print it</em><br /><em>s = queue.poll();</em><br /><em>System.out.print(s+" ");</em><br /><br /><em>// Get all adjacent vertices of the dequeued vertex s</em><br /><em>// If a adjacent has not been visited, then mark it</em><em> visited and enqueue it</em><br /><em>Iterator&lt;Integer&gt; i = adj[s].listIterator();</em><br /><em>while (i.hasNext())</em><br /><em>{</em><br /><em>int n = i.next();</em><br /><em>if (!visited[n])</em><br /><em>{</em><br /><em>visited[n] = true;</em><br /><em>queue.add(n);</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// Driver method to</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>Graph g = new Graph(4);</em><br /><br /><em>g.addEdge(0, 1);</em><br /><em>g.addEdge(0, 2);</em><br /><em>g.addEdge(1, 2);</em><br /><em>g.addEdge(2, 0);</em><br /><em>g.addEdge(2, 3);</em><br /><em>g.addEdge(3, 3);</em><br /><br /><em>System.out.println("Following is Breadth First Traversal "+</em><br /><em>"(starting from vertex 2)");</em><br /><em>g.BFS(2);</em><br /><em>}</em><br /><em>}<br /></em><br /><strong>Output</strong>:<br />Following is Breadth First Traversal (starting from vertex 2)<br />2 0 3 1</pre>
             </pre></html>
            ]]>
        </item>
        <!--Depth-First Search-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Depth-first Search (DFS) is an algorithm for searching a graph or tree data structure.<br />The algorithm starts at the root (top) node of a tree and goes as far as it can down a given branch (path),<br />and then backtracks until it finds an unexplored path, and then explores it.<br />The algorithm does this until the entire graph has been explored.<br />Many problems in computer science can be thought of in terms of graphs. For example, analyzing networks, mapping routes,<br />scheduling, and finding spanning trees are graph problems.<br />To analyze these problems, graph search algorithms like depth-first search are useful.<br /><br />Depth-first searches are often used as subroutines in other more complex algorithms.<br />For example, the matching algorithm, Hopcroft&ndash;Karp uses a DFS as part of its algorithm to help find a matching in a graph.<br />DFS is also used in tree traversal algorithms, also known as tree searches, which have applications in the the<br />travelling salesman problem and the Ford Fulkerson&rsquo;s algorithm.<br /><br /><strong>Example</strong>:<br /><br /><em>// Java program to print DFS traversal from a given given graph</em><br /><em>import java.io.*;</em><br /><em>import java.util.*;</em><br /><br /><em>// This class represents a directed graph using adjacency list </em><em>representation</em><br /><em>class Graph</em><br /><em>{</em><br /><em>private int V;   // No. of vertices</em><br /><br /><em>// Array  of lists for Adjacency List Representation</em><br /><em>private LinkedList&lt;Integer&gt; adj[];</em><br /><br /><em>// Constructor</em><br /><em>Graph(int v)</em><br /><em>{</em><br /><em>V = v;</em><br /><em>adj = new LinkedList[v];</em><br /><em>for (int i=0; i&lt;v; ++i)</em><br /><em>adj[i] = new LinkedList();</em><br /><em>}</em><br /><br /><em>//Function to add an edge into the graph</em><br /><em>void addEdge(int v, int w)</em><br /><em>{</em><br /><em>adj[v].add(w);  // Add w to v\'s list.</em><br /><em>}</em><br /><br /><em>// A function used by DFS</em><br /><em>void DFSUtil(int v,boolean visited[])</em><br /><em>{</em><br /><em>// Mark the current node as visited and print it</em><br /><em>visited[v] = true;</em><br /><em>System.out.print(v+" ");</em><br /><br /><em>// Recur for all the vertices adjacent to this vertex</em><br /><em>Iterator&lt;Integer&gt; i = adj[v].listIterator();</em><br /><em>while (i.hasNext())</em><br /><em>{</em><br /><em>int n = i.next();</em><br /><em>if (!visited[n])</em><br /><em>DFSUtil(n, visited);</em><br /><em>}            }</em><br /><br /><em>// The function to do DFS traversal. It uses recursive DFSUtil()</em><br /><em>void DFS(int v)</em><br /><em>{</em><br /><em>// Mark all the vertices as not visited(set as</em><br /><em>// false by default in java)</em><br /><em>boolean visited[] = new boolean[V];</em><br /><br /><em>// Call the recursive helper function to print DFS traversal</em><br /><em>DFSUtil(v, visited);</em><br /><em>}</em><br /><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>Graph g = new Graph(4);</em><br /><br /><em>g.addEdge(0, 1);</em><br /><em>g.addEdge(0, 2);</em><br /><em>g.addEdge(1, 2);</em><br /><em>g.addEdge(2, 0);</em><br /><em>g.addEdge(2, 3);</em><br /><em>g.addEdge(3, 3);</em><br /><br /><em>System.out.println("Following is Depth First Traversal "+</em><br /><em>"(starting from vertex 2)");</em><br /><br /><em>g.DFS(2);</em><br /><em>}            </em><br /><em>}<br /></em><br /><strong>Output</strong>:<br />Following is Depth First Traversal (starting from vertex 2)<br />2 0 1 3</pre>
             </pre></html>
            ]]>
        </item>
        <!--Topological Sort-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv,<br />vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.<br /><br />We recommend to first see implementation of DFS here. We can modify DFS to find Topological Sorting of a graph.<br />In DFS, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices.<br />In topological sorting, we use a temporary stack. We don&rsquo;t print the vertex immediately, we first recursively<br />call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack.<br /><br />Note that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on)<br />are already in stack.<br /><br /><strong>Example</strong>:<br /><em>// A Java program to print topological sorting of a DAG</em><br /><em>import java.io.*;</em><br /><em>import java.util.*;</em><br /><br /><em>// This class represents a directed graph using adjacency</em><br /><em>// list representation</em><br /><em>class Graph</em><br /><em>{</em><br /><em>private int V;   // No. of vertices</em><br /><em>private LinkedList&lt;Integer&gt; adj[]; // Adjacency List</em><br /><br /><em>//Constructor</em><br /><em>Graph(int v)</em><br /><em>{</em><br /><em>V = v;</em><br /><em>adj = new LinkedList[v];</em><br /><em>for (int i=0; i&lt;v; ++i)</em><br /><em>adj[i] = new LinkedList();</em><br /><em>}</em><br /><br /><em>// Function to add an edge into the graph</em><br /><em>void addEdge(int v,int w) { adj[v].add(w); }</em><br /><em><br />// A recursive function used by topologicalSort</em><br /><em>void topologicalSortUtil(int v, boolean visited[], </em><em>Stack stack)<br /></em><em>{</em><br /><em>// Mark the current node as visited.</em><br /><em>visited[v] = true;</em><br /><em>Integer i;</em><br /><br /><em>// Recur for all the vertices adjacent to this </em><em>vertex<br /></em><em>Iterator&lt;Integer&gt; it = adj[v].iterator();</em><br /><em>while (it.hasNext())</em><br /><em>{</em><br /><em>i = it.next();</em><br /><em>if (!visited[i])</em><br /><em>topologicalSortUtil(i, visited, stack);</em><br /><em>}</em><br /><br /><em>// Push current vertex to stack which stores result</em><br /><em>stack.push(new Integer(v));</em><br /><em>}</em><br /><em><br />// The function to do Topological Sort. It uses</em><br /><em>// recursive topologicalSortUtil()</em><br /><em>void topologicalSort()</em><br /><em>{</em><br /><em>Stack stack = new Stack();</em><br /><br /><em>// Mark all the vertices as not visited</em><br /><em>boolean visited[] = new boolean[V];</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>visited[i] = false;</em><br /><br /><em>// Call the recursive helper function to store</em><br /><em>// Topological Sort starting from all vertices </em><em>one by one</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>if (visited[i] == false)</em><br /><em>topologicalSortUtil(i, visited, stack);</em><br /><br /><em>// Print contents of stack</em><br /><em>while (stack.empty()==false)</em><br /><em>System.out.print(stack.pop() + " ");</em><br /><em>}</em><br /><br /><em>// Driver method</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>// Create a graph given in the above diagram</em><br /><em>Graph g = new Graph(6);</em><br /><em>g.addEdge(5, 2);</em><br /><em>g.addEdge(5, 0);</em><br /><em>g.addEdge(4, 0);</em><br /><em>g.addEdge(4, 1);</em><br /><em>g.addEdge(2, 3);</em><br /><em>g.addEdge(3, 1);</em><br /><br /><em>System.out.println("Following is a Topological " +</em><br /><em>"sort of the given graph");</em><br /><em>g.topologicalSort();</em><br /><em>}            </em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Following is a Topological Sort of the given graph<br /> 5 4 2 3 1 0</pre>
            </pre></html>
            ]]>
        </item>
        <!--Strongly Connected Components-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A directed graph is strongly connected if there is a path between all pairs of vertices.<br />A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.<br /><br />We can find all strongly connected components in O(V+E) time using Kosaraju\'s algorithm. Following is detailed Kosaraju\'s algorithm.<br />1) Create an empty stack \'S\' and do DFS traversal of a graph. In DFS traversal,<br />after calling recursive DFS for adjacent vertices of a vertex, push the vertex to stack.<br />2) Reverse directions of all arcs to obtain the transpose graph.<br />3) One by one pop a vertex from S while S is not empty. Let the popped vertex be \'v\'. Take v as source and do DFS<br />(call DFSUtil(v)). The DFS starting from v prints strongly connected component of v.<br /><br /><em>// Java implementation of Kosaraju\'s algorithm to print all SCCs</em><br /><em>import java.io.*;</em><br /><em>import java.util.*;</em><br /><em>import java.util.LinkedList;</em><br /><br /><em>// This class represents a directed graph using adjacency list</em><em> representation</em><br /><em>class Graph</em><br /><em>{</em><br /><em>private int V;   // No. of vertices</em><br /><em>private LinkedList&lt;Integer&gt; adj[]; //Adjacency List</em><br /><br /><em>//Constructor</em><br /><em>Graph(int v)</em><br /><em>{</em><br /><em>V = v;</em><br /><em>adj = new LinkedList[v];</em><br /><em>for (int i=0; i&lt;v; ++i)</em><br /><em>adj[i] = new LinkedList();</em><br /><em>}</em><br /><br /><em>//Function to add an edge into the graph</em><br /><em>void addEdge(int v, int w)  { adj[v].add(w); }</em><br /><em><br />// A recursive function to print DFS starting from v</em><br /><em>void DFSUtil(int v,boolean visited[])</em><br /><em>{</em><br /><em>// Mark the current node as visited and print it</em><br /><em>visited[v] = true;</em><br /><em>System.out.print(v + " ");</em><br /><br /><em>int n;</em><br /><br /><em>// Recur for all the vertices adjacent to this vertex</em><br /><em>Iterator&lt;Integer&gt; i =adj[v].iterator();</em><br /><em>while (i.hasNext())</em><br /><em>{</em><br /><em>n = i.next();</em><br /><em>if (!visited[n])</em><br /><em>DFSUtil(n,visited);</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// Function that returns reverse (or transpose) of this graph</em><br /><em>Graph getTranspose()</em><br /><em>{</em><br /><em>Graph g = new Graph(V);</em><br /><em>for (int v = 0; v &lt; V; v++)</em><br /><em>{</em><br /><em>// Recur for all the vertices adjacent to this vertex</em><br /><em>Iterator&lt;Integer&gt; i =adj[v].listIterator();</em><br /><em>while(i.hasNext())</em><br /><em>g.adj[i.next()].add(v);</em><br /><em>}</em><br /><em>return g;</em><br /><em>}</em><br /><em><br />void fillOrder(int v, boolean visited[], Stack stack)</em><br /><em>{</em><br /><em>// Mark the current node as visited and print it</em><br /><em>visited[v] = true;</em><br /><em><br />// Recur for all the vertices adjacent to this vertex</em><br /><em>Iterator&lt;Integer&gt; i = adj[v].iterator();</em><br /><em>while (i.hasNext())</em><br /><em>{</em><br /><em>int n = i.next();</em><br /><em>if(!visited[n])</em><br /><em>fillOrder(n, visited, stack);</em><br /><em>}</em><br /><br /><em>// All vertices reachable from v are processed by now,</em><br /><em>// push v to Stack</em><br /><em>stack.push(new Integer(v));</em><br /><em>}</em><br /><br /><em>// The main function that finds and prints all strongly</em><br /><em>// connected components</em><br /><em>void printSCCs()</em><br /><em>{</em><br /><em>Stack stack = new Stack();</em><br /><em><br />// Mark all the vertices as not visited (For first DFS)</em><br /><em>boolean visited[] = new boolean[V];</em><br /><em>for(int i = 0; i &lt; V; i++)</em><br /><em>visited[i] = false;</em><br /><br /><em>// Fill vertices in stack according to their finishing </em><em>times<br /></em><em>for (int i = 0; i &lt; V; i++)</em><br /><em>if (visited[i] == false)</em><br /><em>fillOrder(i, visited, stack);</em><br /><br /><em>// Create a reversed graph</em><br /><em>Graph gr = getTranspose();</em><br /><br /><em>// Mark all the vertices as not visited (For second DFS)</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>visited[i] = false;</em><br /><br /><em>// Now process all vertices in order defined by Stack</em><br /><em>while (stack.empty() == false)</em><br /><em>{</em><br /><em>// Pop a vertex from stack</em><br /><em>int v = (int)stack.pop();</em><br /><br /><em>// Print Strongly connected component of the popped vertex</em><br /><em>if (visited[v] == false)</em><br /><em>{</em><br /><em>gr.DFSUtil(v, visited);</em><br /><em>System.out.println();</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// Driver method</em><br /><em>public static void main(String args[])</em><br /><em>{</em><br /><em>// Create a graph given in the above diagram</em><br /><em>Graph g = new Graph(5);</em><br /><em>g.addEdge(1, 0);</em><br /><em>g.addEdge(0, 2);</em><br /><em>g.addEdge(2, 1);</em><br /><em>g.addEdge(0, 3);</em><br /><em>g.addEdge(3, 4);</em><br /><br /><em>System.out.println("Following are strongly connected components "+</em><br /><em>"in given graph ");</em><br /><em>g.printSCCs();</em><br /><em>}            </em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Following are strongly connected components in given graph<br />0 1 2<br />3<br />4<br /><br /><em>Time Complexity</em>: The above algorithm calls DFS, fins reverse of the graph and again calls DFS.<br />DFS takes O(V+E) for a graph represented using adjacency list. Reversing a graph also takes O(V+E) time.<br />For reversing the graph, we simple traverse all adjacency lists.<br /><br />The above algorithm is asymptotically best algorithm, but there are other algorithms like Tarjan\'s algorithm and<br />path-based which have same time complexity but find SCCs using single DFS.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Minimum Spanning Trees-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the<br />vertices together. A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight<br />spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight<br />of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.<br /><br />A minimum spanning tree has (V &ndash; 1) edges where V is the number of vertices in the graph.<br /><br /><em>Why minimum spanning trees?</em><br />The standard application is to a problem like phone network design. You have a business with several offices;<br />you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to<br />connect different pairs of cities. You want a set of lines that connects all your offices with a minimum total cost.<br />It should be a spanning tree, since if a network isn\'t a tree you can always remove some edges and save money.<br />A less obvious application is that the minimum spanning tree can be used to approximately solve the traveling salesman problem.<br />A convenient formal way of defining this problem is to find the shortest path that visits each point at least once.<br /><br />Kruskal\'s and Prim\'s algorithms are used to find the minimum spanning tree.</pre>
            </pre></html>
            ]]>
        </item>
        <!--Greedy Algorithms-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A greedy algorithm works by choosing the best possible answer in each step and then moving on to the next step until it<br />reaches the end, without regard for the overall solution. It only hopes that the path it takes is the globally optimum one,<br />but as proven time and again, this method does not often come up with a globally optimum solution. In fact, it is entirely<br />possible that the most optimal short-term solutions lead to the worst possible global outcome.<br />It picks the best immediate output, but does not consider the big picture, hence it is considered greedy.<br /><br />Think of it as taking a lot of shortcuts in a manufacturing business: in the short term large amounts are saved in manufacturing<br />cost, but this eventually leads to downfall since quality is compromised, resulting in product returns and low sales as<br />customers become acquainted with the "cheap" product. But this is not always the case, there are a lot of applications<br />where the greedy algorithm works best to find or approximate the globally optimum solution such as in constructing a<br />Huffman tree or a decision learning tree.</pre>
             </pre></html>
            ]]>
        </item>
        <!--Kruskals Algorithm-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Kruskal\'s algorithm to find the minimum cost spanning tree uses the greedy approach.<br />This algorithm treats the graph as a forest and every node it has as an individual tree.<br />A tree connects to another only and only if, it has the least cost among all available options and does not violate MST properties.<br /><br />Below are the steps for finding MST using Kruskal\'s algorithm<br /><br />1. Sort all the edges in non-decreasing order of their weight.<br />2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.<br />3. Repeat step#2 until there are (V-1) edges in the spanning tree.<br /><br /><strong>Implementation</strong>:<br /><em>// Java program for Kruskal\'s algorithm to find Minimum</em><br /><em>// Spanning Tree of a given connected, undirected and</em><br /><em>// weighted graph</em><br /><em>import java.util.*;</em><br /><em>import java.lang.*;</em><br /><em>import java.io.*;</em><br /><br /><em>class Graph</em><br /><em>{</em><br /><em>// A class to represent a graph edge</em><br /><em>class Edge implements Comparable&lt;Edge&gt;</em><br /><em>{</em><br /><em>int src, dest, weight;</em><br /><br /><em>// Comparator function used for sorting edges</em><br /><em>// based on their weight</em><br /><em>public int compareTo(Edge compareEdge)</em><br /><em>{</em><br /><em>return this.weight-compareEdge.weight;</em><br /><em>}<br />};</em><br /><br /><em>// A class to represent a subset for union-find</em><br /><em>class subset</em><br /><em>{</em><br /><em>int parent, rank;</em><br /><em>};</em><br /><br /><em>int V, E;    // V-&gt; no. of vertices &amp; E-&gt;no.of edges</em><br /><em>Edge edge[]; // collection of all edges</em><br /><br /><em>// Creates a graph with V vertices and E edges</em><br /><em>Graph(int v, int e)</em><br /><em>{</em><br /><em>V = v;</em><br /><em>E = e;</em><br /><em>edge = new Edge[E];</em><br /><em>for (int i=0; i&lt;e; ++i)</em><br /><em>edge[i] = new Edge();</em><br /><em>}</em><br /><br /><em>// A utility function to find set of an element i</em><br /><em>// (uses path compression technique)</em><br /><em>int find(subset subsets[], int i)</em><br /><em>{</em><br /><em>// find root and make root as parent of i (path compression)</em><br /><em>if (subsets[i].parent != i)</em><br /><em>subsets[i].parent = find(subsets, subsets[i].parent);</em><br /><br /><em>return subsets[i].parent;</em><br /><em>}</em><br /><br /><em>// A function that does union of two sets of x and y</em><br /><em>// (uses union by rank)</em><br /><em>void Union(subset subsets[], int x, int y)</em><br /><em>{</em><br /><em>int xroot = find(subsets, x);</em><br /><em>int yroot = find(subsets, y);</em><br /><br /><em>// Attach smaller rank tree under root of high rank tree</em><br /><em>// (Union by Rank)</em><br /><em>if (subsets[xroot].rank &lt; subsets[yroot].rank)</em><br /><em>subsets[xroot].parent = yroot;</em><br /><em>else if (subsets[xroot].rank &gt; subsets[yroot].rank)</em><br /><em>subsets[yroot].parent = xroot;</em><br /><br /><em>// If ranks are same, then make one as root and increment </em><em>its rank by one<br /></em><em>else</em><br /><em>{</em><br /><em>subsets[yroot].parent = xroot;</em><br /><em>subsets[xroot].rank++;</em><br /><em>}<br />}</em><br /><br /><em>// The main function to construct MST using Kruskal\'s algorithm</em><br /><em>void KruskalMST()</em><br /><em>{</em><br /><em>Edge result[] = new Edge[V];  // Tnis will store the resultant MST</em><br /><em>int e = 0;  // An index variable, used for result[]</em><br /><em>int i = 0;  // An index variable, used for sorted edges</em><br /><em>for (i=0; i&lt;V; ++i)</em><br /><em>result[i] = new Edge();</em><br /><br /><em>// Step 1:  Sort all the edges in non-decreasing order of their</em><br /><em>// weight.  If we are not allowed to change the given graph, we </em><em>can create a copy of array of edges<br /></em><em>Arrays.sort(edge);</em><br /><br /><em>// Allocate memory for creating V ssubsets</em><br /><em>subset subsets[] = new subset[V];</em><br /><em>for(i=0; i&lt;V; ++i)</em><br /><em>subsets[i]=new subset();</em><br /><br /><em>// Create V subsets with single elements</em><br /><em>for (int v = 0; v &lt; V; ++v)</em><br /><em>{</em><br /><em>subsets[v].parent = v;</em><br /><em>subsets[v].rank = 0;</em><br /><em>}</em><br /><br /><em>i = 0;  // Index used to pick next edge</em><br /><em><br />// Number of edges to be taken is equal to V-1</em><br /><em>while (e &lt; V - 1)</em><br /><em>{</em><br /><em>// Step 2: Pick the smallest edge. And increment</em><br /><em>// the index for next iteration</em><br /><em>Edge next_edge = new Edge();</em><br /><em>next_edge = edge[i++];</em><br /><br /><em>int x = find(subsets, next_edge.src);</em><br /><em>int y = find(subsets, next_edge.dest);</em><br /><br /><em>// If including this edge does\'t cause cycle,</em><br /><em>// include it in result and increment the index </em><em>of result for next edge</em><br /><em>if (x != y)</em><br /><em> {</em><br /><em>result[e++] = next_edge;</em><br /><em>Union(subsets, x, y);</em><br /><em>}</em><br /><em>// Else discard the next_edge</em><br /><em>}</em><br /><br /><em>// print the contents of result[] to display</em><em> the built MST</em><br /><em>System.out.println("Following are the edges in " +</em><br /><em>"the constructed MST");</em><br /><em>for (i = 0; i &lt; e; ++i)</em><br /><em>System.out.println(result[i].src+" -- " +</em><br /><em>result[i].dest+" == " + result[i].weight);</em><br /><em>}</em><br /><br /><em>// Driver Program</em><br /><em>public static void main (String[] args)</em><br /><em>{</em><br /><br /><em>int V = 4;  // Number of vertices in graph</em><br /><em>int E = 5;  // Number of edges in graph</em><br /><em>Graph graph = new Graph(V, E);</em><br /><br /><em>// add edge 0-1</em><br /><em>graph.edge[0].src = 0;</em><br /><em>graph.edge[0].dest = 1;</em><br /><em>graph.edge[0].weight = 10;</em><br /><br /><em>// add edge 0-2</em><br /><em>graph.edge[1].src = 0;</em><br /><em>graph.edge[1].dest = 2;</em><br /><em>graph.edge[1].weight = 6;</em><br /><br /><em>// add edge 0-3</em><br /><em>graph.edge[2].src = 0;</em><br /><em>graph.edge[2].dest = 3;</em><br /><em>graph.edge[2].weight = 5;</em><br /><br /><em>// add edge 1-3</em><br /><em>graph.edge[3].src = 1;</em><br /><em>graph.edge[3].dest = 3;</em><br /><em>graph.edge[3].weight = 15;</em><br /><br /><em>// add edge 2-3</em><br /><em>graph.edge[4].src = 2;</em><br /><em>graph.edge[4].dest = 3;</em><br /><em>graph.edge[4].weight = 4;</em><br /><br /><em>graph.KruskalMST();</em><br /><em>}           </em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Following are the edges in the constructed MST<br />2 -- 3 == 4<br />0 -- 3 == 5<br />0 -- 1 == 10</pre>
             </pre></html>
            ]]>
        </item>
        <!--Prims Algorithm-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Like Kruskal\'s algorithm, Prim\'s algorithm is also a Greedy algorithm. It starts with an empty spanning tree. The idea is to<br />maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the<br />vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight<br />edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.<br />A group of edges that connects two set of vertices in a graph is called cut in graph theory.<br />So, at every step of Prim\'s algorithm, we find a cut (of two sets, one contains the vertices already included in MST and other<br />contains rest of the verices), pick the minimum weight edge from the cut and include this vertex to MST Set<br />(the set that contains already included vertices).<br /><br /><strong>Implementation</strong>:<br /><em>// A Java program for Prim\'s Minimum Spanning Tree (MST) algorithm.</em><br /><em>// The program is for adjacency matrix representation of the graph</em><br /><br /><em>import java.util.*;</em><br /><em>import java.lang.*;</em><br /><em>import java.io.*;</em><br /><br /><em>class MST</em><br /><em>{</em><br /><em>// Number of vertices in the graph</em><br /><em>private static final int V=5;</em><br /><br /><em>// A utility function to find the vertex with minimum key </em><em>value, from the set of vertices not yet included in MST</em><br /><em>int minKey(int key[], Boolean mstSet[])</em><br /><em>{</em><br /><em>// Initialize min value</em><br /><em>int min = Integer.MAX_VALUE, min_index=-1;</em><br /><br /><em>for (int v = 0; v &lt; V; v++)</em><br /><em>if (mstSet[v] == false &amp;&amp; key[v] &lt; min)</em><br /><em>{</em><br /><em>min = key[v];</em><br /><em>min_index = v;</em><br /><em>}</em><br /><br /><em>return min_index;</em><br /><em>}</em><br /><em><br />// A utility function to print the constructed MST stored in</em><em> parent[]</em><br /><em>void printMST(int parent[], int n, int graph[][])</em><br /><em>{</em><br /><em>System.out.println("Edge   Weight");</em><br /><em>for (int i = 1; i &lt; V; i++)</em><br /><em>System.out.println(parent[i]+" - "+ i+"    "+</em><br /><em>graph[i][parent[i]]);</em><br /><em>}</em><br /><br /><em>// Function to construct and print MST for a graph represented</em><br /><em>//  using adjacency matrix representation</em><br /><em>void primMST(int graph[][])</em><br /><em>{</em><br /><em>// Array to store constructed MST</em><br /><em>int parent[] = new int[V];</em><br /><br /><em>// Key values used to pick minimum weight edge in cut</em><br /><em>int key[] = new int [V];</em><br /><br /><em>// To represent set of vertices not yet included in MST</em><br /><em>Boolean mstSet[] = new Boolean[V];</em><br /><em><br />          // Initialize all keys as INFINITE</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>{</em><br /><em>key[i] = Integer.MAX_VALUE;</em><br /><em>mstSet[i] = false;</em><br /><em>}</em><br /><br /><em>// Always include first 1st vertex in MST.</em><br /><em>key[0] = 0;     // Make key 0 so that this vertex is</em><br /><em>// picked as first vertex</em><br /><em>parent[0] = -1; // First node is always root of MST</em><br /><br /><em>// The MST will have V vertices</em><br /><em>for (int count = 0; count &lt; V-1; count++)</em><br /><em>{</em><br /><em>// Pick thd minimum key vertex from the set of vertices</em><br /><em>// not yet included in MST</em><br /><em>int u = minKey(key, mstSet);</em><br /><br /><em>// Add the picked vertex to the MST Set</em><br /><em>mstSet[u] = true;</em><br /><br /><em>// Update key value and parent index of the adjacent</em><br /><em>// vertices of the picked vertex. Consider only those</em><br /><em>// vertices which are not yet included in MST</em><br /><em>for (int v = 0; v &lt; V; v++)</em><br /><br /><em>// graph[u][v] is non zero only for adjacent vertices of m</em><br /><em>// mstSet[v] is false for vertices not yet included in MST</em><br /><em>// Update the key only if graph[u][v] is smaller than key[v]</em><br /><em>if (graph[u][v]!=0 &amp;&amp; mstSet[v] == false &amp;&amp;</em><br /><em>graph[u][v] &lt;  key[v])</em><br /><em>{</em><br /><em>parent[v]  = u;</em><br /><em>key[v] = graph[u][v];</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// print the constructed MST</em><br /><em>printMST(parent, V, graph);</em><br /><em>      }</em><br /><br /><em>public static void main (String[] args)</em><br /><em>{</em><br /> <br /><em> MST t = new MST();</em><br /><em> int graph[][] = new int[][] {{0, 2, 0, 6, 0},</em><br /><em> {2, 0, 3, 8, 5},</em><br /><em> {0, 3, 0, 0, 7},</em><br /><em> {6, 8, 0, 0, 9},</em><br /><em> {0, 5, 7, 9, 0},</em><br /><em> };</em><br /><br /><em>// Print the solution</em><br /><em>t.primMST(graph);</em><br />}<br />}<br /><br /><strong>Output</strong>:<br />Edge   Weight<br />0 - 1    2<br />1 - 2    3<br />0 - 3    6<br />1 - 4    5</pre>
            </pre></html>
            ]]>
        </item>
        <!--Djiktras Algorithm-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>Given a graph and a source vertex in the graph, find shortest paths from source to all vertices in the given graph.<br /><br />Dijkstra\'s algorithm is very similar to Prim\'s algorithm for minimum spanning tree. Like Prim\'s MST,<br />we generate a SPT (shortest path tree) with given source as root. We maintain two sets, one set contains<br />vertices included in shortest path tree, other set includes vertices not yet included in shortest path tree.<br />At every step of the algorithm, we find a vertex which is in the other set (set of not yet included)<br />and has a minimum distance from the source.<br /><br />Below are the detailed steps used in Dijkstra\'s algorithm to find the shortest path from a single source vertex to all<br />other vertices in the given graph.<br /><br /><strong>Algorithm</strong><br />1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e.,<br />whose minimum distance from source is calculated and finalized. Initially, this set is empty.<br />2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE.<br />Assign distance value as 0 for the source vertex so that it is picked first.<br />3) While sptSet doesn\'t include all vertices<br />&hellip;.a) Pick a vertex u which is not there in sptSet and has minimum distance value.<br />&hellip;.b) Include u to sptSet.<br />&hellip;.c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices.<br />For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is<br />less than the distance value of v, then update the distance value of v.<br /><br /><strong>Implementation</strong>:<br /><br /><em>// A Java program for Dijkstra\'s single source shortest path algorithm.</em><br /><em>// The program is for adjacency matrix representation of the graph</em><br /><em>import java.util.*;</em><br /><em>import java.lang.*;</em><br /><em>import java.io.*;</em><br /><br /><em>class ShortestPath</em><br /><em>{</em><br /><em>// A utility function to find the vertex with minimum distance value,</em><br /><em>// from the set of vertices not yet included in shortest path tree</em><br /><em>static final int V=9;</em><br /><em>int minDistance(int dist[], Boolean sptSet[])</em><br /><em>{</em><br /><em>// Initialize min value</em><br /><em>int min = Integer.MAX_VALUE, min_index=-1;</em><br /><br /><em>for (int v = 0; v &lt; V; v++)</em><br /><em>if (sptSet[v] == false &amp;&amp; dist[v] &lt;= min)</em><br /><em>{</em><br /><em>min = dist[v];</em><br /><em>min_index = v;</em><br /><em>}</em><br /><br /><em>return min_index;</em><br /><em>}</em><br /><br /><em>// A utility function to print the constructed distance array</em><br /><em>void printSolution(int dist[], int n)</em><br /><em>{</em><br /><em>System.out.println("Vertex   Distance from Source");</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>System.out.println(i+" tt "+dist[i]);</em><br /><em>}</em><br /><br /><em>// Funtion that implements Dijkstra\'s single source shortest path</em><br /><em>// algorithm for a graph represented using adjacency matrix</em><br /><em>// representation</em><br /><em>void dijkstra(int graph[][], int src)</em><br /><em>{</em><br /><em>int dist[] = new int[V]; // The output array. dist[i] will hold</em><br /><em>// the shortest distance from src to i</em><br /><br /><em>// sptSet[i] will true if vertex i is included in shortest</em><br /><em>// path tree or shortest distance from src to i is finalized</em><br /><em>Boolean sptSet[] = new Boolean[V];</em><br /><br /><em>// Initialize all distances as INFINITE and stpSet[] as false</em><br /><em>for (int i = 0; i &lt; V; i++)</em><br /><em>{</em><br /><em>dist[i] = Integer.MAX_VALUE;</em><br /><em>sptSet[i] = false;</em><br /><em>}</em><br /><br /><em>// Distance of source vertex from itself is always 0</em><br /><em>dist[src] = 0;</em><br /><em><br />// Find shortest path for all vertices</em><br /><em>for (int count = 0; count &lt; V-1; count++)</em><br /><em>{</em><br /><em>// Pick the minimum distance vertex from the set of vertices</em><br /><em>// not yet processed. u is always equal to src in first</em><br /><em>// iteration.</em><br /><em>int u = minDistance(dist, sptSet);</em><br /><br /><em>// Mark the picked vertex as processed</em><br /><em>sptSet[u] = true;</em><br /><br /><em>// Update dist value of the adjacent vertices of the</em><br /><em>// picked vertex.</em><br /><em>for (int v = 0; v &lt; V; v++)</em><br /><br /><em>// Update dist[v] only if is not in sptSet, there is an</em><br /><em>// edge from u to v, and total weight of path from src to</em><br /><em>// v through u is smaller than current value of dist[v]</em><br /><em>if (!sptSet[v] &amp;&amp; graph[u][v]!=0 &amp;&amp;</em><br /><em>dist[u] != Integer.MAX_VALUE &amp;&amp;</em><br /><em>dist[u]+graph[u][v] &lt; dist[v])</em><br /><em>dist[v] = dist[u] + graph[u][v];</em><br /><em>}</em><br /><br /><em>// print the constructed distance array</em><br /><em>printSolution(dist, V);</em><br /><em>}</em><br /><br /><em>// Driver method</em><br /><em>public static void main (String[] args)</em><br /><em>{</em><br /><em>/* Let us create the example graph discussed above */</em><br /><em>int graph[][] = new int[][]{{0, 4, 0, 0, 0, 0, 0, 8, 0},</em><br /><em>{4, 0, 8, 0, 0, 0, 0, 11, 0},</em><br /><em>{0, 8, 0, 7, 0, 4, 0, 0, 2},</em><br /><em>{0, 0, 7, 0, 9, 14, 0, 0, 0},</em><br /><em>{0, 0, 0, 9, 0, 10, 0, 0, 0},</em><br /><em>{0, 0, 4, 14, 10, 0, 2, 0, 0},</em><br /><em>{0, 0, 0, 0, 0, 2, 0, 1, 6},</em><br /><em>{8, 11, 0, 0, 0, 0, 1, 0, 7},</em><br /><em>{0, 0, 2, 0, 0, 0, 6, 7, 0}</em><br /><em>};</em><br /><em>ShortestPath t = new ShortestPath();</em><br /><em>t.dijkstra(graph, 0);</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Vertex   Distance from Source<br />0                0<br />1                4<br />2                12<br />3                19<br />4                21<br />5                11<br />6                9<br />7                8<br />8                14</pre>
             </pre></html>
            ]]>
        </item>
        <!--The floyd-warshall Algorithm-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
           <pre>The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances<br />between every pair of vertices in a given edge weighted directed Graph.<br /><br /><strong>Algorithm</strong>:<br />We initialize the solution matrix same as the input graph matrix as a first step.<br />Then we update the solution matrix by considering all vertices as an intermediate vertex.<br />The idea is to one by one pick all vertices and updates all shortest paths which include the picked vertex as an intermediate<br />vertex in the shortest path. When we pick vertex number k as an intermediate vertex, we already have considered vertices<br />{0, 1, 2, .. k-1} as intermediate vertices. For every pair (i, j) of the source and destination vertices respectively,<br />there are two possible cases.<br />1) k is not an intermediate vertex in shortest path from i to j. We keep the value of dist[i][j] as it is.<br />2) k is an intermediate vertex in shortest path from i to j. We update the value of dist[i][j] as dist[i][k] + dist[k][j].<br /><br /><strong>Implementation</strong>:<br /><em>// A Java program for Floyd Warshall All Pairs Shortest</em><br /><em>// Path algorithm.</em><br /><em>import java.util.*;</em><br /><em>import java.lang.*;</em><br /><em>import java.io.*;</em><br /><br /><em>class AllPairShortestPath</em><br /><em>{</em><br /><em>final static int INF = 99999, V = 4;</em><br /><br /><em>void floydWarshall(int graph[][])</em><br /><em>{</em><br /><em>int dist[][] = new int[V][V];</em><br /><em>int i, j, k;</em><br /><br /><em>/* Initialize the solution matrix same as input graph matrix.</em><br /><em>Or we can say the initial values of shortest distances</em><br /><em>are based on shortest paths considering no intermediate</em><br /><em>vertex. */</em><br /><em>for (i = 0; i &lt; V; i++)</em><br /><em>for (j = 0; j &lt; V; j++)</em><br /><em>dist[i][j] = graph[i][j];</em><br /><br /><em>/* Add all vertices one by one to the set of intermediate</em><br /><em>vertices.</em><br /><em>---&gt; Before start of an iteration, we have shortest</em><br /><em>distances between all pairs of vertices such that</em><br /><em>the shortest distances consider only the vertices in</em><br /><em>set {0, 1, 2, .. k-1} as intermediate vertices.</em><br /><em>----&gt; After the end of an iteration, vertex no. k is added</em><br /><em>to the set of intermediate vertices and the set</em><br /><em>becomes {0, 1, 2, .. k} */</em><br /><em>for (k = 0; k &lt; V; k++)</em><br /><em>{</em><br /><em>// Pick all vertices as source one by one</em><br /><em>for (i = 0; i &lt; V; i++)</em><br /><em>{</em><br /><em>// Pick all vertices as destination for the</em><br /><em>// above picked source</em><br /><em>for (j = 0; j &lt; V; j++)</em><br /><em>{</em><br /><em>// If vertex k is on the shortest path from</em><br /><em>// i to j, then update the value of dist[i][j]</em><br /><em>if (dist[i][k] + dist[k][j] &lt; dist[i][j])</em><br /><em>dist[i][j] = dist[i][k] + dist[k][j];</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// Print the shortest distance matrix</em><br /><em>printSolution(dist);</em><br /><em>}</em><br /><br /><em>void printSolution(int dist[][])</em><br /><em>{</em><br /><em>System.out.println("The following matrix shows the shortest "+</em><br /><em>"distances between every pair of vertices");</em><br /><em>for (int i=0; i&lt;V; ++i)</em><br /><em>{</em><br /><em>for (int j=0; j&lt;V; ++j)</em><br /><em>{</em><br /><em>if (dist[i][j]==INF)</em><br /><em>System.out.print("INF ");</em><br /><em>else</em><br /><em>System.out.print(dist[i][j]+"   ");</em><br /><em>}</em><br /><em>System.out.println();</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// Driver program to test above function</em><br /><em>public static void main (String[] args)</em><br /><em>{</em><br />   <br /><em>int graph[][] = { {0,   5,  INF, 10},</em><br /><em>{INF, 0,   3, INF},</em><br /><em>{INF, INF, 0,   1},</em><br /><em>{INF, INF, INF, 0}</em><br /><em>};</em><br /><em>AllPairShortestPath a = new AllPairShortestPath();</em><br /><br /><em>// Print the solution</em><br /><em>a.floydWarshall(graph);</em><br /><em>}</em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />Following matrix shows the shortest distances between every pair of vertices<br />0      5      8      9<br />INF    0      3      4<br />INF   INF     0      1<br />INF   INF    INF     0</pre>
             </pre></html>
            ]]>
        </item>
        <!--Flow networks-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>A Flow network is a directed graph where each edge has a capacity and a flow. They are typically used to model problems<br />involving the transport of items between locations, using a network of routes with limited capacity.<br /><br />Examples include modeling traffic on a network of roads, fluid in a network of pipes, and electricity in a network of<br />circuit components.<br /><br />For example, a company might want to ship packages from Los Angeles to New York City using trucks to transport between<br />intermediate cities. If there is only one truck for the route connecting a pair of cities and each truck has a maximum load,<br />then the graph describing the transportation options will be a flow network. Each node will represent a city and each edge<br />will represent a truck route between those cities (e.g. a highway). The capacity for a particular route will be the maximum<br />load the truck for that route can carry. Using this model, the company can decide how to split their packages between trucks<br />so that the packages can reach their destination using the available routes and trucks.<br />The number of packages the company decides to ship along a particular truck route is the flow for that route.<br /><br /><strong>Flow Network Problems</strong>:<br />There are several different problems that can be modeled as flow networks. A few in particular are common and show up in<br />very diverse fields. Since flow network problems have been well studied, each is only briefly described here,<br />along with some example applications. More in depth discussions are linked to in each problem description.<br /><br /><strong>Maximum Flow</strong>:<br />The maximum flow problem is the problem of finding the maximum admissible flow through a single source,<br />single sink flow network. It was originally formulated in 1954 by mathematicians attempting to model Soviet<br />railway traffic flow. Well known solutions for the maximum flow problem include the Ford-Fulkerson algorithm,<br />Edmonds-Karp algorithm, and Dinic\'s algorithm.<br />Maximum flow algorithms have an enormous range of applications. Examples include airline flight crew scheduling,<br />the circulation-demand problem (where goods with location dependent demand must be transported using routes with<br />limited capacity), and determining when during a sports season to eliminate losing teams.<br /><br /><strong>Minimum Cost Flow</strong>:<br />Minimum cost flow is the problem of finding the cheapest possible way to send a certain amount of flow through a network.<br />This requires extending the flow network so that each edge  now also has an associated cost  per unit of flow per edge.<br />The total cost of a flow is then a(e) \cdot f(e)). Minimum cost flow can be solved using linear programming since the<br />objective function is linear, as are the constraints.<br />One common application of minimum cost flow is in determining the cheapest way to transport items from point A to point B,<br />given some routes with limited capacity and associated cost. For example, truck routes may have greater capacity,<br />but higher cost (in terms of time), while plane routes may have lesser capacity, but lower cost.<br />Thus, a company looking to minimize the cost of transport would seek to model this trade-off between capacity and cost<br />using minimum cost flow.<br /><br /><strong>Maximal Bipartite Matching</strong>:<br />Maximal bipartite matching is the problem of determining the maximal matching for a bipartite graph.<br />If the graph is modeled as a flow network (flow from one set of nodes to the other), various flow algorithms<br />can be used to solve it. For example, the Ford-Fulkerson algorithm can solve bipartite matching in unweighted graphs,<br />as can the Hopcroft&ndash;Karp algorithm, which does so more efficiently since it is designed specially for bipartite graphs.<br />For the weighted graph case (called the assignment problem), the best known algorithm is the Hungarian algorithm.<br />Most interesting maximal bipartite matching is framed in terms of the assignment problem.<br />The most common formulation of the assignment problem is that given a certain number of agents and<br />a certain number of tasks, as well as a cost/benefit for each agent on each task, assign each agent to exactly one<br />task such that the cost/benefit is minimized/maximized. Many common problems cans be formulated in terms of the<br />assignment problem, so the applications are extremely diverse. Applications include scheduling, resource allocation,<br />and transportation segmentation.<br /><br /><strong>Transportation Problem</strong>:<br />A more general version of the assignment problem is the transportation problem. It turns out the transportation problem is<br />also a more specific version of the minimum cost problem. The transportation problem is similar to the assignment problem,<br />but instead of each agent being assigned to exactly one task, each agent can split their time among multiple tasks and<br />each task may by attended to by multiple agents. Thus, some agents and tasks may not be assigned.<br />The transportation problem, like its name suggests, is sometimes described in terms of mines and factories.<br />If mines supply factories with ore, then the transportation problem reduces to determining the most cost effective<br />way to transport ore from individual mines to individual factories. Thus, ore from one mine may be sent to multiple<br />factories, while one factory may use the ore from many mines. In this case, the cost function is dependent on the<br />Euclidean distance between each mine and factory, as well as the cost of available transportation methods between the two.<br />Obviously, mining isn\'t the only industry whose transportation concerns can be formulated in this fashion,<br />so the problem itself is very general, as are its applications.</pre>
             </pre></html>
            ]]>
        </item>
        <!--The ford fulkerson method-->
        <item>
            <![CDATA[<html><pre style="text-align:center">
            <pre>The Ford-Fulkerson algorithm is an algorithm that tackles the max-flow min-cut problem.<br />That is, given a network with vertices and edges between those vertices that have certain weights,<br />how much "flow" can the network process at a time? Flow can mean anything, but typically it means data through a computer network.<br /><br />It was discovered in 1956 by Ford and Fulkerson. This algorithm is sometimes referred to as a method because parts of<br />its protocol are not fully specified and can vary from implementation to implementation. An algorithm typically refers to a<br />specific protocol for solving a problem, whereas a method is a more general approach to a problem.<br /><br />The Ford-Fulkerson algorithm assumes that the input will be a graph, G, along with a source vertex, s, and a sink vertex, t.<br />The graph is any representation of a weighted graph where vertices are connected by edges of specified weights.<br />There must also be a source vertex and sink vertex to understand the beginning and end of the flow network.<br /><br /><em>Time Complexity</em>: Time complexity of the above algorithm is O(max_flow * E). We run a loop while there is an augmenting path.<br />In worst case, we may add 1 unit flow in every iteration. Therefore the time complexity becomes O(max_flow * E).<br /><br /><strong>Implementation:</strong><br /><br /><em>// Java program for implementation of Ford Fulkerson algorithm</em><br /><em>import java.util.*;</em><br /><em>import java.lang.*;</em><br /><em>import java.io.*;</em><br /><em>import java.util.LinkedList;</em><br /><br /><em>class MaxFlow</em><br /><em>{</em><br /><em>static final int V = 6;    //Number of vertices in graph</em><br /><br /><em>/* Returns true if there is a path from source \'s\' to sink</em><br /><em>\'t\' in residual graph. Also fills parent[] to store the</em><br /><em>path */</em><br /><em>boolean bfs(int rGraph[][], int s, int t, int parent[])</em><br /><em>{</em><br /><em>// Create a visited array and mark all vertices as not</em><br /><em>// visited</em><br /><em>boolean visited[] = new boolean[V];</em><br /><em>for(int i=0; i&lt;V; ++i)</em><br /><em>visited[i]=false;</em><br /><br /><em>// Create a queue, enqueue source vertex and mark</em><br /><em>// source vertex as visited</em><br /><em> LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();</em><br /><em> queue.add(s);</em><br /><em>visited[s] = true;</em><br /><em>parent[s]=-1;</em><br /><br /><em>// Standard BFS Loop</em><br /><em>while (queue.size()!=0)</em><br /><em>{</em><br /><em>int u = queue.poll();</em><br /><br /><em>for (int v=0; v &lt; V; v++)</em><br /><em>{</em><br /><em>if (visited[v]==false &amp;&amp; rGraph[u][v] &gt; 0)</em><br /><em>{</em><br /><em>queue.add(v);</em><br /><em>parent[v] = u;</em><br /><em> visited[v] = true;</em><br /><em>}</em><br /><em>}</em><br /><em>}</em><br /><br /><em>// If we reached sink in BFS starting from source, then</em><br /><em>// return true, else false</em><br /><em>return (visited[t] == true);</em><br /><em>}</em><br /><br /><em>// Returns tne maximum flow from s to t in the given graph</em><br /><em>int fordFulkerson(int graph[][], int s, int t)</em><br /><em>{</em><br /><em>int u, v;</em><br /><em><br />// Create a residual graph and fill the residual graph</em><br /><em>// with given capacities in the original graph as</em><br /><em>// residual capacities in residual graph</em><br /><br /><em>// Residual graph where rGraph[i][j] indicates</em><br /><em>// residual capacity of edge from i to j (if there </em><em>is an edge. If rGraph[i][j] is 0, then there is </em><em>not)</em><br /><em>int rGraph[][] = new int[V][V];</em><br /><br /><em>for (u = 0; u &lt; V; u++)</em><br /><em>for (v = 0; v &lt; V; v++)</em><br /><em>rGraph[u][v] = graph[u][v];</em><br /><em><br />// This array is filled by BFS and to store path</em><br /><em>int parent[] = new int[V];</em><br /><br /><em>int max_flow = 0;  // There is no flow initially</em><br /><br /><em>// Augment the flow while tere is path from source </em><em>to sink</em><br /><em>while (bfs(rGraph, s, t, parent))</em><br /><em>{</em><br /><em>// Find minimum residual capacity of the edhes</em><br /><em>// along the path filled by BFS. Or we can say</em><br /><em>// find the maximum flow through the path found.</em><br /><em>int path_flow = Integer.MAX_VALUE;</em><br /><em>for (v=t; v!=s; v=parent[v])</em><br /><em>{</em><br /><em>u = parent[v];</em><br /><em>path_flow = Math.min(path_flow, rGraph[u][v]);</em><br /><em>}</em><br /><br /><em>// update residual capacities of the edges and</em><br /><em>// reverse edges along the path</em><br /><em>for (v=t; v != s; v=parent[v])</em><br /><em>{</em><br /><em>u = parent[v];</em><br /><em>rGraph[u][v] -= path_flow;</em><br /><em>rGraph[v][u] += path_flow;</em><br /><em>}</em><br /><br /><em>// Add path flow to overall flow</em><br /><em>max_flow += path_flow;</em><br /><em>}</em><br /><br /><em>// Return the overall flow</em><br /><em>return max_flow;</em><br /><em>}</em><br /><br /><em>// Driver program to test above functions</em><br /><em>public static void main (String[] args) throws java.lang.Exception</em><br /><em>{</em><br /><em>// Let us create a graph shown in the above example</em><br /><em>int graph[][] =new int[][] { {0, 16, 13, 0, 0, 0},</em><br /><em>{0, 0, 10, 12, 0, 0},</em><br /><em>{0, 4, 0, 0, 14, 0},</em><br /><em>{0, 0, 9, 0, 0, 20},</em><br /><em>{0, 0, 0, 7, 0, 4},</em><br /><em>{0, 0, 0, 0, 0, 0}</em><br /><em>};</em><br /><em>MaxFlow m = new MaxFlow();</em><br /><br /><em>System.out.println("The maximum possible flow is " +</em><br /><em>m.fordFulkerson(graph, 0, 5));</em><br /><br /><em>}</em><br /><em>}</em><br /><br /><strong>Output</strong>:<br />The maximum possible flow is 23</pre>
            </pre></html>
            ]]>
        </item>
        <!--Maximum bipartite matching-->
        <!--<item>-->
            <!---->
        <!--</item>-->

        <!--Push Relabel Algorithm-->
        <!--<item>-->
        <!---->
        <!--</item>-->

    </string-array>


</resources>