<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string-array name="graph_algorithms">
        <item>
            Representations of graphs
        </item>
        <item>
            Breadth-First Search
        </item>
        <item>
            Depth-First Search
        </item>
        <item>
            Topological Sort
        </item>
        <item>
            Strongly Connected Components
        </item>
        <item>
            Minimum Spanning Trees
        </item>
        <item>
            Greedy Algorithms
        </item>
        <item>
            Kruskal\'s Algorithm
        </item>
        <item>
            Prim\'s Algorithm
        </item>
        <item>
            Dijkstra\'s Algorithm
        </item>
        <item>
            The Floyd-Warshall Algorithm
        </item>
        <item>
            Flow Networks
        </item>
        <item>
            The Ford Fulkerson method
        </item>
        <!--<item>-->
            <!--Maximum Bipartite Matching-->
        <!--</item>-->
        <!--<item>-->
            <!--Push relabel Algorithm-->
        <!--</item>-->

    </string-array>
    <string-array name="graph_algorithms_answers">
        <!--Representations of graphs-->
        <item>
            Graph is a data structure that consists of following two components:
            \n\n 1. A finite set of vertices also called as nodes.
            \n\n 2. A finite set of ordered pair of the form (u, v) called as edge.
            The pair is ordered because (u, v) is not same as (v, u) in case of a directed graph(di-graph).
            The pair of the form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.

            \n\nGraphs are used to represent many real-life applications: Graphs are used to represent networks.
            The networks may include paths in a city or telephone network or circuit network.
            Graphs are also used in social networks like linkedIn, Facebook.
            For example, in Facebook, each person is represented with a vertex(or node).
            Each node is a structure and contains information like person id, name, gender and locale.

            \n\nFollowing two are the most commonly used representations of a graph.
            \n\n 1. Adjacency Matrix
            \n\n 2. Adjacency List
            \nThere are other representations also like, Incidence Matrix and Incidence List.
            The choice of the graph representation is situation specific. It totally depends on the type of operations to be
            performed and ease of use.

            \n\nAdjacency Matrix:
            \nAdjacency Matrix is a 2D array of size V x V where V is the number of vertices in a graph.
            Let the 2D array be adj[][], a slot adj[i][j] = 1 indicates that there is an edge from vertex i to vertex j.
            Adjacency matrix for undirected graph is always symmetric. Adjacency Matrix is also used to represent weighted graphs.
            If adj[i][j] = w, then there is an edge from vertex i to vertex j with weight w.

            \n\nAdjacency List:
            \nAn array of linked lists is used. Size of the array is equal to the number of vertices.
            Let the array be array[]. An entry array[i] represents the linked list of vertices adjacent to the ith vertex.
            This representation can also be used to represent a weighted graph. The weights of edges can be stored in nodes of linked lists.

            \n\nExample:

            \n\n// Java Program to demonstrate adjacency list
            \n// representation of graphs
            \nimport java.util.LinkedList;
\n
            \n          public class GFG
            \n        {
            \n      // A user define class to represent a graph.
            \n    // A graph is an array of adjacency lists.
            \n  // Size of array will be V (number of vertices
            \n// in graph)
            \nstatic class Graph
            \n {
            \nint V;
            \nLinkedList&lt;Integer&gt; adjListArray[];
            \n
            \n          // constructor
            \n        Graph(int V)
            \n      {
            \n    this.V = V;
            \n
            \n          // define the size of array as
            \n        // number of vertices
            \n      adjListArray = new LinkedList[V];
            \n
            \n          // Create a new list for each vertex
            \n      // such that adjacent nodes can be stored
            \n       for(int i = 0; i &lt; V ; i++){
            \n      adjListArray[i] = new LinkedList&lt;&gt;();
            \n    }
            \n  }
            \n}
            \n
            \n          // Adds an edge to an undirected graph
            \n        static void addEdge(Graph graph, int src, int dest)
            \n      {
            \n    // Add an edge from src to dest.
            \n  graph.adjListArray[src].addFirst(dest);
            \n
            \n          // Since graph is undirected, add an edge from dest
            \n        // to src also
            \n      graph.adjListArray[dest].addFirst(src);
            \n    }
            \n
            \n          // A utility function to print the adjacency list
            \n        // representation of graph
            \n      static void printGraph(Graph graph)
            \n    {
            \n  for(int v = 0; v &lt; graph.V; v++)
            \n{
            \nSystem.out.println("Adjacency list of vertex "+ v);
            \nSystem.out.print("head");
            \nfor(Integer pCrawl: graph.adjListArray[v]){
            \nSystem.out.print(" -> "+pCrawl);
            \n}
            \nSystem.out.println("\n");
            \n}
            \n}
            \n
            \n        // Driver program to test above functions
            \n          public static void main(String args[])
            \n        {
            \n      // create the graph given in above figure
            \n    int V = 5;
            \n  Graph graph = new Graph(V);
            \naddEdge(graph, 0, 1);
            \naddEdge(graph, 0, 4);
            \n addEdge(graph, 1, 2);
            \naddEdge(graph, 1, 3);
            \naddEdge(graph, 1, 4);
            \naddEdge(graph, 2, 3);
            \naddEdge(graph, 3, 4);
            \n
            \n          // print the adjacency list representation of
            \n        // the above graph
            \n      printGraph(graph);
            \n    }            }

            \n\nOutput:
            \n Adjacency list of vertex 0
            \n head -> 1-> 4
            \n
            \n          Adjacency list of vertex 1
            \n        head -> 0-> 2-> 3-> 4
            \n
            \n          Adjacency list of vertex 2
            \n        head -> 1-> 3
            \n
            \n          Adjacency list of vertex 3
            \n        head -> 1-> 2-> 4
            \n
            \n          Adjacency list of vertex 4
            \n        head -> 0-> 1-> 3
        </item>
        <!--Breadth-First Search-->
        <item>
            Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree.
            The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again.
            To avoid processing a node more than once, we use a boolean visited array.
            For simplicity, it is assumed that all vertices are reachable from the starting vertex.

            \n\nBreadth-first search assigns two values to each vertex v:

            \n\n - A distance, giving the minimum number of edges in any path from the source vertex to vertex v.
            \n - The predecessor vertex of v vv along some shortest path from the source vertex.
            The source vertex\'s predecessor is some special value, such as null, indicating that it has no predecessor.

            \n\nIn BFS, we initially set the distance and predecessor of each vertex to the special value (null).
            We start the search at the source and assign it a distance of 0. Then we visit all the neighbors of the source and give each
            neighbor a distance of 1 and set its predecessor to be the source. Then we visit all the neighbors of the vertices whose
            distance is 1 and that have not been visited before, and we give each of these vertices a distance of 2 and set its predecessor
            to be vertex from which we visited it. We keep going until all vertices reachable from the source vertex have been visited,
            always visiting all vertices at distance k from the source before visiting any vertex at distance k+1, plus, 1.

            \n\nExample:

            \n\n// Java program to print BFS traversal from a given source vertex.
            \n// BFS(int s) traverses vertices reachable from s.
            \nimport java.io.*;
            \nimport java.util.*;
            \n
            \n          // This class represents a directed graph using adjacency list
            \n        // representation
            \n      class Graph
            \n    {
            \n  private int V;   // No. of vertices
            \n private LinkedList&lt;Integer&gt; adj[]; //Adjacency Lists
            \n
            \n          // Constructor
            \n        Graph(int v)
            \n      {
            \n    V = v;
            \n  adj = new LinkedList[v];
            \nfor (int i=0; i&lt;v; ++i)
            \n adj[i] = new LinkedList();
            \n}
            \n
            \n          // Function to add an edge into the graph
            \n        void addEdge(int v,int w)
            \n      {
            \n    adj[v].add(w);
            \n  }
            \n
            \n          // prints BFS traversal from a given source s
            \n        void BFS(int s)
            \n      {
            \n    // Mark all the vertices as not visited(By default
            \n  // set as false)
            \nboolean visited[] = new boolean[V];
            \n
            \n          // Create a queue for BFS
            \n        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
            \n
            \n          // Mark the current node as visited and enqueue it
            \n        visited[s]=true;
            \n      queue.add(s);
            \n
            \n          while (queue.size() != 0)
            \n        {
            \n      // Dequeue a vertex from queue and print it
            \n    s = queue.poll();
            \n  System.out.print(s+" ");
            \n
            \n           // Get all adjacent vertices of the dequeued vertex s
            \n         // If a adjacent has not been visited, then mark it
            \n          // visited and enqueue it
            \n        Iterator^lt;Integer&gt; i = adj[s].listIterator();
            \n      while (i.hasNext())
            \n    {
            \n  int n = i.next();
            \nif (!visited[n])
            \n{
            \nvisited[n] = true;
            \nqueue.add(n);
            \n }
            \n}
            \n }
            \n}
            \n
            \n          // Driver method to
            \n        public static void main(String args[])
            \n      {
            \n    Graph g = new Graph(4);
            \n
            \n          g.addEdge(0, 1);
            \n        g.addEdge(0, 2);
            \n      g.addEdge(1, 2);
            \n    g.addEdge(2, 0);
            \n  g.addEdge(2, 3);
            \ng.addEdge(3, 3);
            \n
            \n          System.out.println("Following is Breadth First Traversal "+
            \n        "(starting from vertex 2)");
            \n
            \n          g.BFS(2);
            \n        }
            \n      }
            \n\nOutput:
            \nFollowing is Breadth First Traversal (starting from vertex 2)
            \n2 0 3 1
        </item>
        <!--Depth-First Search-->
        <item>
            Depth-first Search (DFS) is an algorithm for searching a graph or tree data structure.
            The algorithm starts at the root (top) node of a tree and goes as far as it can down a given branch (path),
            and then backtracks until it finds an unexplored path, and then explores it.
            The algorithm does this until the entire graph has been explored.
            Many problems in computer science can be thought of in terms of graphs. For example, analyzing networks, mapping routes,
            scheduling, and finding spanning trees are graph problems.
            To analyze these problems, graph search algorithms like depth-first search are useful.

            \n\nDepth-first searches are often used as subroutines in other more complex algorithms.
            For example, the matching algorithm, Hopcroft–Karp uses a DFS as part of its algorithm to help find a matching in a graph.
            DFS is also used in tree traversal algorithms, also known as tree searches, which have applications in the the
            travelling salesman problem and the Ford Fulkerson’s algorithm.

            \n\nExample:

            \n\n// Java program to print DFS traversal from a given given graph
            \n import java.io.*;
            \nimport java.util.*;
            \n
            \n          // This class represents a directed graph using adjacency list
            \n        // representation
            \n      class Graph
            \n    {
            \n  private int V;   // No. of vertices
            \n
            \n          // Array  of lists for Adjacency List Representation
            \n        private LinkedList&lt;Integer&gt; adj[];
            \n
            \n          // Constructor
            \n        Graph(int v)
            \n      {
            \n    V = v;
            \n  adj = new LinkedList[v];
            \nfor (int i=0; i&lt;v; ++i)
            \nadj[i] = new LinkedList();
            \n}
            \n
            \n          //Function to add an edge into the graph
            \n        void addEdge(int v, int w)
            \n      {
            \n    adj[v].add(w);  // Add w to v\'s list.
            \n  }
            \n
            \n          // A function used by DFS
            \n        void DFSUtil(int v,boolean visited[])
            \n      {
            \n    // Mark the current node as visited and print it
            \n  visited[v] = true;
            \nSystem.out.print(v+" ");
            \n
            \n          // Recur for all the vertices adjacent to this vertex
            \n        Iterator&lt;Integer&gt; i = adj[v].listIterator();
            \n      while (i.hasNext())
            \n    {
            \n  int n = i.next();
            \nif (!visited[n])
            \nDFSUtil(n, visited);
            \n}            }
            \n
            \n          // The function to do DFS traversal. It uses recursive DFSUtil()
            \n        void DFS(int v)
            \n      {
            \n    // Mark all the vertices as not visited(set as
            \n  // false by default in java)
            \nboolean visited[] = new boolean[V];
            \n
            \n          // Call the recursive helper function to print DFS traversal
            \n        DFSUtil(v, visited);
            \n      }
            \n
            \n          public static void main(String args[])
            \n        {
            \n      Graph g = new Graph(4);
            \n
            \n          g.addEdge(0, 1);
            \n        g.addEdge(0, 2);
            \n      g.addEdge(1, 2);
            \n    g.addEdge(2, 0);
            \n  g.addEdge(2, 3);
            \ng.addEdge(3, 3);
            \n
            \n          System.out.println("Following is Depth First Traversal "+
            \n        "(starting from vertex 2)");
            \n
            \n          g.DFS(2);
            \n        }            }
            \n\nOutput:
            \nFollowing is Depth First Traversal (starting from vertex 2)
            \n2 0 1 3

        </item>
        <!--Topological Sort-->
        <item>
            Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv,
            vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.

            \n\nWe recommend to first see implementation of DFS here. We can modify DFS to find Topological Sorting of a graph.
            In DFS, we start from a vertex, we first print it and then recursively call DFS for its adjacent vertices.
            In topological sorting, we use a temporary stack. We don’t print the vertex immediately, we first recursively
            call topological sorting for all its adjacent vertices, then push it to a stack. Finally, print contents of stack.

            \nNote that a vertex is pushed to stack only when all of its adjacent vertices (and their adjacent vertices and so on)
            are already in stack.

            \n\nExample:
            \n            // A Java program to print topological sorting of a DAG
            \n          import java.io.*;
            \n        import java.util.*;
            \n
            \n          // This class represents a directed graph using adjacency
            \n        // list representation
            \n      class Graph
            \n    {
            \n  private int V;   // No. of vertices
            \nprivate LinkedList&lt;Integer&gt; adj[]; // Adjacency List
            \n
            \n          //Constructor
            \n        Graph(int v)
            \n      {
            \n    V = v;
            \n  adj = new LinkedList[v];
            \nfor (int i=0; i&lt;v; ++i)
            \nadj[i] = new LinkedList();
            \n }
            \n
            \n          // Function to add an edge into the graph
            \n        void addEdge(int v,int w) { adj[v].add(w); }
            \n
            \n          // A recursive function used by topologicalSort
            \n        void topologicalSortUtil(int v, boolean visited[],
            \n      Stack stack)
            \n    {
            \n  // Mark the current node as visited.
            \nvisited[v] = true;
            \nInteger i;
            \n
            \n          // Recur for all the vertices adjacent to this
            \n      // vertex
            \n    Iterator&lt;Integer&gt; it = adj[v].iterator();
            \n    while (it.hasNext())
            \n      {
            \n  i = it.next();
            \nif (!visited[i])
            \ntopologicalSortUtil(i, visited, stack);
            \n}
            \n
            \n          // Push current vertex to stack which stores result
            \n        stack.push(new Integer(v));
            \n      }
            \n
            \n          // The function to do Topological Sort. It uses
            \n        // recursive topologicalSortUtil()
            \n      void topologicalSort()
            \n    {
            \n  Stack stack = new Stack();
            \n
            \n          // Mark all the vertices as not visited
            \n      boolean visited[] = new boolean[V];
            \n        for (int i = 0; i &lt; V; i++)
            \n      visited[i] = false;
            \n
            \n          // Call the recursive helper function to store
            \n        // Topological Sort starting from all vertices
            \n      // one by one
            \n    for (int i = 0; i &lt; V; i++)
            \n  if (visited[i] == false)
            \ntopologicalSortUtil(i, visited, stack);
            \n
            \n          // Print contents of stack
            \n        while (stack.empty()==false)
            \n      System.out.print(stack.pop() + " ");
            \n    }
            \n
            \n          // Driver method
            \n        public static void main(String args[])
            \n      {
            \n    // Create a graph given in the above diagram
            \n  Graph g = new Graph(6);
            \ng.addEdge(5, 2);
            \n          g.addEdge(5, 0);
            \n        g.addEdge(4, 0);
            \n      g.addEdge(4, 1);
            \n    g.addEdge(2, 3);
            \n  g.addEdge(3, 1);
            \n
            \n          System.out.println("Following is a Topological " +
            \n        "sort of the given graph");
            \n      g.topologicalSort();
            \n    }            }

            \n\nOutput:
            \nFollowing is a Topological Sort of the given graph
            \n 5 4 2 3 1 0
        </item>
        <!--Strongly Connected Components-->
        <item>
            A directed graph is strongly connected if there is a path between all pairs of vertices.
            A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.

            \n\nWe can find all strongly connected components in O(V+E) time using Kosaraju’s algorithm. Following is detailed Kosaraju’s algorithm.
            \n 1) Create an empty stack ‘S’ and do DFS traversal of a graph. In DFS traversal,
            after calling recursive DFS for adjacent vertices of a vertex, push the vertex to stack.
            \n 2) Reverse directions of all arcs to obtain the transpose graph.
            \n 3) One by one pop a vertex from S while S is not empty. Let the popped vertex be ‘v’. Take v as source and do DFS
            (call DFSUtil(v)). The DFS starting from v prints strongly connected component of v.

            \n\n// Java implementation of Kosaraju\'s algorithm to print all SCCs
            \nimport java.io.*;
            \nimport java.util.*;
            \nimport java.util.LinkedList;
            \n
            \n          // This class represents a directed graph using adjacency list
            \n        // representation
            \n      class Graph
            \n    {
            \n  private int V;   // No. of vertices
            \nprivate LinkedList&lt;Integer&gt; adj[]; //Adjacency List
            \n
            \n          //Constructor
            \n        Graph(int v)
            \n      {
            \n    V = v;
            \n  adj = new LinkedList[v];
            \nfor (int i=0; i&lt;v; ++i)
            \nadj[i] = new LinkedList();
            \n}
            \n
            \n          //Function to add an edge into the graph
            \n        void addEdge(int v, int w)  { adj[v].add(w); }
            \n
            \n          // A recursive function to print DFS starting from v
            \n       void DFSUtil(int v,boolean visited[])
            \n    {
            \n      // Mark the current node as visited and print it
            \n    visited[v] = true;
            \n  System.out.print(v + " ");
            \n
            \n          int n;
            \n
            \n          // Recur for all the vertices adjacent to this vertex
            \n        Iterator&lt;Integer&gt; i =adj[v].iterator();
            \n      while (i.hasNext())
            \n    {
            \n  n = i.next();
            \nif (!visited[n])
            \nDFSUtil(n,visited);
            \n}
            \n}
            \n
            \n          // Function that returns reverse (or transpose) of this graph
            \n        Graph getTranspose()
            \n      {
            \n    Graph g = new Graph(V);
            \n    for (int v = 0; v &lt; V; v++)
            \n  {
            \n// Recur for all the vertices adjacent to this vertex
            \nIterator&lt;Integer&gt; i =adj[v].listIterator();
            \n           while(i.hasNext())
            \n         g.adj[i.next()].add(v);
            \n       }
            \n     return g;
            \n   }
            \n
            \n          void fillOrder(int v, boolean visited[], Stack stack)
            \n        {
            \n      // Mark the current node as visited and print it
            \n    visited[v] = true;
            \n
            \n          // Recur for all the vertices adjacent to this vertex
            \n        Iterator&lt;Integer&gt; i = adj[v].iterator();
            \n      while (i.hasNext())
            \n    {
            \n  int n = i.next();
            \nif(!visited[n])
            \nfillOrder(n, visited, stack);
            \n}
            \n
            \n          // All vertices reachable from v are processed by now,
            \n        // push v to Stack
            \n      stack.push(new Integer(v));
            \n    }
            \n
            \n          // The main function that finds and prints all strongly
            \n        // connected components
            \n      void printSCCs()
            \n    {
            \n  Stack stack = new Stack();
            \n
            \n          // Mark all the vertices as not visited (For first DFS)
            \n        boolean visited[] = new boolean[V];
            \n      for(int i = 0; i &lt; V; i++)
            \n    visited[i] = false;
            \n
            \n          // Fill vertices in stack according to their finishing
            \n        // times
            \n      for (int i = 0; i &lt; V; i++)
            \n    if (visited[i] == false)
            \n  fillOrder(i, visited, stack);
            \n
            \n          // Create a reversed graph
            \n        Graph gr = getTranspose();
            \n
            \n        // Mark all the vertices as not visited (For second DFS)
            \n          for (int i = 0; i &lt; V; i++)
            \n      visited[i] = false;
            \n
            \n          // Now process all vertices in order defined by Stack
            \n        while (stack.empty() == false)
            \n      {
            \n    // Pop a vertex from stack
            \n  int v = (int)stack.pop();
            \n
            \n          // Print Strongly connected component of the popped vertex
            \n        if (visited[v] == false)
            \n      {
            \n    gr.DFSUtil(v, visited);
            \n  System.out.println();
            \n}
            \n}
            \n }
            \n
            \n          // Driver method
            \n        public static void main(String args[])
            \n      {
            \n    // Create a graph given in the above diagram
            \n  Graph g = new Graph(5);
            \n g.addEdge(1, 0);
            \ng.addEdge(0, 2);
            \ng.addEdge(2, 1);
            \ng.addEdge(0, 3);
            \ng.addEdge(3, 4);
            \n
            \n          System.out.println("Following are strongly connected components "+
            \n        "in given graph ");
            \n      g.printSCCs();
            \n    }            }

            \n\nOutput:
            \nFollowing are strongly connected components in given graph
            \n0 1 2
            \n3
            \n4

            \n\nTime Complexity: The above algorithm calls DFS, fins reverse of the graph and again calls DFS.
            DFS takes O(V+E) for a graph represented using adjacency list. Reversing a graph also takes O(V+E) time.
            For reversing the graph, we simple traverse all adjacency lists.

            \n\nThe above algorithm is asymptotically best algorithm, but there are other algorithms like Tarjan’s algorithm and
            path-based which have same time complexity but find SCCs using single DFS.
        </item>
        <!--Minimum Spanning Trees-->
        <item>
            Given a connected and undirected graph, a spanning tree of that graph is a subgraph that is a tree and connects all the
            vertices together. A single graph can have many different spanning trees. A minimum spanning tree (MST) or minimum weight
            spanning tree for a weighted, connected and undirected graph is a spanning tree with weight less than or equal to the weight
            of every other spanning tree. The weight of a spanning tree is the sum of weights given to each edge of the spanning tree.

            \nA minimum spanning tree has (V – 1) edges where V is the number of vertices in the graph.

            \n\nWhy minimum spanning trees?
            \nThe standard application is to a problem like phone network design. You have a business with several offices;
            you want to lease phone lines to connect them up with each other; and the phone company charges different amounts of money to
            connect different pairs of cities. You want a set of lines that connects all your offices with a minimum total cost.
            It should be a spanning tree, since if a network isn\'t a tree you can always remove some edges and save money.
            \nA less obvious application is that the minimum spanning tree can be used to approximately solve the traveling salesman problem.
            A convenient formal way of defining this problem is to find the shortest path that visits each point at least once.

            \n\nKruskal\'s and Prim\'s algorithms are used to find the minimum spanning tree.
        </item>
        <!--Greedy Algorithms-->
        <item>
            A greedy algorithm works by choosing the best possible answer in each step and then moving on to the next step until it
            reaches the end, without regard for the overall solution. It only hopes that the path it takes is the globally optimum one,
            but as proven time and again, this method does not often come up with a globally optimum solution. In fact, it is entirely
            possible that the most optimal short-term solutions lead to the worst possible global outcome.
            \nIt picks the best immediate output, but does not consider the big picture, hence it is considered greedy.

            Think of it as taking a lot of shortcuts in a manufacturing business: in the short term large amounts are saved in manufacturing
            cost, but this eventually leads to downfall since quality is compromised, resulting in product returns and low sales as
            customers become acquainted with the "cheap" product. But this is not always the case, there are a lot of applications
            where the greedy algorithm works best to find or approximate the globally optimum solution such as in constructing a
            Huffman tree or a decision learning tree.
        </item>
        <!--Kruskals Algorithm-->
        <item>
            Kruskal\'s algorithm to find the minimum cost spanning tree uses the greedy approach.
            This algorithm treats the graph as a forest and every node it has as an individual tree.
            A tree connects to another only and only if, it has the least cost among all available options and does not violate MST properties.

            \n\nBelow are the steps for finding MST using Kruskal’s algorithm
            \n
            \n          1. Sort all the edges in non-decreasing order of their weight.
            \n        2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If cycle is not formed, include this edge. Else, discard it.
            \n      3. Repeat step#2 until there are (V-1) edges in the spanning tree.

            \n\n Implementation:
            \n\n// Java program for Kruskal\'s algorithm to find Minimum
            \n// Spanning Tree of a given connected, undirected and
            \n// weighted graph
            \nimport java.util.*;
            \nimport java.lang.*;
            \nimport java.io.*;
            \n
            \n          class Graph
            \n        {
            \n      // A class to represent a graph edge
            \n    class Edge implements Comparable&lt;Edge&gt;
            \n  {
            \nint src, dest, weight;
            \n
            \n          // Comparator function used for sorting edges
            \n        // based on their weight
            \n      public int compareTo(Edge compareEdge)
            \n    {
            \n  return this.weight-compareEdge.weight;
            \n}            };
            \n
            \n          // A class to represent a subset for union-find
            \n        class subset
            \n      {
            \n    int parent, rank;
            \n  };
            \n
            \n          int V, E;    // V-> no. of vertices &amp; E->no.of edges
            \n        Edge edge[]; // collection of all edges
            \n
            \n          // Creates a graph with V vertices and E edges
            \n      Graph(int v, int e)
            \n        {
            \n    V = v;
            \n  E = e;
            \nedge = new Edge[E];
            \nfor (int i=0; i&lt;e; ++i)
            \nedge[i] = new Edge();
            \n}
            \n
            \n          // A utility function to find set of an element i
            \n        // (uses path compression technique)
            \n      int find(subset subsets[], int i)
            \n    {
            \n  // find root and make root as parent of i (path compression)
            \nif (subsets[i].parent != i)
            \nsubsets[i].parent = find(subsets, subsets[i].parent);
            \n
            \n          return subsets[i].parent;
            \n        }
            \n
            \n        // A function that does union of two sets of x and y
            \n          // (uses union by rank)
            \n      void Union(subset subsets[], int x, int y)
            \n    {
            \n  int xroot = find(subsets, x);
            \nint yroot = find(subsets, y);
            \n
            \n          // Attach smaller rank tree under root of high rank tree
            \n        // (Union by Rank)
            \n      if (subsets[xroot].rank &lt; subsets[yroot].rank)
            \n    subsets[xroot].parent = yroot;
            \n  else if (subsets[xroot].rank > subsets[yroot].rank)
            \nsubsets[yroot].parent = xroot;
            \n
            \n          // If ranks are same, then make one as root and increment
            \n        // its rank by one
            \n      else
            \n    {
            \n  subsets[yroot].parent = xroot;
            \nsubsets[xroot].rank++;
            \n}            }
            \n
            \n          // The main function to construct MST using Kruskal\'s algorithm
            \n        void KruskalMST()
            \n      {
            \n    Edge result[] = new Edge[V];  // Tnis will store the resultant MST
            \n  int e = 0;  // An index variable, used for result[]
            \nint i = 0;  // An index variable, used for sorted edges
            \nfor (i=0; i&lt;V; ++i)
            \nresult[i] = new Edge();
            \n
            \n          // Step 1:  Sort all the edges in non-decreasing order of their
            \n        // weight.  If we are not allowed to change the given graph, we
            \n      // can create a copy of array of edges
            \n    Arrays.sort(edge);
            \n
            \n          // Allocate memory for creating V ssubsets
            \n        subset subsets[] = new subset[V];
            \n      for(i=0; i&lt;V; ++i)
            \n    subsets[i]=new subset();
            \n
            \n          // Create V subsets with single elements
            \n        for (int v = 0; v &lt; V; ++v)
            \n      {
            \n    subsets[v].parent = v;
            \n  subsets[v].rank = 0;
            \n}
            \n
            \n          i = 0;  // Index used to pick next edge
            \n
            \n          // Number of edges to be taken is equal to V-1
            \n        while (e &lt; V - 1)
            \n      {
            \n    // Step 2: Pick the smallest edge. And increment
            \n  // the index for next iteration
            \nEdge next_edge = new Edge();
            \nnext_edge = edge[i++];
            \n
            \n          int x = find(subsets, next_edge.src);
            \n        int y = find(subsets, next_edge.dest);
            \n
            \n        // If including this edge does\'t cause cycle,
            \n          // include it in result and increment the index
            \n      // of result for next edge
            \n  if (x != y)
            \n    {
            \nresult[e++] = next_edge;
            \nUnion(subsets, x, y);
            \n }
            \n// Else discard the next_edge
            \n }
            \n
            \n          // print the contents of result[] to display
            \n        // the built MST
            \n      System.out.println("Following are the edges in " +
            \n    "the constructed MST");
            \n  for (i = 0; i &lt; e; ++i)
            \nSystem.out.println(result[i].src+" -- " +
            \nresult[i].dest+" == " + result[i].weight);
            \n}
            \n
            \n          // Driver Program
            \n        public static void main (String[] args)
            \n      {
            \n
            \n          /* Let us create following weighted graph
            \n       10
            \n     0--------1
            \n   |  \     |
            \n        6|   5\   |15
            \n      |      \ |
            \n    2--------3
            \n  4       */
            \n int V = 4;  // Number of vertices in graph
            \nint E = 5;  // Number of edges in graph
            \nGraph graph = new Graph(V, E);
            \n
            \n          // add edge 0-1
            \n        graph.edge[0].src = 0;
            \n      graph.edge[0].dest = 1;
            \n    graph.edge[0].weight = 10;
            \n
            \n          // add edge 0-2
            \n        graph.edge[1].src = 0;
            \n    graph.edge[1].dest = 2;
            \n      graph.edge[1].weight = 6;

            \n  // add edge 0-3
            \n graph.edge[2].src = 0;
            \ngraph.edge[2].dest = 3;
            \ngraph.edge[2].weight = 5;
            \n
            \n          // add edge 1-3
            \n        graph.edge[3].src = 1;
            \n      graph.edge[3].dest = 3;
            \n    graph.edge[3].weight = 15;
            \n
            \n          // add edge 2-3
            \n      graph.edge[4].src = 2;
            \n        graph.edge[4].dest = 3;
            \n      graph.edge[4].weight = 4;
            \n
            \n          graph.KruskalMST();
            \n        }            }
            \n\n Output:
            \nFollowing are the edges in the constructed MST
            \n2 -- 3 == 4
            \n0 -- 3 == 5
            \n0 -- 1 == 10
        </item>
        <!--Prims Algorithm-->
        <item>
            Like Kruskal’s algorithm, Prim’s algorithm is also a Greedy algorithm. It starts with an empty spanning tree. The idea is to
            maintain two sets of vertices. The first set contains the vertices already included in the MST, the other set contains the
            vertices not yet included. At every step, it considers all the edges that connect the two sets, and picks the minimum weight
            edge from these edges. After picking the edge, it moves the other endpoint of the edge to the set containing MST.
            \nA group of edges that connects two set of vertices in a graph is called cut in graph theory.
            So, at every step of Prim’s algorithm, we find a cut (of two sets, one contains the vertices already included in MST and other
            contains rest of the verices), pick the minimum weight edge from the cut and include this vertex to MST Set
            (the set that contains already included vertices).

            \n\nImplementation:
            \n\n// A Java program for Prim\'s Minimum Spanning Tree (MST) algorithm.
            \n            // The program is for adjacency matrix representation of the graph
            \n
            \n          import java.util.*;
            \n        import java.lang.*;
            \n      import java.io.*;
            \n
            \n          class MST
            \n        {
            \n      // Number of vertices in the graph
            \n    private    static final int V=5;
            \n
            \n          // A utility function to find the vertex with minimum key
            \n        // value, from the set of vertices not yet included in MST
            \n      int minKey(int key[], Boolean mstSet[])
            \n    {
            \n  // Initialize min value
            \nint min = Integer.MAX_VALUE, min_index=-1;
            \n
            \n          for (int v = 0; v &lt; V; v++)
            \n        if (mstSet[v] == false &amp;&amp; key[v] &lt; min)
            \n      {
            \n    min = key[v];
            \n  min_index = v;
            \n}
            \n
            \n          return min_index;
            \n        }
            \n
            \n          // A utility function to print the constructed MST stored in
            \n        // parent[]
            \n      void printMST(int parent[], int n, int graph[][])
            \n    {
            \n  System.out.println("Edge   Weight");
            \nfor (int i = 1; i &lt; V; i++)
            \nSystem.out.println(parent[i]+" - "+ i+"    "+
            \ngraph[i][parent[i]]);
            \n}
            \n
            \n          // Function to construct and print MST for a graph represented
            \n        //  using adjacency matrix representation
            \n      void primMST(int graph[][])
            \n    {
            \n  // Array to store constructed MST
            \nint parent[] = new int[V];
            \n
            \n          // Key values used to pick minimum weight edge in cut
            \n        int key[] = new int [V];
            \n
            \n          // To represent set of vertices not yet included in MST
            \n        Boolean mstSet[] = new Boolean[V];
            \n
            \n          // Initialize all keys as INFINITE
            \n        for (int i = 0; i &lt; V; i++)
            \n      {
            \n    key[i] = Integer.MAX_VALUE;
            \n  mstSet[i] = false;
            \n}
            \n
            \n          // Always include first 1st vertex in MST.
            \n        key[0] = 0;     // Make key 0 so that this vertex is
            \n      // picked as first vertex
            \n    parent[0] = -1; // First node is always root of MST
            \n
            \n          // The MST will have V vertices
            \n        for (int count = 0; count &lt; V-1; count++)
            \n      {
            \n    // Pick thd minimum key vertex from the set of vertices
            \n  // not yet included in MST
            \nint u = minKey(key, mstSet);
            \n
            \n          // Add the picked vertex to the MST Set
            \n        mstSet[u] = true;
            \n
            \n          // Update key value and parent index of the adjacent
            \n        // vertices of the picked vertex. Consider only those
            \n      // vertices which are not yet included in MST
            \n    for (int v = 0; v &lt; V; v++)
            \n
            \n          // graph[u][v] is non zero only for adjacent vertices of m
            \n        // mstSet[v] is false for vertices not yet included in MST
            \n      // Update the key only if graph[u][v] is smaller than key[v]
            \n    if (graph[u][v]!=0 &amp;&amp; mstSet[v] == false &amp;&amp;
            \n  graph[u][v] &lt;  key[v])
            \n{
            \nparent[v]  = u;
            \nkey[v] = graph[u][v];
            \n }
            \n}
            \n
            \n          // print the constructed MST
            \n        printMST(parent, V, graph);
            \n      }
            \n
            \n          public static void main (String[] args)
            \n        {
            \n      /* Let us create the following graph
            \n   2    3
            \n (0)--(1)--(2)
            \n       |    / \   |
            \n         6| 8/   \5 |7
            \n     | /      \ |
            \n   (3)-------(4)
            \n   9          */
            \n MST t = new MST();
            \n   int graph[][] = new int[][] {{0, 2, 0, 6, 0},
            \n {2, 0, 3, 8, 5},
            \n           {0, 3, 0, 0, 7},
            \n         {6, 8, 0, 0, 9},
            \n       {0, 5, 7, 9, 0},
            \n     };
            \n
            \n          // Print the solution
            \n        t.primMST(graph);
            \n
            \n\nOutput:
            \nEdge   Weight
            \n0 - 1    2
            \n1 - 2    3
            \n0 - 3    6
            \n1 - 4    5
        </item>
        <!--Djiktras Algorithm-->
        <item>
            Given a graph and a source vertex in the graph, find shortest paths from source to all vertices in the given graph.

            \n\nDijkstra’s algorithm is very similar to Prim’s algorithm for minimum spanning tree. Like Prim’s MST,
            we generate a SPT (shortest path tree) with given source as root. We maintain two sets, one set contains
            vertices included in shortest path tree, other set includes vertices not yet included in shortest path tree.
            At every step of the algorithm, we find a vertex which is in the other set (set of not yet included)
            and has a minimum distance from the source.

            \n\nBelow are the detailed steps used in Dijkstra’s algorithm to find the shortest path from a single source vertex to all
            other vertices in the given graph.

            \n\nAlgorithm
            \n 1) Create a set sptSet (shortest path tree set) that keeps track of vertices included in shortest path tree, i.e.,
            whose minimum distance from source is calculated and finalized. Initially, this set is empty.
            \n 2) Assign a distance value to all vertices in the input graph. Initialize all distance values as INFINITE.
            Assign distance value as 0 for the source vertex so that it is picked first.
            \n 3) While sptSet doesn’t include all vertices
            \n ….a) Pick a vertex u which is not there in sptSet and has minimum distance value.
            \n ….b) Include u to sptSet.
            \n ….c) Update distance value of all adjacent vertices of u. To update the distance values, iterate through all adjacent vertices.
            For every adjacent vertex v, if sum of distance value of u (from source) and weight of edge u-v, is
            less than the distance value of v, then update the distance value of v.

            \n\nImplementation:

            \n\n// A Java program for Dijkstra\'s single source shortest path algorithm.
            \n// The program is for adjacency matrix representation of the graph
            \nimport java.util.*;
            \nimport java.lang.*;
            \nimport java.io.*;
            \n
            \n          class ShortestPath
            \n        {
            \n      // A utility function to find the vertex with minimum distance value,
            \n    // from the set of vertices not yet included in shortest path tree
            static final int V=9;
            \n  int minDistance(int dist[], Boolean sptSet[])
            \n{
            \n// Initialize min value
            \nint min = Integer.MAX_VALUE, min_index=-1;
            \n
            \n          for (int v = 0; v &lt; V; v++)
            \n        if (sptSet[v] == false &amp;&amp; dist[v] &lt;= min)
            \n      {
            \n    min = dist[v];
            \n  min_index = v;
            \n}
            \n
            \n          return min_index;
            \n        }
            \n
            \n          // A utility function to print the constructed distance array
            \n        void printSolution(int dist[], int n)
            \n      {
            \n    System.out.println("Vertex   Distance from Source");
            \n  for (int i = 0; i &lt; V; i++)
            \nSystem.out.println(i+" tt "+dist[i]);
            \n}
            \n
            \n          // Funtion that implements Dijkstra\'s single source shortest path
            \n        // algorithm for a graph represented using adjacency matrix
            \n      // representation
            \n    void dijkstra(int graph[][], int src)
            \n  {
            \nint dist[] = new int[V]; // The output array. dist[i] will hold
            \n// the shortest distance from src to i
            \n
            \n          // sptSet[i] will true if vertex i is included in shortest
            \n        // path tree or shortest distance from src to i is finalized
            \n      Boolean sptSet[] = new Boolean[V];
            \n
            \n          // Initialize all distances as INFINITE and stpSet[] as false
            \n        for (int i = 0; i &lt; V; i++)
            \n      {
            \n    dist[i] = Integer.MAX_VALUE;
            \n  sptSet[i] = false;
            \n}
            \n
            \n          // Distance of source vertex from itself is always 0
            \n        dist[src] = 0;
            \n
            \n          // Find shortest path for all vertices
            \n        for (int count = 0; count &lt; V-1; count++)
            \n      {
            \n    // Pick the minimum distance vertex from the set of vertices
            \n  // not yet processed. u is always equal to src in first
            \n// iteration.
            \nint u = minDistance(dist, sptSet);
            \n
            \n          // Mark the picked vertex as processed
            \n        sptSet[u] = true;
            \n
            \n          // Update dist value of the adjacent vertices of the
            \n        // picked vertex.
            \n      for (int v = 0; v &lt; V; v++)
            \n
            \n          // Update dist[v] only if is not in sptSet, there is an
            \n        // edge from u to v, and total weight of path from src to
            \n      // v through u is smaller than current value of dist[v]
            \n    if (!sptSet[v] &amp;&amp; graph[u][v]!=0 &amp;&amp;
            \n  dist[u] != Integer.MAX_VALUE &amp;&amp;
            \ndist[u]+graph[u][v] &lt; dist[v])
            \ndist[v] = dist[u] + graph[u][v];
            \n}
            \n
            \n          // print the constructed distance array
            \n        printSolution(dist, V);
            \n      }
            \n
            \n          // Driver method
            \n        public static void main (String[] args)
            \n      {
            \n    /* Let us create the example graph discussed above */
            \n  int graph[][] = new int[][]{{0, 4, 0, 0, 0, 0, 0, 8, 0},
            \n            {4, 0, 8, 0, 0, 0, 0, 11, 0},
            \n          {0, 8, 0, 7, 0, 4, 0, 0, 2},
            \n        {0, 0, 7, 0, 9, 14, 0, 0, 0},
            \n      {0, 0, 0, 9, 0, 10, 0, 0, 0},
            \n    {0, 0, 4, 14, 10, 0, 2, 0, 0},
            \n  {0, 0, 0, 0, 0, 2, 0, 1, 6},
            \n            {8, 11, 0, 0, 0, 0, 1, 0, 7},
            \n          {0, 0, 2, 0, 0, 0, 6, 7, 0}
            \n        };
            \n      ShortestPath t = new ShortestPath();
            \n    t.dijkstra(graph, 0);

            \n\nOutput:
            \nVertex   Distance from Source
            \n0                0
            \n1                4
            \n2                12
            \n3                19
            \n4                21
            \n5                11
            \n6                9
            \n7                8
            \n8                14

        </item>
        <!--The floyd-warshall Algorithm-->
        <item>
            The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances
            between every pair of vertices in a given edge weighted directed Graph.

            \n\nAlgorithm:
            \nWe initialize the solution matrix same as the input graph matrix as a first step.
            Then we update the solution matrix by considering all vertices as an intermediate vertex.
            The idea is to one by one pick all vertices and updates all shortest paths which include the picked vertex as an intermediate
            vertex in the shortest path. When we pick vertex number k as an intermediate vertex, we already have considered vertices
            {0, 1, 2, .. k-1} as intermediate vertices. For every pair (i, j) of the source and destination vertices respectively,
            there are two possible cases.
            \n\n 1) k is not an intermediate vertex in shortest path from i to j. We keep the value of dist[i][j] as it is.
            \n\n 2) k is an intermediate vertex in shortest path from i to j. We update the value of dist[i][j] as dist[i][k] + dist[k][j].

            \n\nImplementation:
            \n// A Java program for Floyd Warshall All Pairs Shortest
            \n// Path algorithm.
            \nimport java.util.*;
            \nimport java.lang.*;
            \nimport java.io.*;
            \n
            \n
            \n        class AllPairShortestPath
            \n      {
            \n    final static int INF = 99999, V = 4;
            \n
            \n          void floydWarshall(int graph[][])
            \n        {
            \n      int dist[][] = new int[V][V];
            \n    int i, j, k;
            \n
            \n          /* Initialize the solution matrix same as input graph matrix.
            \n        Or we can say the initial values of shortest distances
            \n      are based on shortest paths considering no intermediate
            \n    vertex. */
            \n  for (i = 0; i &lt; V; i++)
            \n  for (j = 0; j &lt; V; j++)
            \n dist[i][j] = graph[i][j];
            \n
            \n          /* Add all vertices one by one to the set of intermediate
            \n        vertices.
            \n      ---> Before start of an iteration, we have shortest
            \n    distances between all pairs of vertices such that
            \n  the shortest distances consider only the vertices in
            \n set {0, 1, 2, .. k-1} as intermediate vertices.
            \n ----> After the end of an iteration, vertex no. k is added
            \n to the set of intermediate vertices and the set
            \n becomes {0, 1, 2, .. k} */
            \nfor (k = 0; k &lt; V; k++)
            \n{
            \n// Pick all vertices as source one by one
            \n            for (i = 0; i &lt; V; i++)
            \n          {
            \n        // Pick all vertices as destination for the
            \n      // above picked source
            \n    for (j = 0; j &lt; V; j++)
            \n  {
            \n// If vertex k is on the shortest path from
            \n// i to j, then update the value of dist[i][j]
            \nif (dist[i][k] + dist[k][j] &lt; dist[i][j])
            \ndist[i][j] = dist[i][k] + dist[k][j];
            \n}}         }
            \n
            \n          // Print the shortest distance matrix
            \n        printSolution(dist);
            \n      }
            \n
            \n          void printSolution(int dist[][])
            \n        {
            \n      System.out.println("The following matrix shows the shortest "+
            \n    "distances between every pair of vertices");
            \n  for (int i=0; i&lt;V; ++i)
            \n{
            for (int j=0; j&lt;V; ++j)
            \n            {
            \n          if (dist[i][j]==INF)
            \n        System.out.print("INF ");
            \n      else
            \n    System.out.print(dist[i][j]+"   ");
            \n  }
            \nSystem.out.println();
            \n}            }
            \n
            \n          // Driver program to test above function
            \n        public static void main (String[] args)
            \n      {
            \n    /* Let us create the following weighted graph
            \n  10
            \n          (0)------->(3)
            \n          |         /|\
            \n        5 |          |
            \n      |          | 1
            \n    \|/         |
            \n  (1)------->(2)
            \n 3           */
            \n int graph[][] = { {0,   5,  INF, 10},
            \n            {INF, 0,   3, INF},
            \n          {INF, INF, 0,   1},
            \n        {INF, INF, INF, 0}
            \n      };
            \n    AllPairShortestPath a = new AllPairShortestPath();
            \n
            \n          // Print the solution
            \n        a.floydWarshall(graph);
            \n      }            }

            \n\nOutput:
            \nFollowing matrix shows the shortest distances between every pair of vertices
            \n  0      5      8      9
            \n INF     0      3      4
            \n INF   INF      0      1
            \n INF   INF     INF     0
        </item>
        <!--Flow networks-->
        <item>
            A Flow network is a directed graph where each edge has a capacity and a flow. They are typically used to model problems
            involving the transport of items between locations, using a network of routes with limited capacity.

            \n\nExamples include modeling traffic on a network of roads, fluid in a network of pipes, and electricity in a network of
            circuit components.

            \n\nFor example, a company might want to ship packages from Los Angeles to New York City using trucks to transport between
            intermediate cities. If there is only one truck for the route connecting a pair of cities and each truck has a maximum load,
            then the graph describing the transportation options will be a flow network. Each node will represent a city and each edge
            will represent a truck route between those cities (e.g. a highway). The capacity for a particular route will be the maximum
            load the truck for that route can carry. Using this model, the company can decide how to split their packages between trucks
            so that the packages can reach their destination using the available routes and trucks.
            The number of packages the company decides to ship along a particular truck route is the flow for that route.

            \n\nFlow Network Problems:
            \n\nThere are several different problems that can be modeled as flow networks. A few in particular are common and show up in
            very diverse fields. Since flow network problems have been well studied, each is only briefly described here,
            along with some example applications. More in depth discussions are linked to in each problem description.

            \n\nMaximum Flow:
            \nThe maximum flow problem is the problem of finding the maximum admissible flow through a single source,
            single sink flow network. It was originally formulated in 1954 by mathematicians attempting to model Soviet
            railway traffic flow. Well known solutions for the maximum flow problem include the Ford-Fulkerson algorithm,
            Edmonds-Karp algorithm, and Dinic\'s algorithm.
            \nMaximum flow algorithms have an enormous range of applications. Examples include airline flight crew scheduling,
            the circulation-demand problem (where goods with location dependent demand must be transported using routes with
            limited capacity), and determining when during a sports season to eliminate losing teams.

            \n\nMinimum Cost Flow:
            \nMinimum cost flow is the problem of finding the cheapest possible way to send a certain amount of flow through a network.
            This requires extending the flow network so that each edge  now also has an associated cost  per unit of flow per edge.
            The total cost of a flow is then a(e) \cdot f(e)). Minimum cost flow can be solved using linear programming since the
            objective function is linear, as are the constraints.
            \nOne common application of minimum cost flow is in determining the cheapest way to transport items from point A to point B,
            given some routes with limited capacity and associated cost. For example, truck routes may have greater capacity,
            but higher cost (in terms of time), while plane routes may have lesser capacity, but lower cost.
            Thus, a company looking to minimize the cost of transport would seek to model this trade-off between capacity and cost
            using minimum cost flow.

            \n\nMaximal Bipartite Matching:
            \nMaximal bipartite matching is the problem of determining the maximal matching for a bipartite graph.
            If the graph is modeled as a flow network (flow from one set of nodes to the other), various flow algorithms
            can be used to solve it. For example, the Ford-Fulkerson algorithm can solve bipartite matching in unweighted graphs,
            as can the Hopcroft–Karp algorithm, which does so more efficiently since it is designed specially for bipartite graphs.
            For the weighted graph case (called the assignment problem), the best known algorithm is the Hungarian algorithm.
            \nMost interesting maximal bipartite matching is framed in terms of the assignment problem.
            The most common formulation of the assignment problem is that given a certain number of agents and
            a certain number of tasks, as well as a cost/benefit for each agent on each task, assign each agent to exactly one
            task such that the cost/benefit is minimized/maximized. Many common problems cans be formulated in terms of the
            assignment problem, so the applications are extremely diverse. Applications include scheduling, resource allocation,
            and transportation segmentation.

            \n\nTransportation Problem:
            \nA more general version of the assignment problem is the transportation problem. It turns out the transportation problem is
            also a more specific version of the minimum cost problem. The transportation problem is similar to the assignment problem,
            but instead of each agent being assigned to exactly one task, each agent can split their time among multiple tasks and
            each task may by attended to by multiple agents. Thus, some agents and tasks may not be assigned.
            \nThe transportation problem, like its name suggests, is sometimes described in terms of mines and factories.
            If mines supply factories with ore, then the transportation problem reduces to determining the most cost effective
            way to transport ore from individual mines to individual factories. Thus, ore from one mine may be sent to multiple
            factories, while one factory may use the ore from many mines. In this case, the cost function is dependent on the
            Euclidean distance between each mine and factory, as well as the cost of available transportation methods between the two.
            Obviously, mining isn\'t the only industry whose transportation concerns can be formulated in this fashion,
            so the problem itself is very general, as are its applications.
        </item>
        <!--The ford fulkerson method-->
        <item>
            The Ford-Fulkerson algorithm is an algorithm that tackles the max-flow min-cut problem.
            That is, given a network with vertices and edges between those vertices that have certain weights,
            how much "flow" can the network process at a time? Flow can mean anything, but typically it means data through a computer network.

            \n\nIt was discovered in 1956 by Ford and Fulkerson. This algorithm is sometimes referred to as a method because parts of
            its protocol are not fully specified and can vary from implementation to implementation. An algorithm typically refers to a
            specific protocol for solving a problem, whereas a method is a more general approach to a problem.

            \n\nThe Ford-Fulkerson algorithm assumes that the input will be a graph, G, along with a source vertex, s, and a sink vertex, t.
            The graph is any representation of a weighted graph where vertices are connected by edges of specified weights.
            There must also be a source vertex and sink vertex to understand the beginning and end of the flow network.

            \n\nTime Complexity: Time complexity of the above algorithm is O(max_flow * E). We run a loop while there is an augmenting path.
            In worst case, we may add 1 unit flow in every iteration. Therefore the time complexity becomes O(max_flow * E).

            \n\nImplementation

            \n\n// Java program for implementation of Ford Fulkerson algorithm
            \nimport java.util.*;
            \nimport java.lang.*;
            \nimport java.io.*;
            \nimport java.util.LinkedList;

            \n\nclass MaxFlow
            \n{
            \nstatic final int V = 6;    //Number of vertices in graph

            \n/* Returns true if there is a path from source \'s\' to sink
            \n            \'t\' in residual graph. Also fills parent[] to store the
            \n          path */
            \n        boolean bfs(int rGraph[][], int s, int t, int parent[])
            \n      {
            \n    // Create a visited array and mark all vertices as not
            \n  // visited
            \nboolean visited[] = new boolean[V];
            \n for(int i=0; i&lt;V; ++i)
            \n visited[i]=false;

            \n// Create a queue, enqueue source vertex and mark
            \n// source vertex as visited
            \n LinkedList&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
            \n queue.add(s);
            \nvisited[s] = true;
            \n parent[s]=-1;
            \n
            \n          // Standard BFS Loop
            \n        while (queue.size()!=0)
            \n      {
            \n    int u = queue.poll();
            \n
            \n          for (int v=0; v &lt; V; v++)
            \n        {
            \n      if (visited[v]==false &amp;&amp; rGraph[u][v] > 0)
            \n    {
            \n  queue.add(v);
            \nparent[v] = u;
            \n visited[v] = true;
            \n }
            \n }
            \n }
            \n
            \n          // If we reached sink in BFS starting from source, then
            \n        // return true, else false
            \n    return (visited[t] == true);
            \n      }
            \n
            \n          // Returns tne maximum flow from s to t in the given graph
            \n        int fordFulkerson(int graph[][], int s, int t)
            \n      {
            \n    int u, v;
            \n
            \n          // Create a residual graph and fill the residual graph
            \n        // with given capacities in the original graph as
            \n      // residual capacities in residual graph
            \n
            \n          // Residual graph where rGraph[i][j] indicates
            \n        // residual capacity of edge from i to j (if there
            \n      // is an edge. If rGraph[i][j] is 0, then there is
            \n    // not)
            \n  int rGraph[][] = new int[V][V];
            \n
            \n          for (u = 0; u &lt; V; u++)
            \n        for (v = 0; v &lt; V; v++)
            \n      rGraph[u][v] = graph[u][v];
            \n
            \n          // This array is filled by BFS and to store path
            \n        int parent[] = new int[V];
            \n
            \n          int max_flow = 0;  // There is no flow initially
            \n
            \n          // Augment the flow while tere is path from source
            \n        // to sink
            \n      while (bfs(rGraph, s, t, parent))
            \n    {
            \n  // Find minimum residual capacity of the edhes
            \n// along the path filled by BFS. Or we can say
            \n// find the maximum flow through the path found.
            \nint path_flow = Integer.MAX_VALUE;
            \nfor (v=t; v!=s; v=parent[v])
            \n{
            \nu = parent[v];
            \npath_flow = Math.min(path_flow, rGraph[u][v]);
            \n}
            \n
            \n          // update residual capacities of the edges and
            \n        // reverse edges along the path
            \n      for (v=t; v != s; v=parent[v])
            \n    {
            \n  u = parent[v];
            \nrGraph[u][v] -= path_flow;
            \nrGraph[v][u] += path_flow;
            \n }
            \n
            \n          // Add path flow to overall flow
            \n        max_flow += path_flow;
            \n      }
            \n
            \n          // Return the overall flow
            \n        return max_flow;
            \n      }
            \n
            \n          // Driver program to test above functions
            \n        public static void main (String[] args) throws java.lang.Exception
            \n      {
            \n    // Let us create a graph shown in the above example
            \n  int graph[][] =new int[][] { {0, 16, 13, 0, 0, 0},
            \n{0, 0, 10, 12, 0, 0},
            \n          {0, 4, 0, 0, 14, 0},
            \n        {0, 0, 9, 0, 0, 20},
            \n      {0, 0, 0, 7, 0, 4},
            \n    {0, 0, 0, 0, 0, 0}
            \n  };
            \nMaxFlow m = new MaxFlow();
            \n
            \n          System.out.println("The maximum possible flow is " +
            \n        m.fordFulkerson(graph, 0, 5));
            \n
            \n          }
            \n        }

            \n\nOutput:

            \n\nThe maximum possible flow is 23

        </item>
        <!--Maximum bipartite matching-->
        <!--<item>-->
            <!---->
        <!--</item>-->

        <!--Push Relabel Algorithm-->
        <!--<item>-->
        <!---->
        <!--</item>-->

    </string-array>


</resources>